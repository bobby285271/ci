
<!DOCTYPE HTML>
<html class="no-js bg" lang="zh-cmn-Hans">
<head>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<meta charset="UTF-8">

<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">

<meta name="renderer" content="webkit">

<meta name="theme-color" content="#3a3f51" />
<meta http-equiv="x-dns-prefetch-control" content="on">
<title>2020 Nowcoder Basic Algorithm Training Camp Solutions - Dasyatis</title>
<link rel="icon" type="image/ico" href="https://bobby285271.coding.net/p/img/d/img/git/raw/master/favicon.ico">
<meta name="description" content="颓废了一个寒假，Codeforces 打来打去都是 Specialist，菜的一批。POJ 又刷到怀疑人生。后来被 Kaidora 神犇安排了这个集训营。当时已经是第四场要开始了，还是去了。果然..." />
<meta name="keywords" content="Algorithm,Contest,Nowcoder" />
<meta name="generator" content="Typecho 1.2/18.1.29" />
<meta name="template" content="handsome" />
<link rel="alternate" type="application/rss+xml" title="2020 Nowcoder Basic Algorithm Training Camp Solutions &raquo; Dasyatis &raquo; RSS 2.0" href="../../../feed/2020/02/09/2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html" />
<link rel="alternate" type="application/rdf+xml" title="2020 Nowcoder Basic Algorithm Training Camp Solutions &raquo; Dasyatis &raquo; RSS 1.0" href="../../../feed/rss/2020/02/09/2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html" />
<link rel="alternate" type="application/atom+xml" title="2020 Nowcoder Basic Algorithm Training Camp Solutions &raquo; Dasyatis &raquo; ATOM 1.0" href="../../../feed/atom/2020/02/09/2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html" />
<script type="text/x-mathjax-config">
        MathJax.Hub.Config({messageStyle: "none",tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>

<link href="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet">

<link rel="stylesheet" href="../../../../usr/themes/handsome/assets/css/function.min.css%3Fv=6.0.020191205.css" type="text/css" />
<link rel="stylesheet" href="../../../../usr/themes/handsome/assets/css/handsome.min.css%3Fv=6.0.020191205.css" type="text/css" />

<link rel="stylesheet" href="../../../../usr/themes/handsome/assets/css/features/jquery.fancybox.min.css%3Fv=6.0.020191205.css" type="text/css" />
<link rel="stylesheet" href="../../../../usr/themes/handsome/assets/css/features/code/vs.min.css%3Fv=6.0.020191205.css" type="text/css" />

<link rel="stylesheet" href="../../../../usr/themes/handsome/assets/css/font.min.css%3Fv=6.0.020191205.css" type="text/css" />
<style type="text/css">
        
        html.bg {
        background: #EFEFEF
        }
        .cool-transparent .off-screen+* .app-content-body {
        background: #EFEFEF
        }
@media (max-width:767px){
    html.bg {
        background: #EFEFEF
        }
        .cool-transparent .off-screen+* .app-content-body {
        background: #EFEFEF
        }
}
    </style>

<script src="https://cdn.staticfile.org/jquery/2.2.4/jquery.min.js" type="af8c7cddc53fcd57c335e7ed-text/javascript"></script>

<script src="../../../../usr/themes/handsome/assets/js/features/fancyMorph.min.js" type="af8c7cddc53fcd57c335e7ed-text/javascript"></script>
</head>
<body id="body" class="fix-padding">

<div id="alllayout" class="app app-aside-fix container app-header-fixed "> 
<header id="header" class="fix-padding app-header navbar box-shadow-bottom-lg" role="menu">

<div class="text-ellipsis navbar-header bg-white">
<button class="pull-right visible-xs" ui-toggle-class="show animated animated-lento fadeIn" target=".navbar-collapse">
<span class="menu-icons"><i data-feather="search"></i></span>
</button>
<button class="pull-left visible-xs" ui-toggle-class="off-screen animated" target=".app-aside" ui-scroll="app">
<span class="menu-icons"><i data-feather="menu"></i></span>
</button>

<a href="../../../../index.html" class="navbar-brand text-lt">
<i class="fontello fontello-home"></i>
<span class="hidden-folded m-l-xs">Dasyatis</span>
</a>

</div>


<div class="collapse pos-rlt navbar-collapse bg-white">

<form id="searchform1" class="searchform navbar-form navbar-form-sm navbar-left shift" method="post" role="search">
<div class="form-group">
<div class="input-group rounded bg-white-pure box-shadow-wrap-normal">
<input autocomplete="off" id="search_input" type="search" name="s" class="transparent rounded form-control input-sm no-borders padder" required placeholder="输入关键词搜索…">

<ul id="search_tips_drop" class="small-scroll-bar dropdown-menu hide" style="display: block;top: 
                30px; left: 0px;">
</ul>
<span id="search_submit" class="transparent input-group-btn">
<button type="submit" class="transparent btn btn-sm">
<span class="feathericons" id="icon-search"><i data-feather="search"></i></span>
<span class="feathericons animate-spin  hide" id="spin-search"><i data-feather="loader"></i></span>


</button>
</span>
</div>
</div>
</form>
<a href="2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html" style="display: none" id="searchUrl"></a>

<ul class="nav navbar-nav navbar-right">

<li class="dropdown">
<a href="2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html#" data-toggle="dropdown" class="feathericons dropdown-toggle">
<i data-feather="twitch"></i>
<span class="visible-xs-inline">
闲言碎语 </span>
<span class="badge badge-sm up bg-danger pull-right-xs"></span>
</a>

<div class="dropdown-menu w-xl animated fadeInUp">
<div class="panel bg-white">
<div class="panel-heading b-light bg-light">
<strong>
闲言碎语 </strong>
</div>
<div class="list-group" id="smallRecording">
<a href="../../../cross.html" class="list-group-item"><span class="clear block m-b-none words_contents">GDM 使用的字体和 GNOME 使用的字体不一样就很烦躁，发现一个简单的解决方法。其实就是登录 gdm 用户然后用 gsettings 改字体，毕竟人家似乎也不管你的 /etc/fonts/local.conf。machinectl shell <span class="__cf_email__" data-cfemail="cfa8aba28f">[email&#160;protected]</span> /bin/bashgsettings set org.gnome.desktop.interface font-name "Noto S...<br><small class="text-muted">2020-5-14 12:19:43</small></span></a> </div>
</div>
</div>
</li>


<li class="dropdown" id="easyLogin">
<a onclick="if (!window.__cfRLUnblockHandlers) return false; return false" data-toggle="dropdown" class="dropdown-toggle clear" data-toggle="dropdown" data-cf-modified-af8c7cddc53fcd57c335e7ed-="">
<span class="feathericons"><i data-feather="key"></i></span>
<b class="caret"></b>
</a>

<div class="dropdown-menu w-lg wrapper bg-white animated fadeIn" aria-labelledby="navbar-login-dropdown">
<form id="Login_form" action="https://static.bobby285271.top/index.php/action/login?_=e642f35425f42da983c5920ec38e975c" method="post">
<div class="form-group">
<label for="navbar-login-user">用户名</label>
<input type="text" name="name" id="navbar-login-user" class="form-control" placeholder="用户名或电子邮箱"></div>
<div class="form-group">
<label for="navbar-login-password">密码</label>
<input type="password" name="password" id="navbar-login-password" class="form-control" placeholder="密码"></div>
<button style="width: 100%" type="submit" id="login-submit" name="submitLogin" class="btn-rounded box-shadow-wrap-lg btn-gd-primary padder-lg">
<span>登录</span>
<span class="text-active">登录中...</span>
<span class="banLogin_text">刷新页面后登录</span>
<i class="animate-spin  fontello fontello-spinner hide" id="spin-login"></i>
<i class="animate-spin fontello fontello-refresh hide" id="ban-login"></i>
</button>
<input type="hidden" name="referer" value="https://static.bobby285271.top" data-current-url="value"></form>
</div>
</li>

</ul>
</div>

</header>


<aside id="aside" class="app-aside hidden-xs bg-white"> 
<div class="aside-wrap" layout="column">
<div class="navi-wrap scroll-y scroll-hide" flex>

<div class="clearfix hidden-xs text-center hide  show" id="aside-user">
<div class="dropdown wrapper ">
<div ui-nav>
<a href="../../../About.html">
<span class="thumb-lg w-auto-folded avatar m-t-sm  ">
<img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/0782bea86d809777847ee49607ce2ce2_2_1_art.jpg" class="img-full img-circle normal-shadow">
</span>
</a>
</div>
<a href="2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html#" data-toggle="dropdown" class="dropdown-toggle hidden-folded  ">
<span class="clear">
<span class="block m-t-sm">
<strong class="font-bold text-lt">Bobby Rong</strong>
<b class="caret"></b>
</span>
<span class="text-muted text-xs block">SCNUSE 学生</span>
</span>
</a>

<ul class="dropdown-menu animated fadeInRight w hidden-folded no-padder">
<li class="wrapper b-b m-b-sm bg-info m-n">
<span class="arrow top hidden-folded arrow-info"></span>
<div>
<p>晚上好，注意早点休息</p>
</div>
<div class="progress progress-xs m-b-none dker">
<div class="progress-bar bg-white" data-toggle="tooltip" data-original-title="时间已经度过95.83%" style="width: 95.83%"></div>
</div>
</li>
</ul>

</div>
</div>


<nav ui-nav class="navi clearfix">
<ul class="nav">

<div class="line dk hidden-folded"></div>
<li class="hidden-folded padder m-t m-b-sm text-muted text-xs">
<span>导航</span>
</li>

<li>
<a href="../../../../index.html" class="auto">
<span class="nav-icon"><i data-feather="home"></i></span>
<span>首页</span>
</a>
</li>

<li class="line dk"></li>

<li class="hidden-folded padder m-t m-b-sm text-muted text-xs">
<span>组成</span>
</li>

<li>
<a class="auto">
<span class="pull-right text-muted">
<i class="fontello icon-fw fontello-angle-right text"></i>
<i class="fontello icon-fw fontello-angle-down text-active"></i>
</span>

<span class="nav-icon"><i data-feather="grid"></i></span>
<span>分类</span>
</a>
<ul class="nav nav-sub dk">
<li class="nav-sub-header">
<a>
<span>分类</span>
</a>
</li>

<li><a href="../../../category/Uncategorized/index.html"><b class="badge pull-right">0</b><span>Uncategorized</span></a></li><li><a href="../../../category/Linux-Distributions/index.html"><b class="badge pull-right">3</b><span>Linux Distributions</span></a></li><li><a href="../../../category/Algorithm-and-ACM/index.html"><b class="badge pull-right">5</b><span>Algorithm and ACM</span></a></li><li><a href="../../../category/Web-and-Internet/index.html"><b class="badge pull-right">2</b><span>Web and Internet</span></a></li><li><a href="../../../category/applications/index.html"><b class="badge pull-right">1</b><span>Desktop Applications</span></a></li> </ul>
</li>

<li>
<a class="auto">
<span class="pull-right text-muted">
<i class="fontello icon-fw fontello-angle-right text"></i>
<i class="fontello icon-fw fontello-angle-down text-active"></i>
</span>
<span class="nav-icon"><i data-feather="file"></i></span>
<span>页面</span>
</a>
<ul class="nav nav-sub dk">
<li class="nav-sub-header">
<a data-no-instant>
<span>页面</span>
</a>
</li>

<li><a href="../../../Studio.html"><span>Studio</span></a></li>
<li><a href="../../../archiso.html"><span>Archiso</span></a></li>
<li><a href="../../../About.html"><span>About</span></a></li>
<li><a href="../../../cross.html"><span>Cross</span></a></li>
<li><a href="../../../Archives.html"><span>Archives</span></a></li>
</ul>
</li>

<li>
<a class="auto">
<span class="pull-right text-muted">
<i class="fontello icon-fw fontello-angle-right text"></i>
<i class="fontello icon-fw fontello-angle-down text-active"></i>
</span>
<span class="nav-icon"><i data-feather="user"></i></span>
<span>友链</span>
</a>
<ul class="nav nav-sub dk">
<li class="nav-sub-header">
<a data-no-instant>
<span>友链</span>
</a>
</li>

<li data-original-title="在 Arch Linux 社区疯狂输出的大佬" data-toggle="tooltip" data-placement="top"><a href="https://felixc.at/" target="_blank"><span>Felix Yan</span></a></li><li data-original-title="早期的百度贴吧 Linux 吧大水怪" data-toggle="tooltip" data-placement="top"><a href="https://fiveyellowmice.com/" target="_blank"><span>FiveYellowMice</span></a></li><li data-original-title="SCNU ACMer，神犇" data-toggle="tooltip" data-placement="top"><a href="https://www.cnblogs.com/JNzH/" target="_blank"><span>JNzH</span></a></li><li data-original-title="GDUT ACMer，神犇" data-toggle="tooltip" data-placement="top"><a href="https://kaidora.github.io/" target="_blank"><span>Kaidora</span></a></li><li data-original-title="SCNU SE1905 同班同学" data-toggle="tooltip" data-placement="top"><a href="https://user-kay.github.io/" target="_blank"><span>Kay Chen</span></a></li><li data-original-title="0xFFFF.one 站长，大佬" data-toggle="tooltip" data-placement="top"><a href="https://izgq.net/" target="_blank"><span>ZGQ</span></a></li><li data-original-title="百度贴吧 Linux 吧魔法大吧" data-toggle="tooltip" data-placement="top"><a href="http://www.wenyinos.org/" target="_blank"><span>WenyinOS</span></a></li><li data-original-title="早期的百度贴吧 Linux 吧大水怪，北大学霸" data-toggle="tooltip" data-placement="top"><a href="https://lightmelodies.github.io/" target="_blank"><span>LightMelodies</span></a></li><li data-original-title="软协技术部锅长" data-toggle="tooltip" data-placement="top"><a href="https://mikyming.online/" target="_blank"><span>MikyMing</span></a></li> </ul>
</li>
</ul>
</nav>

</div>


<div id="left_footer" class="footer wrapper-xs text-center nav-xs lt">
<div class="col-xs-4 no-padder">
<a target="_blank" class="tinav" href="../../../../admin/index.html" title="" data-toggle="tooltip" data-placement="top" data-original-title="后台管理">
<span class="left-bottom-icons block"><i data-feather="settings"></i></span>
<small class="text-muted">管理</small>
</a>
</div>
<div class="col-xs-4 no-padder">
<a target="_blank" class="tinav" href="../../../feed/index.html" title="" data-toggle="tooltip" data-placement="top" data-original-title="文章RSS地址">
<span class="left-bottom-icons block"><i data-feather="rss"></i></span>
<small class="text-muted">文章</small>
</a>
</div>
<div class="col-xs-4 no-padder">
<a target="_blank" href="../../../feed/comments/index.html" title="" data-toggle="tooltip" data-placement="top" data-original-title="评论RSS地址">
<span class="left-bottom-icons block"><i data-feather="message-square"></i></span>
<small class="text-muted">评论</small>
</a>
</div>
</div>
</div>
</aside>

<div id="content" class="app-content">

<div id="loading" class="butterbar active hide">
<span class="bar"></span>
</div> 
<style>
    #post-content{
        font-size: 14px;
    }
</style>

<a class="off-screen-toggle hide"></a>
<main class="app-content-body ">
<div class="hbox hbox-auto-xs hbox-auto-sm">

<div class="col center-part">


<header id="small_widgets" class="bg-light lter wrapper-md">
<h1 class="entry-title m-n font-thin text-black l-h">2020 Nowcoder Basic Algorithm Training Camp Solutions<a class="plus-font-size" data-toggle="tooltip" data-original-title="点击改变文章字体大小"><i data-feather="type"></i></a><a data-morphing="" id="morphing" data-src="#morphing-content" href="javascript:;" class="read_mode superscript m-l-sm" data-toggle="tooltip" data-placement="right" data-original-title="阅读模式"><i data-feather="book-open"></i></a></h1> 
<ul class="entry-meta text-muted list-inline m-b-none small
             post-head-icon">

<li class="meta-author"><span class="post-icons"><i data-feather="user"></i></span><span class="sr-only">博主：</span> <a class="meta-value" href="../../../author/1/index.html" rel="author"> bobby285271</a></li>

<li class="meta-date"><span class="post-icons"><i data-feather="clock"></i></span><span class="sr-only">发布时间：</span><time class="meta-value">2020 年 02 月 09 日</time></li>

<li class="meta-views"><span class="post-icons"><i data-feather="eye"></i></span><span class="meta-value">41次浏览</span></li>

<li class="meta-comments"><span class="post-icons"><i data-feather="message-circle"></i></span><a class="meta-value" href="2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html#comments">暂无评论</a></li>

<li class="meta-word"><span class="post-icons"><i data-feather="pen-tool"></i></span><span class="meta-value">48602字数</span></li>

<li class="meta-categories"><span class="post-icons"><i data-feather="hash"></i></span><span class="sr-only">分类：</span> <span class="meta-value"><a href="../../../category/Algorithm-and-ACM/index.html">Algorithm and ACM</a></span></li>
</ul>
</header>
<div class="wrapper-md" id="post-panel">
<ol class="breadcrumb bg-white-pure" itemscope=""><li>
<a href="../../../../index.html" itemprop="breadcrumb" title="返回首页" data-toggle="tooltip"><span class="home-icons"><i data-feather="home"></i></span>首页</a>
</li><li class="active">正文&nbsp;&nbsp;</li>
<div style="float:right;">
分享到：
<style>
   .breadcrumb i.iconfont.icon-qzone:after {
    padding: 0 0 0 5px;
    color: #ccc;
    content: "/\00a0";
    }
    
   </style>
<a href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://static.bobby285271.top/index.php/2020/02/09/2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html&title=2020 Nowcoder Basic Algorithm Training Camp Solutions&site=https://static.bobby285271.top/" itemprop="breadcrumb" target="_blank" title="" data-toggle="tooltip" data-original-title="分享到QQ空间" onclick="if (!window.__cfRLUnblockHandlers) return false; window.open(this.href, 'qzone-share', 'width=550,height=335');return false;" data-cf-modified-af8c7cddc53fcd57c335e7ed-=""><i style="font-size:15px;" class="iconfont icon-qzone" aria-hidden="true"></i></a>
<a href="http://service.weibo.com/share/share.php?url=https://static.bobby285271.top/index.php/2020/02/09/2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html&title=2020 Nowcoder Basic Algorithm Training Camp Solutions" target="_blank" itemprop="breadcrumb" title="" data-toggle="tooltip" data-original-title="分享到微博" onclick="if (!window.__cfRLUnblockHandlers) return false; window.open(this.href, 'weibo-share', 'width=550,height=335');return false;" data-cf-modified-af8c7cddc53fcd57c335e7ed-=""><i style="font-size:15px;" class="fontello fontello-weibo" aria-hidden="true"></i></a></div></ol> 
<div id="postpage" class="blog-post">
<article class="single-post panel">

<div class="entry-thumbnail" aria-hidden="true"><div class="item-thumb lazy" data-original="https://static.bobby285271.top/usr/themes/handsome/usr/img/sj/7.jpg" style="background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxMzggNzkuMTU5ODI0LCAyMDE2LzA5LzE0LTAxOjA5OjAxICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+IEmuOgAAAA1JREFUCJljePfx038ACXMD0ZVlJAYAAAAASUVORK5CYII=)"></div></div> 
<div id="post-content" class="wrapper-lg">
<div class="entry-content l-h-2x">
<p>颓废了一个寒假，Codeforces 打来打去都是 Specialist，菜的一批。POJ 又刷到怀疑人生。后来被 Kaidora 神犇安排了这个集训营。当时已经是第四场要开始了，还是去了。果然，哪怕都是自闭五小时每小时过一题，氪了金感觉就是不一样。</p><p>点击下方的页码查看相应场次的记录，第 $i$ 页对应的是第 $i-1$ 场比赛。</p><h1>2020 牛客寒假算法基础集训营 1</h1><blockquote>字符串、贪心、矩阵快速幂、概率论、计算几何、并查集、数论</blockquote><h2>1A. Honoka 和格点三角形</h2><h3>大意</h3><p>给出 $m \times n$ 格点矩阵，问在矩阵里面能找出多少个面积为 $1$，且至少有一条边平行于 $x$ 轴或 $y$ 轴的三角形。答案对 $1000000007$ 取模。</p><h3>思路</h3><p>若存在平行于 $x$ 轴或 $y$ 轴的边且长度为 $2$，一共有 $2(n-1)(m-2)m+2(m-1)(n-2)n$ 种情况。</p><p>若存在平行于 $x$ 轴或 $y$ 轴的边且长度为 $1$，除去已经计算过的情况（即还存在平行于$x$ 轴或 $y$ 轴且长度为 $2$ 的边），一共有 $2(m-1)(m-2)(n-2)+2(n-1)(n-2)(m-2)$ 种情况。</p><p>相加后化简，得到 $2(m+n-2)(2mn-3m-3n+4)$，利用 $ab\ mod\ c = ((a\ mod\ c)(b\ mod\ c))\ mod\ c$ 计算结果。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    long long n, m, tempa, tempb;
    cin &gt;&gt; n &gt;&gt; m;
    tempa = 2 * (m + n - 2);
    tempb = (2 * m * n - 3 * m - 3 * n + 4);
    cout &lt;&lt; (tempa % 1000000007) * (tempb % 1000000007) % 1000000007 &lt;&lt; endl;
    return 0;
}
</code></pre><h2>1B. Kotori 和 Bangdream</h2><h3>大意及思路</h3><p>签到题。求数学期望，也就是可能结果的概率乘以其结果的总和。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    double n, x, a, b;
    cin &gt;&gt; n &gt;&gt; x &gt;&gt; a &gt;&gt; b;
    double ans = (a * x + b * (100 - x)) * n / 100;
    printf(&quot;%.2lf\n&quot;, ans);
    return 0;
}
</code></pre><h2>1C. Umi 和弓道</h2><h3>大意</h3><p>一个人在 $(x_0,y_0)$，给出 $n$ 个靶子，在 $x$ 轴或 $y$ 轴放置挡板，令放置挡板后可以射中的靶子数量不多于 $k$ 个。</p><h3>思路</h3><p>只要靶子和 $(x_0,y_0)$ 不在一个象限就有可能被挡掉。要想挡掉一个靶子，只需求出靶子和 $(x_0,y_0)$ 所在直线与坐标轴的交点，并保证挡板覆盖了这个点。我们只需要恰好覆盖 $n-k$ 个这样的点就行了。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const double inf = 1e18;
vector&lt;double&gt; v1, v2;
int main()
{
    v1.clear();
    v2.clear();
    double x0, y0;
    int n, k, i;
    cin &gt;&gt; x0 &gt;&gt; y0 &gt;&gt; n &gt;&gt; k;
    k = n - k;
    for (i = 0; i &lt; n; i++)
    {
        double x, y;
        cin &gt;&gt; x &gt;&gt; y;
        if (x * x0 &lt; 0)
        {
            v2.push_back(y0 - x0 * (y - y0) / (x - x0));
        }
        if (y * y0 &lt; 0)
        {
            v1.push_back(x0 - y0 * (x - x0) / (y - y0));
        }
    }
    double mi = inf;
    sort(v1.begin(), v1.end());
    sort(v2.begin(), v2.end());
    if (v1.size() &gt;= k)
    {
        double head = 0, tail = k - 1;
        while (tail &lt; v1.size())
        {
            mi = mi &gt; (v1[tail] - v1[head]) ? (v1[tail] - v1[head]) : mi;
            tail++, head++;
        }
    }
    if (v2.size() &gt;= k)
    {
        double head = 0, tail = k - 1;
        while (tail &lt; v2.size())
        {
            mi = mi &gt; (v2[tail] - v2[head]) ? (v2[tail] - v2[head]) : mi;
            tail++, head++;
        }
    }
    if (mi == 1e18)
        cout &lt;&lt; -1;
    else
        printf(&quot;%.7lf&quot;, mi);
    return 0;
}
</code></pre><h2>1D. Hanayo 和米饭</h2><h3>大意</h3><p>给出 $n-1$ 个数，求一个数使得所有的 $n$ 个数经过排序后可形成公差为 $1$ 的等差数列。保证答案存在且唯一。</p><h3>思路</h3><p>签到题。将 $n-1$ 个数排序，看相邻两数的差是否为 $2$。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int n;
    cin &gt;&gt; n;
    int a[n - 1];
    for (int i = 0; i &lt; n - 1; i++)
    {
        cin &gt;&gt; a[i];
    }
    sort(a, a + n - 1);
    for (int i = 0; i &lt; n - 2; i++)
    {
        if (a[i + 1] - a[i] != 1)
        {
            cout &lt;&lt; a[i] + 1 &lt;&lt; endl;
            break;
        }
    }
    return 0;
}
</code></pre><h2>1E. Rin 和快速迭代</h2><h3>大意</h3><p>令 $f(x)$ 为 $x$ 因子个数，将 $f$ 迭代下去，问迭代多少次能得到 $2$。</p><h3>思路</h3><p>模拟就行。求因子个数时注意处理完全平方数。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
long long sol(long long x)
{
    long long temp = 0;
    long long i;
    for (i = 1; i * i &lt;= x; i++)
    {
        if (x % i == 0)
            temp++;
    }
    temp = temp &lt;&lt; 1;
    i--;
    if (i * i == x)
        temp--;
    return temp;
}
int main()
{
    long long n;
    cin &gt;&gt; n;
    int ans = 0;
    while (1)
    {
        n = sol(n);
        ans++;
        if (n == 2)
        {
            cout &lt;&lt; ans &lt;&lt; endl;
            return 0;
        }
    }
    return 0;
}
</code></pre><h2>1F. Maki 和 Tree</h2><h3>大意</h3><p>在树（无向）中有黑白两种点。求 $n$ 个点的树中有多少简单路径有且仅有通过一个黑色点。</p><h3>思路</h3><p>先预处理各个白色连通及其大小，具体思路是读入一条边如果这条边的两端都是白色连通块就连在一起（并查集）。然后再算各个黑点的答案。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
int fa[111111];  //父亲
int kdm[111111]; //孩子数量
string color;
int f(int x)
{ //寻找祖先
    if (fa[x] == x)
        return x;
    return f(fa[x]);
}
void uni(int x, int y)
{ //连接 x 点和 y 点
    int p = f(x), q = f(y);
    if (p != q)
    {
        if (kdm[p] &gt; kdm[q])
        {
            fa[q] = p;
            kdm[p] += kdm[q] + 1;
        }
        else
        {
            fa[p] = q;
            kdm[q] += kdm[p] + 1;
        }
    }
}
ll t[111111]; //统计连通块白点数量
vector&lt;int&gt; g[111111];
ll gao(vector&lt;int&gt; temp)
{ //temp 为黑点的每个相邻白点孩子数量集合
    ll res = 0, i;
    ll n = temp.size();
    if (n == 0)
        return 0;
    ll dp[n] = {0}, sum[n] = {0}, s = 0;
    sum[0] = s = temp[0];
    for (i = 0; i &lt; n; i++)
    {
        res += temp[i];
    }
    for (i = 1; i &lt; n; i++)
    {
        sum[i] = s += temp[i];
    }
    for (i = 1; i &lt; n; i++)
    {
        dp[i] = dp[i - 1] + temp[i] * sum[i - 1];
    }
    return res + dp[n - 1];
}
int main()
{

    int n, i, j;
    cin &gt;&gt; n &gt;&gt; color;
    for (i = 1; i &lt;= n; i++)
        fa[i] = i;
    for (i = 1; i &lt; n; i++)
    {
        int x, y;
        cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y);
        g[y].push_back(x);
        if (color[x - 1] == 'W' &amp;&amp; color[y - 1] == 'W')
            uni(x, y);
    }
    ll sum = 0;
    for (i = 1; i &lt;= n; i++)
        t[i] = kdm[f(i)] + 1;
    for (i = 1; i &lt;= n; i++)
    {
        if (color[i - 1] == 'B')
        {
            vector&lt;int&gt; temp;
            for (j = 0; j &lt; g[i].size(); j++)
            {
                if (color[g[i][j] - 1] == 'W')
                    temp.push_back(t[g[i][j]]); //若相邻点是白点，加入 temp
            }
            sum += gao(temp);
        }
    }
    cout &lt;&lt; sum;
}
</code></pre><h2>1G. Eli 和字符串</h2><h3>大意</h3><p>给出一个字符串，求连续子串的最小长度，要求这个连续子串要包含至少 $k$ 个相同的某个字母。</p><h3>思路</h3><p>前缀和加尺取法。前缀和用于求某个连续子串各个字母出现的次数。尺取法即连续子串两个指针，右指针不断右移，当发现满足条件的连续子串则左指针开始右移，当右指针移动到尽头则停止。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int cnt[26][200010];
int main()
{
    int n, k;
    string a;
    cin &gt;&gt; n &gt;&gt; k &gt;&gt; a;
    int l = a.size();
    for (int i = 0; i &lt; l; i++)
    {
        for (int j = 0; j &lt; 26; j++)
        {
            cnt[j][i + 1] = cnt[j][i];
        }
        cnt[a[i] - 'a'][i + 1]++;
    }
    int p1 = 0, p2 = 1, ans = n + 1;
    while (1)
    {
        int flag = 0;
        for (int i = 0; i &lt; 26; i++)
        {
            if (cnt[i][p2] - cnt[i][p1] &gt;= k)
            {
                ans = min(ans, p2 - p1);
                flag = 1;
            }
        }
        if (flag == 1)
            p1++;
        else
            p2++;
        if (p2 == n + 1)
            break;
    }
    if (ans == n + 1)
        cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;
    else
        cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h2>1H. Nozomi 和字符串</h2><h3>大意</h3><p>一个 $01$ 串，允许你改变其中的 $k$ 个数字，然后找出一个尽可能长的连续子串，这个子串上的所有字符都相同。求这个子串的长度。</p><h3>思路</h3><p>依然是尺取法。分成将 $0$ 变成 $1$ 和将 $1$ 变成 $0$ 两种情况。对于前者，还是两个指针，右指针不断右移，当遇到 $0$ 就用掉一次操作直到次数用尽。接下来右指针继续右移直到再次需要操作的时候，这时左指针右移直到已用操作数恰好减一为止，这时右指针继续右移。后者同理。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    string s;
    int n, k, ans = 0;
    cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;
    int pl = 0, pr = 0, change = 0;
    // 0 =&gt; 1
    for (int i = 0; i &lt; n; i++)
    {
        if (s[i] == '0')
        {
            if (change &lt; k)
            {
                change++;
            }
            else
            {
                while (pl &lt;= pr &amp;&amp; s[pl] != '0')
                    pl++;
                pl++;
            }
        }
        pr++;
        ans = max(ans, pr - pl);
    }
    pl = 0, pr = 0, change = 0;
    for (int i = 0; i &lt; n; i++)
    {
        if (s[i] == '1')
        {
            if (change &lt; k)
            {
                change++;
            }
            else
            {
                while (pl &lt;= pr &amp;&amp; s[pl] != '1')
                    pl++;
                pl++;
            }
        }
        pr++;
        // cout &lt;&lt; pl &lt;&lt; &quot; &quot; &lt;&lt; pr &lt;&lt; endl;
        ans = max(ans, pr - pl);
        // cout &lt;&lt; ans &lt;&lt; endl;
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h2>1I. Nico 和 Niconiconi</h2><h3>大意</h3><p>给出一个字符串，其中 <code>nico</code> 计 $a$ 分，<code>niconi</code> 计 $b$ 分，<code>niconiconi</code> 计 $c$ 分，每个字符都只能参与一次计分，问最大分数。</p><h3>思路</h3><p>简单 DP。$dp[i]$ 可由 $dp[i-1]$、$dp[i-3]$、$dp[i-5]$ 和 $dp[i-9]$ 转移而来，转移后取最大者即可。要注意避免越界。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
long long dp[300010];
int main()
{
    string s;
    long long n, a, b, c;
    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; s;
    for (long long i = 0; i &lt; n; i++)
    {
        if (i &gt; 0)
            dp[i] = dp[i - 1];
        if (i &gt;= 3 &amp;&amp; s.substr(i - 3, 4) == &quot;nico&quot;)
            dp[i] = max(dp[i], dp[i - 3] + a);
        if (i &gt;= 5 &amp;&amp; s.substr(i - 5, 6) == &quot;niconi&quot;)
            dp[i] = max(dp[i], dp[i - 5] + b);
        if (i &gt;= 9 &amp;&amp; s.substr(i - 9, 10) == &quot;niconiconi&quot;)
            dp[i] = max(dp[i], dp[i - 9] + c);
    }
    cout &lt;&lt; dp[n - 1] &lt;&lt; endl;
    return 0;
}
</code></pre><h2>1J. ## TODO</h2><h1>2020 牛客寒假算法基础集训营 2</h1><blockquote>枚举、贪心、DP、数论、思维、数据结构、哈希</blockquote><h2>2A. 做游戏</h2><h3>大意</h3><p>石头剪刀布。已知两人分别出了多少次石头、剪刀和布，求其中一个玩家最多能获胜多少局。</p><h3>思路</h3><p>贪心。让尽量多的剪刀 - 布、石头 - 剪刀和布 - 石头成组，可以直接出答案 $min(A,Y)+min(B,Z)+min(C,X)$。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    long long a, b, c, x, y, z;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; x &gt;&gt; y &gt;&gt; z;
    cout &lt;&lt; min(a, y) + min(b, z) + min(c, x) &lt;&lt; endl;
    return 0;
}
</code></pre><h2>2B. 排数字</h2><h3>大意</h3><p>给出一个字符串 $S$，问将字符串打乱后最多能有多少个不同的连续子串为 $616$ 。</p><h3>思路</h3><p>只需将所有的 $6$ 和 $1$ 集中起来：$6161616...$ ，因此统计 $6$ 和 $1$ 的个数即可，得出答案。注意 $cnt6$ 个 $6$ 最多能只造 $cnt6-1$ 个满足题意的字串，所以是 $min(cnt6-1,cnt1)$。如果算出来小于零应该将答案调整为 $0$。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int n, cnt1 = 0, cnt6 = 0;
    string s;
    cin &gt;&gt; n &gt;&gt; s;
    for (int i = 0; i &lt; n; i++)
    {
        if (s[i] == '1')
            cnt1++;
        else if (s[i] == '6')
            cnt6++;
    }
    cout &lt;&lt; max(0, min(cnt6 - 1, cnt1)) &lt;&lt; endl;
    return 0;
}
</code></pre><h2>2C. 算概率</h2><h3>大意</h3><p>一共 $n$ 道题，第 $i$ 道题的正确率是 $p_i$​，给出这个正确率对 $10^9+7$ 取模的结果，求这 $n$ 题里恰好有 $0,1,\cdots,n$ 题正确的概率分别是多少，同样对 $10^9+7$ 取模。对分数取模的定义已在题目给出。</p><h3>思路</h3><p>简单 DP。一个难点是求状态转移方程，一个是理解题目中对分数取模的概念（本蒟蒻在补第四套题时才会的乘法逆元，做这道题时直接观察样例对 $\frac{1}{2}$ 取模的结果，然后分子分母代进 $a$ 和 $b$ 蒙一把，发现简单粗暴地将概率乘个 $(10^9+7)+1$ 就是了）。要求前 $i$ 题正确 $j$ 题的概率，首先要知道的是前面具体过了哪几道题我们不需要知道（这里有点靠直觉），我们只需要简单粗暴地把它当作一个整体参与后面的计算。接下来，我们要分两种情况讨论，一个是第 $i$ 题对了 $f_{i-1,j} \cdot p_i$，一个是第 $i$ 题错了 $f_{i,j} \cdot (1-p_i)$，加起来就是了。状态转移方程 $f_{i,j} = f_{i-1,j} \cdot p_i+f_{i-1,j} \cdot (1-p_i)$。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

long long n, p[2005], dp[2005][2005];

int main()
{
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++)
    {
        cin &gt;&gt; p[i];
    }
    dp[0][0] = 1;
    for (int i = 1; i &lt;= n; i++)
    {
        dp[i][0] = dp[i - 1][0] * (1000000008 - p[i]) % 1000000007;
        for (int j = 1; j &lt;= i; j++)
            dp[i][j] = (dp[i - 1][j] * (1000000008 - p[i]) + dp[i - 1][j - 1] * p[i]) % 1000000007;
    }
    for (int i = 0; i &lt;= n; i++)
        cout &lt;&lt; dp[n][i] &lt;&lt; ' ';
    return 0;
}

</code></pre><h2>2D. 数三角</h2><h3>大意</h3><p>给出 $n$ 个点，问这 $n$ 个点形成的三角形中，总共有多少个钝角三角形。</p><h3>思路</h3><p>签到。枚举后比较 $a^2+b^2$ 和 $c^2$ 即可，另外注意三点不能共线。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int n, a[505], b[505], ans = 0;

bool f(int i, int j, int k)
{
    int check1 = (a[j] - a[i]) * (a[k] - a[i]) + (b[j] - b[i]) * (b[k] - b[i]);
    int check2 = (a[j] - a[i]) * (b[k] - b[i]) - (a[k] - a[i]) * (b[j] - b[i]);
    return check1 &lt; 0 &amp;&amp; check2 != 0;
}
int main()
{
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++)
        cin &gt;&gt; a[i] &gt;&gt; b[i];
    for (int i = 0; i &lt; n; i++)
    {
        for (int j = i + 1; j &lt; n; j++)
        {
            for (int k = j + 1; k &lt; n; k++)
            {
                if (f(i, j, k) || f(k, i, j) || f(j, i, k))
                {
                    ans++;
                }
            }
        }
    }

    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h2>2E. 做计数</h2><h3>大意</h3><p>求有多少个不同的正整数三元组 $(i,j,k)$ 满足 $\sqrt i+\sqrt j = \sqrt k$，而且 $i \cdot j \leq n$。</p><h3>思路</h3><p>看过一样的题，所以说多去看百度贴吧的营销号推送确实能涨知识。见到根号疯狂平方就对了（必要时候还是要移项的）。等式左右两边平方，$i+j+2 \sqrt {ij}=k$，发现要使 $k$ 为整数，必需要令 $i \cdot j$ 为完全平方数，所以我们就枚举完全平方数，然后再枚举这些完全平方数的因数。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int n, ans;
int main()
{
    cin &gt;&gt; n;
    for (int i = 1; i * i &lt;= n; i++)
    {
        for (int j = 1; j &lt;= i; j++)
            if (i * i % j == 0)
                ans += 2;
        ans--;
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h2>2F. 拿物品</h2><h3>大意</h3><p>多个物品，每个物品两个属性 $a$ 和 $b$， 甲乙两人轮流拿物品，最后甲的得分为其拿到物品的 $a$ 属性的和，乙则为 $b$ 属性的和。问两人最优策略下会拿哪些物品。</p><h3>思路</h3><p>假设两人赛后互换物品 $(a_1,b_1)$ 和 $(a_2,b_2)$，那么两人得分变化分别为 $-a_1+a_2$ 和 $b_1-b_2$，如果想让前者得分更大，要有 $a_1+b_1 &lt; a_2+b_2$。后者同理。所以就按照 $a+b$ 排序。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

const int N = 2e5 + 7;
int n;
vector&lt;int&gt; sa, sb;
struct temp
{
    int a, b, id;
} a[N];

bool cmp(temp a, temp b)
{
    return a.a + a.b &gt; b.a + b.b;
}

int main()
{
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++)
        cin &gt;&gt; a[i].a;
    for (int i = 1; i &lt;= n; i++)
    {
        cin &gt;&gt; a[i].b;
        a[i].id = i;
    }
    sort(a + 1, a + 1 + n, cmp);
    for (int i = 1; i &lt;= n; ++i)
        ((i &amp; 1) ? sa : sb).push_back(a[i].id);
    for (auto i : sa)
        cout &lt;&lt; i &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;
    for (auto i : sb)
        cout &lt;&lt; i &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;
    return 0;
}
</code></pre><h2>2G. 判正误</h2><h3>大意</h3><p>给出七个整数 $a, b, c, d, e, f, g$ 问是否有 $a^d+b^e+c^f=g$。数据范围 $10^9$ 级别，数据量 $10^3$ 级别。</p><h3>思路</h3><p>在模的意义下上快速幂验证，也就是验证 $a^d+b^e+c^f \equiv g \left ( mod \ M\right )$。模数越多，数据越水，就越稳。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int mod[] = {2, 3, 5, 7, 11, 31, 71, 97, 233, 397, 433, 449, 607, 857, 10007, 21179, 36251, 44579, 62003, 72883, 97843, 139991, 232013, 369353, 681521, 692711, 777241, 822821, 1956761, 2145137, 2915837, 6229117, 7788787, 13743493, 17331841, 19260817, 19269293, 19959809, 21006959, 23937083, 24410849, 28452757, 28478603, 29229359, 35570827, 35604011, 35875487, 37370863, 38303347, 38475517, 38819149, 40455791, 44021539, 45641993, 46531301, 48866749, 50529641, 52634191, 52790587, 55180799, 56971613, 58259351, 60954737, 62207269, 63367453, 65072599, 66017821, 67952779, 69475349, 74689217, 77059907, 77907121, 79391659, 84768797, 85584601, 85724879, 85756609, 86850899, 91783511, 92331541, 94519499, 96375241, 99033413, 99486311, 100569829, 106873549, 109329881, 109913681, 111186487, 111894067, 112136617, 112417363, 114011921, 119143363, 122994493, 123747781, 124001021, 126515639, 128191039, 128767909, 132222763, 133587661, 139644719, 145641527, 153388423, 155187077, 156883333, 157989581, 159538063, 161488643, 164039129, 166070447, 169181543, 169554227, 173564801, 175742867, 185469637, 187203899, 191263223, 198691817, 204144887, 211631201, 217903877, 218028203, 220073423, 228143453, 228667423, 232064653, 240519263, 245647159, 247586411, 247936121, 250949197, 253413211, 253464329, 260572729, 260590409, 262887773, 265711423, 266763641, 273585149, 276472817, 276500531, 280543667, 280649591, 281385491, 291366337, 293273159, 296973107, 302890501, 306568693, 315614297, 316729409, 317617121, 320337781, 320613497, 321322823, 324691051, 325963067, 327184157, 329900633, 330670159, 332058781, 332213669, 332300869, 334382221, 341895677, 347938237, 349011827, 349347503, 349906439, 353796941, 364557253, 364755931, 367946441, 372413831, 374358983, 379589897, 381149689, 389431873, 404683493, 405216109, 405495029, 408142403, 408989747, 410841979, 410935093, 412405351, 412592459, 412722139, 412990573, 418171483, 421270357, 424233613, 427938449, 428492083, 429962881, 430883569, 434988383, 435941201, 438816151, 440052953, 440143589, 444693631, 453646433, 455847109, 456640189, 457911511, 458185237, 463116761, 463861417, 469275953, 471298573, 471712513, 478267417, 483824813, 494828483, 497397293, 499657393, 507957479, 512906621, 519346459, 519879973, 520094713, 523213693, 525673273, 529575763, 529883803, 533887031, 534260809, 535328309, 541992667, 542253071, 544780177, 545567609, 552922529, 555129893, 555820037, 558473471, 563484017, 571310471, 578121241, 582251063, 583825639, 584121323, 592038487, 599098811, 601467677, 610073969, 615059213, 619220713, 622457177, 627412609, 630547919, 632342989, 637357363, 638865419, 648268013, 650007487, 651564761, 654115433, 661281713, 662664461, 667914281, 682988213, 691099121, 691445809, 692038043, 692411953, 698620943, 699007259, 701164631, 706806461, 707096251, 707697451, 709566589, 719095829, 725756807, 736880491, 739603867, 743026709, 744236861, 744396049, 747393791, 749395103, 760341121, 762934307, 773124059, 773195911, 776162609, 781629113, 781884613, 786120631, 788314343, 788898377, 788939293, 790209983, 791933183, 796328783, 798643889, 802280047, 803293991, 803847559, 809752739, 818520473, 820434047, 826810489, 829359959, 829707427, 836587463, 841011167, 843763253, 849410557, 851226437, 853058471, 853168793, 853778327, 859086391, 860720017, 863193077, 873061181, 888803059, 893035529, 900902953, 904636883, 917949577, 921817139, 922328707, 931449133, 933074827, 933156233, 935241721, 935632799, 939948881, 957119773, 961329913, 965269573, 965337949, 967551691, 971080093, 973578143, 976825877, 985100197, 985413691, 986124823, 990650057, 998244353, 999058883, 1000000007};
int ff(int a, int m)
{
    return (a % m + m) % m;
}
int Pow(int a, int b, int c)
{
    int ret = 1;
    while (b)
    {
        if (b &amp; 1)
            ret = ret * 1ll * a % c;
        a = a * 1ll * a % c;
        b &gt;&gt;= 1;
    }
    return ret;
}
int a, b, c, d, e, f, g;

bool check(int m)
{
    return ((Pow(ff(a, m), d, m) + Pow(ff(b, m), e, m)) % m + Pow(ff(c, m), f, m)) % m == ff(g, m);
}

int main()
{
    int T;
    cin &gt;&gt; T;
    while (T--)
    {
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f &gt;&gt; g;
        bool flag = 1;
        for (int i = 0; i &lt; 349; ++i)
        {
            if (!check(mod[i]))
            {
                flag = 0;
                break;
            }
        }
        puts(flag ? &quot;Yes&quot; : &quot;No&quot;);
    }
    return 0;
}
</code></pre><p>第三场。</p><h1>2020 牛客寒假算法基础集训营 4</h1><blockquote>搜索、简单 STL、前缀和、二分搜索、位运算、贪心、分治、树</blockquote><h2>4A. 欧几里得</h2><h3>大意</h3><p>给出了一个递归实现的 GCD 的代码，告诉你递归次数，求最开始的两个数，它们不相同且都是非负数，使这两个数的和最小。</p><h3>思路</h3><p>签到题。递归次数为 $0$ 次的时候肯定这两个是 $1$ 和 $0$。递归次数为 $1$ 次的时候则是 $2$ 和 $1$。假设说 $a$ 大于 $b$，其实就是已知 $b$ 和 $a\ mod\ b$，然后要让 $a$ 最小，那么就让 $\left \lfloor \frac{a}{b} \right \rfloor$ 最小。那就让它等于 $1$，可以很快发现是斐波那契数列。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main()
{
    int T;
    cin &gt;&gt; T;
    while (T--)
    {
        long long n;
        cin &gt;&gt; n;
        long long a[n + 10];
        a[0] = 1;
        a[1] = 2;
        for (int i = 2; i &lt; n + 7; i++)
        {
            a[i] = a[i - 1] + a[i - 2];
        }
        if (n == 0)
            cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;
        else
            cout &lt;&lt; a[n + 1] &lt;&lt; endl;
    }
    return 0;
}
</code></pre><h2>4B. 括号序列</h2><h3>大意</h3><p>给出一个仅包含 <code>[</code>、<code>]</code>、<code>(</code>、<code>)</code>、<code>{</code>、<code>}</code> 六种字符的括号序列，判断其是否合法。</p><h3>思路</h3><p>签到题。开一个栈来储存左括号，读到右括号看看栈顶的左括号和它匹不匹配。匹配就 POP 一个左括号。每时每刻都判断一下栈是不是空的。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main()
{
    string a;
    cin &gt;&gt; a;
    stack&lt;char&gt; b;
    for (int i = 0; i &lt; a.size(); i++)
    {
        // cout &lt;&lt; a[i];
        if (a[i] == '[')
            b.push('[');
        else if (a[i] == '{')
            b.push('{');
        else if (a[i] == '(')
            b.push('(');
 
 
        else if (a[i] == ']')
        {
            if (b.empty() || (! b.empty() &amp;&amp; b.top() != '['))
            {
                cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
                return 0;
            }
            else if (! b.empty())
                b.pop();
        }
        else if (a[i] == ')')
        {
            if (b.empty() || (! b.empty() &amp;&amp; b.top() != '('))
            {
                cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
                return 0;
            }
            else if (! b.empty())
                b.pop();
        }
        else if (a[i] == '}')
        {
            if (b.empty() || (! b.empty() &amp;&amp; b.top() != '{'))
            {
                cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
                return 0;
            }
            else if (! b.empty())
                b.pop();
        }
    }
    if (b.empty())
        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
    return 0;
}
</code></pre><h2>4C. 子段乘积</h2><h3>大意</h3><p>给出一个数列和一个数字 $k$，求其长度为 $k$ 的连续子段的乘积对 $998244353$ 取模余数的最大值。</p><h3>思路</h3><p>其实会乘法逆元的话就可以尺取了，可惜我刚开始做这题的时候不会，只好线段树了。反正期间也不用改动数字，懒标记什么的统统不要，把线段树建起来直接开始查询。</p><pre><code>#include &lt;bits/stdc++.h&gt;
 
using namespace std;
 
const int maxn = 200010;
 
int a[maxn + 2];
 
struct tree
{
    int l, r;
    long long pre, add;
} t[4 * maxn + 2];
 
void bulid(int p, int l, int r)
{
    t[p].l = l;
    t[p].r = r;
    if (l == r)
    {
        t[p].pre = a[l];
        return;
    }
    int mid = l + r &gt;&gt; 1;
    bulid(p * 2, l, mid);
    bulid(p * 2 + 1, mid + 1, r);
    t[p].pre = (t[p * 2].pre * t[p * 2 + 1].pre) % 998244353;
}
 
long long ask(int p, int x, int y)
{
    if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
        return t[p].pre;
    int mid = t[p].l + t[p].r &gt;&gt; 1;
    long long ans = 1;
    if (x &lt;= mid)
        ans = ans * ask(p * 2, x, y) % 998244353;
    if (y &gt; mid)
        ans = ans * ask(p * 2 + 1, x, y) % 998244353;
    return ans;
}
 
int main()
{
    int n, m;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; i++)
        scanf(&quot;%d&quot;, &amp;a[i]);
    bulid(1, 1, n);
    long long ans = -1;
    for (int i = 1; i + m - 1 &lt;= n; i++)
    {
        int x, y;
        ans = max(ans, ask(1, i, i + m - 1));
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h2>4D. 子段异或</h2><h3>大意</h3><p>给出一个数列，让你需要输出其中异或值为 $0$ 的不同连续子段的数量。</p><h3>思路</h3><p>首先用到了前缀和的思想，将前缀异或存进一个数组里。然后接合异或的性质：如果 $a\ xor\ b=c$，那么 $c\ xor\ a=b$，那么数组里任意两个数异或就是某一个区间的异或值，反正我们也不用关心这个区间从哪开始从哪结束，又因为 $a\ xor\ a=0$，我们给数组排下序，看看相邻两个数字是否相等就可以啦。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main()
{
    int n;
    cin &gt;&gt; n;
    long long a[n + 10];
    long long temp;
    cin &gt;&gt; temp;
    a[0] = temp;
    for (int i = 1; i &lt; n; i++)
    {
        cin &gt;&gt; temp;
        a[i] = a[i - 1] ^ temp;
    }
    sort(a, a + n);
    long long ans = 0, cnt = 1;
    for (int i = 0; i &lt; n; i++)
    {
        if (a[i] == 0)
            ans++;
        if (i != 0 &amp;&amp; a[i] == a[i - 1])
            cnt++;
        if (i != 0 &amp;&amp; (a[i] != a[i - 1] || i == n - 1))
        {
            ans += cnt * (cnt - 1) / 2;
            cnt = 1;
        }
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h2>4E. 最小表达式</h2><h3>大意</h3><p>给出一个字符串，里面只包含 $1$ 到 $9$ 还有加号。要求给出字符串的一个排列，使排列后是一个合法的算式而且算式的计算结果最小。</p><h3>思路</h3><p>贪心。加号的数字知道后就知道要有多少个数相加。然后我们将大的数字放在个位十位这种低位数，将小的数字放在高位数。然后是大数加法。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int cnt[20];
int sum[500050];

string s;
int main()
{
    cin &gt;&gt; s;
    int ccnt = 1;
    int n = s.size();
    for (int i = 0; i &lt; n; i++)
    {
        if (isdigit(s[i]))
        {
            cnt[s[i] - '0']++;
        }
        else
        {
            ccnt++;
        }
    }
    int p = 0, cp = 0;
    for (int i = 10; i &gt;= 1; i--)
    {
        while (cnt[i])
        {
            sum[cp] += i;
            cnt[i]--;
            p = (p + 1) % ccnt;
            if (p == 0)
                cp++;
        }
    }
    for (int i = 0; i &lt; 500010; i++)
    {
        sum[i + 1] += sum[i] / 10;
        sum[i] %= 10;
    }
    int opt = 0;
    for (int i = 500010; i &gt;= 0; i--)
    {
        if (opt || sum[i])
        {
            cout &lt;&lt; sum[i];
            opt = 1;
        }
    }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre><h2>4J. 二维跑步</h2><h3>完整题目</h3><p>一个点在平面直角坐标系中移动，初始位置 $(0,0)$，移动了 $n$ 次。从 $(i,0)$ 可以移动到 $(i+1,0)$、$(i+1,1)$、$(i+1,2)$、$(i,0)$、$(i-1,1)$、$(i-1,2)$，从 $(i,1)$ 可以移动到 $(i+1,0)$、$(i+1,1)$、$(i+1,2)$、$(i,1)$、$(i-1,0)$、$(i-1,2)$，从 $(i,2)$ 可以移动到 $(i+1,0)$、$(i+1,1)$、$(i+1,2)$、$(i,2)$、$(i-1,0)$、$(i-1,1)$。这里的 $(i,0)$ 移动到 $(i,0)$ 没有打错，而是不变换坐标的前提下消耗一个步数。已知 $n$ 和 $m$，数值均小于 $3 \cdot 10^6$，然后问你有多少种方式使得点的 $x$ 坐标最后落在 $[-m,m]$，答案对 $998244353$ 取模输出。</p><h3>思路</h3><h4>坐标等价</h4><p>理解题目在讲啥后，首先要做的是简化题目条件，你会发现这么多的坐标其中纵坐标只有三种，$0$、$1$ 和 $2$，当横坐标增加的时候（也就是从 $i$ 变成 $i+1$ 了，后面类似），无论初始位置的纵坐标是啥，能够到达的位置的纵坐标都是任意的。当横座标不变，纵坐标都是不变的。当横坐标减少的时候，无论初始位置的纵坐标是啥，能够到达的位置的纵坐标都只有两个可选而且都不等于初始位置的纵坐标。综上所述，我们发现纵坐标在这题是无关紧要的，横坐标相同的三个点是等价的。那么我们就可以将题目理解为：从 $x=i$ 的点到 $x=i+1$ 的点有三种方法，到 $x=i$ 的点有一种方法，到 $x=i-1$ 的点有两种方法。</p><h4>排列组合</h4><p>考虑到 $n$ 步下来本质还是左移、右移、不动三种方式的组合，只需设出三种方式分别的步数，用组合数公式即可。这里不妨设 $x$ 坐标不变的次数为 $i$，其中 $a$ 次 $x$ 坐标增加了，那么就会有 $n-i-a$ 次坐标减少。我们可以知道最后的坐标位置为 $x_{final}=a-(n-i-a)=2a-n+i$。为了让这个坐标处于 $[-m,m]$ 这个区间，我们要有：</p><p>$\left\{\begin{matrix} -m \leq 2a-n+i \leq m \ 0 \leq a \leq n-i \end{matrix}\right. $</p><p>由于 $a$ 还是一个整数，算出来的结果还需要上下取整：</p><p>$max(\left \lceil \frac{-m+n-i}{2} \right \rceil,0)\leq a \leq min(\left \lfloor \frac{m+n-i}{2} \right \rfloor,n-i)$</p><p>结合高中数学内容，我们知道 $i$ 次坐标不变，$a$ 次坐标增加的方案数一共是 $C _{n}^{i}(C _{n-i}^{a} \cdot 3^{a} \cdot 2^{n-i-a})$，我们进行求和操作，得出的结果是：</p><p>$ans = \sum_{i=0}^{n} \textrm{C} _{n}^{i}(\sum_{a=max(\left \lceil \frac{-m+n-i}{2} \right \rceil,0)}^{min(\left \lfloor \frac{m+n-i}{2} \right \rfloor,n-i)} \textrm{C} _{n-i}^{a} \cdot 3^{a} \cdot 2^{n-i-a}) $</p><h4>优化</h4><p>考虑到 $n$ 和 $m$ 的数据范围，直接进行计算肯定是不行，我们尝试将上面的式子拆为多部分。令：</p><p>$\left\{\begin{matrix}f(p,q)=C_p^q \cdot3^q \cdot 2^{p-q} \ L(i)=max(\left \lceil \frac{-m+n-i}{2} \right \rceil,0) \ R(i)=min(\left \lfloor \frac{m+n-i}{2} \right \rfloor,n-i) \ G(i)=\sum_{a=L(i)}^{R(i)}f(n-i,a) \ ans = \sum_{i=0}^{n}C_{n}^{i} G(i) \end{matrix}\right.$</p><p>在这些式子中，我们发现要缩短 $ans$ 的计算时间，就必须缩短 $G(i)$ 的计算时间。考虑到计算 $G(i)$ 时 $L(i)$ 和 $R(i)$ 都是一次性计算完成，但是 $f(p,q)$ 这样的式子我们要算上很多遍，我们我们就尝试优化 $f(p,q)$ 的计算。所谓优化很多时候就是预处理。我们看看对应的式子：组合数，得算阶乘吧，得算 $2$ 的 $p-q$ 次幂吧，得算 $3$ 的 $q$ 次幂吧，全部预处理掉。接下来就比较玄学了，考虑到我们除了要计算 $f(n-i,a)$，还要计算 $f(n-i-1,a)$、$f(n-i+1,a)$ 等等，因为恰好有 $C_p^q=C_{p-1}^{q}+C_{p-1}^{q-1}$ 这个公式，也就有了前项推后项的思路。我们尝试将 $2$ 和 $3$ 的指数和组合数匹配一下，得出 $f(p,q)=2f(p-1,q)+3f(p-1,q-1)$ 这样的式子。</p><p>接下来就不用再管 $f(p,q)$ 等于什么了，回到 $G(i)$ 这个层面。我们用上面的结论尝试展开上面的式子：</p><p>$G(i)=\sum_{a=L(i)}^{R(i)}f(n-i,a)$ <br>$=\sum_{a=L(i)}^{R(i)}(3f(n-(i+1),a-1)+2f(n-(i+1),a))$ <br>$=3f(n-(i+1),L(i)-1)+2f(n-(i+1),L(i))+3f(n-(i+1),L(i))+ \cdots +2f(n-(i+1),R(i)-1))+3f(n-(i+1),R(i)-1)+2f(n-(i+1),R(i))$ <br>$=5 \sum_{a=L(i)}^{R(i)-1}f(n-(i+1),a)+3f(n-(i+1),L(i)-1)+2f(n-(i+1),R(i))$</p><p>你会发现有一项是 $\sum_{a=L(i)}^{R(i)-1}f(n-(i+1),a)$，和 $G(i+1)$ 的形式很像，但是后者是 $\sum_{a=L(i+1)}^{R(i+1)}f(n-(i+1),a)$，还是有点区别。怎么办呢？就人为创造一个 $\sum_{a=L(i+1)}^{R(i+1)}f(n-(i+1),a)$ 呗。还是上面那个式子，我们把所有的 $L(i)$ 换成 $L(i+1)$，把 $R(i)-1$ 换成 $R(i+1)$，但这算出来就和 $G(i)$ 差了几个的 $f(n-i,a)$ 怎么办呢。先标记为 $\Delta$ 到后面再算呗。</p><p>$G(i)=\sum_{a=L(i+1)}^{R(i+1)+1}f(n-i,a)+\Delta$ <br>$=\sum_{a=L(i+1)}^{R(i+1)+1}(3f(n-(i+1),a-1)+2f(n-(i+1),a))+\Delta$ <br>$=3f(n-(i+1),L(i+1)-1)+2f(n-(i+1),L(i+1))+3f(n-(i+1),L(i+1))+ \cdots +2f(n-(i+1),R(i+1)))+3f(n-(i+1),R(i+1))+2f(n-(i+1),R(i+1)+1)+\Delta$ <br>$=5 \sum_{a=L(i+1)}^{R(i+1)}f(n-(i+1),a)+3f(n-(i+1),L(i+1)-1)+2f(n-(i+1),R(i+1)+1)+\Delta$ <br>$=5G(i+1)+3f(n-(i+1),L(i+1)-1)+2f(n-(i+1),R(i+1)+1)+\Delta$</p><h4>代码实现</h4><p>在式子乘个 <code>1ll</code> 可以有效避免溢出的问题。计算高次幂为了避免溢出，在写快速幂的时候也要每步取模。计算组合数的时候需要用到除以比较大的数，还是为了避免溢出这时候也是要取模的。于是就打开了乘法逆元的新世界，道理其实也不是很懂，大概就是如果有一个素数 $p$，根据费马小定理则有 $a^{p-1}\equiv1(mod\;p)$，那么 ${a}\cdot a^{p-2}\equiv1(mod\;p)$，$a^{p-2}$ 就叫 $a\ mod\ p$ 意义下的逆元，照用就是了。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
const int mod = 998244353;
const int N = 3000010;
int n, m, f2[N], f3[N], q[N], p[N], G[N];
 

//////// 快速幂 ////////
int qpow(int a, int b) {
    int ans = 1;
    a %= mod;
    for (; b; b &gt;&gt;= 1) {
        if (b &amp; 1) ans = 1ll * ans * a % mod;
        a = 1ll * a * a % mod;
    }
    return ans;
}

//////// 组合数 ////////
int c(int a, int b) { return 1ll * q[a] * p[b] % mod * p[a - b] % mod; }

//////// 算 f(a,b) ////////
int f(int a, int b) { return 1ll * c(a, b) * f3[b] % mod * f2[a - b] % mod; }

int main() {
    cin &gt;&gt; n &gt;&gt; m;
    f2[0] = f3[0] = q[0] = 1;
    for (int i = 1; i &lt;= n; i++) {
        // 算 i!，2 的 i 次方，3 的 i 次方，对 mod 取模
        q[i] = 1ll * q[i - 1] * i % mod;
        f2[i] = 1ll * f2[i - 1] * 2 % mod;
        f3[i] = 1ll * f3[i - 1] * 3 % mod;
    }

    // 乘法逆元
    p[n] = qpow(q[n], mod - 2);
    for (int i = n - 1; i &gt;= 0; i--) p[i] = 1ll * p[i + 1] * (i + 1) % mod;

    //////// 算 G(i) ////////
    int l = 0, r = 1; G[n] = 1;
    for (int i = n - 1; i &gt;= 0; i--, r++) {

        // 算 5 * G(i + 1) + 3 * f(...) + 5 * f(...)
        G[i] = (5ll * G[i + 1] % mod + 3ll * f(n - i - 1, l - 1) % mod + 2ll * f(n - i - 1, r) % mod) % mod;
        int ql = max((n - i - m + 1) / 2, 0), qr = min((n - i + m) / 2, n - i);
        // 此时 l = L(i + 1), r = R(i + 1) + 1
        // 此时 ql = L(i), qr = R(i)
        
        // 算 delta
        while (l &lt; ql) G[i] = (1ll * G[i] - f(n - i, l) + mod) % mod, l++;
        while (l &gt; ql) l--, G[i] = (1ll * G[i] + f(n - i, l)) % mod;
        while (r &gt; qr) G[i] = (1ll * G[i] - f(n - i, r) + mod) % mod, r--;
        while (r &lt; qr) r++, G[i] = (1ll * G[i] + f(n - i, r)) % mod;
        // 此时 l = L(i), r = R(i)
        // 此时 i--, r++
    }

    //////// 算答案 ////////
    int ans = 0;
    for (int i = n; i &gt;= 0; i--) ans = (ans + 1ll * G[i] * c(n, i) % mod) % mod;
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h1>2020 牛客寒假算法基础集训营 5</h1><blockquote>字符串、二分、哈希、DP、模拟、搜索、数学</blockquote><h2>5A. 模板</h2><h3>大意</h3><p>给出两个字符串，允许对其中一个字符串做任意的替换、删除最后一位、在末尾添加一个字母。问最少的步数，使两个字符串相同。</p><h3>思路</h3><p>签到题。逐个位置匹配，发现不一样则步数加一。当长度较短的字符串匹配完后再加上两个字符串的长度差。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    string a, b;
    cin &gt;&gt; a &gt;&gt; b;
    if (n &lt; m)
    {
        swap(n, m);
        swap(a, b);
    }
    int ans = 0;
 
    for (int i = 0; i &lt; m; i++)
    {
        if (a[i] != b[i])
            ans++;
    }
    ans += n - m;
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h2>5B. 牛牛战队的比赛地</h2><h3>大意</h3><p>已知多个点的坐标，问平面上哪个位置满足到这些点的距离的最大值最小。</p><h3>思路</h3><p>三分答案。大概是因为它是二次函数，每次使用三分都能排除最差的一部分答案。二分答案似乎也是可以的，但二分的依据是单调性，二次函数也没法保证这一点，所以做起来似乎要麻烦很多。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

struct p
{
    int x, y;
} a[100005];
int n;
double check(double x)
{
    double max = 0;
    for (int i = 0; i &lt; n; i++)
    {
        double tmp = sqrt(a[i].y * a[i].y + (a[i].x - x) * (a[i].x - x));
        if (tmp &gt; max)
            max = tmp;
    }
    return max;
}
double tsearch(double left, double right)
{
    int i;
    double mid, midmid;
    for (i = 0; i &lt; 100; i++)
    {
        mid = left + (right - left) / 2;
        midmid = mid + (right - mid) / 2;
        if (check(mid) &gt; check(midmid))
            left = mid;
        else
            right = midmid;
    }
    return mid;
}
int main()
{
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++)
        cin &gt;&gt; a[i].x &gt;&gt; a[i].y;
    double max = tsearch(-10000, 10000);
    cout &lt;&lt; check(max) &lt;&lt; endl;
    return 0;
}
</code></pre><h2>5C. C 语言 IDE</h2><h3>大意</h3><p>输入一份 C 语言代码，要求输出代码中出现的函数。</p><h3>思路</h3><p>哦，是码农大模拟！爱了爱了。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

string source;
void replaceAll(string &amp;s, string oldstr, string newstr)
{
    for (string::size_type pos = 0; pos != string::npos; pos += newstr.length())
        if ((pos = s.find(oldstr, pos)) != string::npos)
            s.replace(pos, oldstr.length(), newstr);
        else
            break;
}
struct functions
{
    string inClass, name, outputType;
    vector&lt;string&gt; inputType;
    functions(string inClass = &quot;&quot;, string name = &quot;&quot;, string outputType = &quot;void&quot;, vector&lt;string&gt; inputType = vector&lt;string&gt;(0))
        : inClass(inClass), name(name), outputType(outputType), inputType(inputType) {}
};
vector&lt;functions&gt; funs;
void solve(string &amp;s)
{
    replaceAll(s, &quot;/*&quot;, &quot; /* &quot;);
    replaceAll(s, &quot;*/&quot;, &quot; */ &quot;);
    replaceAll(s, &quot;//&quot;, &quot; // &quot;);
    replaceAll(s, &quot;(&quot;, &quot; ( &quot;);
    replaceAll(s, &quot;)&quot;, &quot; ) &quot;);
    replaceAll(s, &quot;{&quot;, &quot; { &quot;);
    replaceAll(s, &quot;}&quot;, &quot; } &quot;);
    replaceAll(s, &quot;=&quot;, &quot; = &quot;);
    replaceAll(s, &quot;\&quot;&quot;, &quot; \&quot; &quot;);
    replaceAll(s, &quot;'&quot;, &quot; ' &quot;);
    replaceAll(s, &quot;;&quot;, &quot; ; &quot;);
    replaceAll(s, &quot;,&quot;, &quot; , &quot;);
    replaceAll(s, &quot;+ = &quot;, &quot;+=&quot;);
    replaceAll(s, &quot;- = &quot;, &quot;-=&quot;);
    replaceAll(s, &quot;* = &quot;, &quot;*=&quot;);
    replaceAll(s, &quot;/ = &quot;, &quot;/=&quot;);
    replaceAll(s, &quot;^ = &quot;, &quot;^=&quot;);
    replaceAll(s, &quot;| = &quot;, &quot;|=&quot;);
    replaceAll(s, &quot;&amp; = &quot;, &quot;&amp;=&quot;);
    replaceAll(s, &quot;:&quot;, &quot; : &quot;);
    replaceAll(s, &quot; :  : &quot;, &quot;::&quot;);
    vector&lt;string&gt; tokens;
    string now = &quot;&quot;;
    for (int i = 0; s[i]; i++)
    {
        if (s[i] == ' ' || s[i] == '\t' || s[i] == '\r' || s[i] == '\n' || s[i] == '\0')
        {
            if (now != &quot;&quot;)
            {
                if (now == &quot;:&quot; &amp;&amp; tokens.back() == &quot;)&quot;)
                {
                    string tmpnow = &quot;&quot;;
                    for (int j = i + 1; s[j]; j++)
                    {
                        if (s[j] == ' ' || s[j] == '\t' || s[j] == '\r' || s[j] == '\n' || s[j] == '\0')
                        {
                            if (tmpnow == &quot;{&quot;)
                            {
                                now = &quot;{&quot;;
                                i = j - 1;
                                break;
                            }
                            tmpnow = &quot;&quot;;
                        }
                        else
                            tmpnow += s[j];
                    }
                    continue;
                }
                if (now == &quot;const&quot;)
                {
                    now = &quot;&quot;;
                    continue;
                }
                if (now == &quot;//&quot;)
                {
                    for (int j = i; s[j]; j++)
                    {
                        if (s[j] == '\n')
                        {
                            i = j - 1;
                            break;
                        }
                    }
                    now = &quot;&quot;;
                    continue;
                }
                if (now == &quot;/*&quot;)
                {
                    int num = 1;
                    string tmpnow = &quot;&quot;;
                    for (int j = i + 1; s[j]; j++)
                    {
                        if (s[j] == ' ' || s[j] == '\t' || s[j] == '\r' || s[j] == '\n' || s[j] == '\0')
                        {
                            if (tmpnow == &quot;/*&quot;)
                                num++;
                            if (tmpnow == &quot;*/&quot;)
                            {
                                num--;
                                if (num == 0)
                                {
                                    i = j - 1;
                                    break;
                                }
                            }
                            tmpnow = &quot;&quot;;
                        }
                        else
                            tmpnow += s[j];
                    }
                    now = &quot;&quot;;
                    continue;
                }
                tokens.push_back(now);
                now = &quot;&quot;;
            }
        }
        else
            now += s[i];
    }
    int cnt = 0;
    string nowNamespace = &quot;&quot;;
    for (int i = 1; i &lt; (int)tokens.size(); i++)
    {
        if ((tokens[i] == &quot;struct&quot; || tokens[i] == &quot;class&quot;) &amp;&amp; tokens[i + 2] == &quot;{&quot;)
        {
            cnt = 0;
            nowNamespace = tokens[i + 1];
            i += 2;
        }
        functions tmp(nowNamespace);
        if (tokens[i] == &quot;{&quot; &amp;&amp; tokens[i - 1] == &quot;)&quot;)
        {
            int num = 1;
            for (int j = i - 2; j &gt;= 0; j--)
            {
                if (tokens[j] == &quot;)&quot;)
                    num++;
                if (tokens[j] == &quot;(&quot;)
                {
                    num--;
                    if (num == 0)
                    {
                        tmp.name = tokens[j - 1];
                        tmp.outputType = &quot;&quot;;
                        for (int k = j - 2; k &gt;= 0; k--)
                            if (tokens[k] != &quot;}&quot; &amp;&amp; tokens[k] != &quot;}&quot; &amp;&amp; tokens[k] != &quot;;&quot; &amp;&amp;
                                tokens[k].back() != ':' &amp;&amp; tokens[k] != &quot;inline&quot; &amp;&amp;
                                tokens[k] != &quot;static&quot; &amp;&amp; tokens[k][0] != '#' &amp;&amp;
                                tokens[k].back() != '\&quot;' &amp;&amp; tokens[k].back() != '&gt;')
                                tmp.outputType = tmp.outputType == &quot;&quot; ? tokens[k] : tokens[k] + &quot; &quot; + tmp.outputType;
                            else
                                break;
                        int last = i - 2;
                        for (int k = i - 2; k &gt;= j; k--)
                        {
                            if (tokens[k] == &quot;(&quot; || tokens[k] == &quot;,&quot;)
                            {
                                string tt = &quot;&quot;;
                                for (int t = k + 1; t &lt; last; t++)
                                    tt = tt == &quot;&quot; ? tokens[t] : tt + &quot; &quot; + tokens[t];
                                if (tt != &quot;&quot;)
                                    tmp.inputType.push_back(tt);
                                last = k - 1;
                            }
                            if (tokens[k] == &quot;=&quot; || tokens[k] == &quot;)&quot;)
                                last = k - 1;
                        }
                        reverse(tmp.inputType.begin(), tmp.inputType.end());
                        break;
                    }
                }
            }
            funs.push_back(tmp);
            num = 1;
            for (int j = i + 1; j &lt; (int)tokens.size(); j++)
            {
                if (tokens[j] == &quot;{&quot;)
                    num++;
                if (tokens[j] == &quot;}&quot;)
                {
                    num--;
                    if (num == 0)
                    {
                        i = j;
                        break;
                    }
                }
            }
            continue;
        }
        if (nowNamespace != &quot;&quot;)
        {
            if (tokens[i] == &quot;{&quot;)
                cnt++;
            if (tokens[i] == &quot;}&quot;)
            {
                cnt--;
                if (!cnt)
                    nowNamespace = &quot;&quot;;
            }
        }
    }
}
int main()
{
    char ch;
    while ((ch = getchar()) != EOF)
        source += ch;
    solve(source);
    for (auto &amp;i : funs)
    {
        if (i.outputType != &quot;&quot;)
            cout &lt;&lt; i.outputType &lt;&lt; &quot; &quot;;
        if (i.inClass != &quot;&quot;)
            cout &lt;&lt; i.inClass &lt;&lt; &quot;::&quot;;
        cout &lt;&lt; i.name &lt;&lt; &quot;(&quot;;
        for (int j = 0; j &lt; (int)i.inputType.size(); j++)
            cout &lt;&lt; i.inputType[j] &lt;&lt; (j == (int)i.inputType.size() - 1 ? &quot;)&quot; : &quot;,&quot;);
        if ((int)i.inputType.size() == 0)
            cout &lt;&lt; &quot;)&quot;;
        cout &lt;&lt; endl;
    }
    return 0;
}
</code></pre><h2>5E. Enjoy the Game</h2><h3>大意</h3><p>给出一个规则：$n$ 张卡牌，先手第一步最少拿 $1$ 张，最多拿 $n-1$ 张。接下来每一步，双方最少要拿 $1$ 张，最多拿等同于上一步对方拿的牌数的牌。拿走最后一张牌胜。问对不同的 $n$，先手是否有必胜策略。</p><h3>思路</h3><p>找规律找出来的，只要是二的幂就是 Alice 胜，否则就是 Bob 胜。这题好像把 <code>__builtin_popcount(n)</code> 给卡了，原因不明，反正下次是不敢用了。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
long long lowbit(long long x)
{
    return x&amp;(-x);
}
   
int main()
{
    long long n;
    cin &gt;&gt; n;
    if (lowbit(n) == n)
    {
        cout &lt;&lt; &quot;Alice&quot; &lt;&lt; endl;
        return 0;
    }
    cout &lt;&lt; &quot;Bob&quot; &lt;&lt; endl;
    return 0;
}
</code></pre><h2>5H. Hash</h2><h3>大意</h3><p>给出一个字符串和一个 Hash 函数（核心代码 <code>res = (res * 26 + str[i] - 'a') % mod;</code>），求一个字典序最小且大于该字符串且有着相同 Hash 的字符串。</p><h3>思路</h3><p>其实就是把字符串转成了二十六进制数，然后给它取模。那么要想 Hash 值相同字典序还要大于原字符串，就直接给这个二十六进制数加上模数就好了。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main()
{
    string a;
    int m;
    int ta[6];
    while (cin &gt;&gt; a &gt;&gt; m)
    {
        int org[6], backup[6];
        for (int i = 0; i &lt; 6; i++)
        {
            org[i] = a[i] - 'a';
            backup[i] = org[i];
        }
        string b = a;
        for (int i = 5; i &gt;= 0; i--)
        {
            ta[i] = m % 26;
            m /= 26;
        }
        if (m != 0)
        {
            cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;
        }
        for (int i = 5; i &gt; 0; i--)
        {
            org[i] += ta[i];
            if (org[i] &gt; 25)
            {
                org[i] -= 26;
                org[i - 1]++;
            }
        }
        org[0] += ta[0];
        if (org[0] &lt; 26)
        {
            for (int i = 0; i &lt; 6; i++)
            {
                printf(&quot;%c&quot;, org[i] + 'a');
            }
            cout &lt;&lt; endl;
            continue;
        }
        else
        {
            cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;
            continue;
        }
    }
 
    return 0;
}
</code></pre><h2>5I. I 题是个签到题</h2><h3>大意</h3><p>给出一场比赛参赛人数和各题过题人数，通过人数不低于全场人数的 $80\%$ 或在所有题目中前三多就叫签到题。问 I 题是不是签到题。</p><h3>思路</h3><p>签到题。排序即可，关键是要处理并列的情况。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
struct temp
{
    int num;
    int ac;
} a[20000];
 
bool cmp(temp a, temp b)
{
    return a.ac &gt; b.ac;
}
 
int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 0; i &lt; n; i++)
    {
        cin &gt;&gt; a[i].ac;
        a[i].num = i;
    }
    if (a[8].ac * 10 &gt;= m * 8)
    {
        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
        return 0;
    }
    sort(a, a + n, cmp);
    int cnt = 1;
    int cur = 1;
    if (a[0].num == 8)
    {
        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
        return 0;
    }
    for (int i = 1; i &lt; n; i++)
    {
        if (a[i].ac != a[i - 1].ac)
        {
            cnt += cur;
            cur = 1;
        }
        else
        {
            cur++;
        }
        if (a[i].num == 8 &amp;&amp; cnt &lt;= 3)
        {
            cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
            return 0;
        }
        if (cnt &gt; 3)
        {
            cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
            return 0;
        }
    }
}
</code></pre><h2>5J. 牛牛战队的秀场</h2><h3>大意</h3><p>求圆内接正 $n$ 边形的边长。</p><h3>思路</h3><p>签到。可以很容易地计算每条弦对应的圆心角的大小，然后三角函数。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
#define PI 3.1415926535898
 
int main()
{
    double n, r, i, j;
    cin &gt;&gt; n &gt;&gt; r &gt;&gt; i &gt;&gt; j;
    if (i == j)
    {
        cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;
        return 0;
    }
    if (i &gt; j)
        swap(i, j);
    double ans = min(j - i, i - j + n);
    printf(&quot;%.8lf\n&quot;, ans * 2 * r * sin(360 / n / 2 * PI / 180));
    return 0;
}
</code></pre><h1>2020 牛客寒假算法基础集训营 6</h1><blockquote>贪心、图论、构造、二分、计数、数论、思维</blockquote><h2>6A. 配对</h2><h3>大意</h3><p>给出两个集合，每个集合里有 $N$ 个数，不同集合的两个数配对并求和，要求最大化第 $K$ 大的和。</p><h3>思路</h3><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
typedef long long ll;
 
int main()
{
    ll n, k;
    cin &gt;&gt; n &gt;&gt; k;
    ll a[n], b[n], c[n];
    for (ll i = 0; i &lt; n; i++)
    {
        cin &gt;&gt; a[i];
    }
    for (ll i = 0; i &lt; n; i++)
    {
        cin &gt;&gt; b[i];
    }
    sort(a, a + n);
    sort(b, b + n);
    for (int i = 0; i &lt; k; i++)
    {
        c[i] = a[n - 1 - i] + b[n - k + i];
    }
    sort(c, c + k);
    cout &lt;&lt; c[0] &lt;&lt; endl;
    return 0;
}
</code></pre><h2>B.</h2> </div>

<div class="show-foot">
<div class="notebook">
<i class="fontello fontello-clock-o"></i>
<span>最后修改：2020 年 05 月 01 日 12 : 06 PM</span>
</div>
<div class="copyright" data-toggle="tooltip" data-html="true" data-original-title="转载请保留本文转载地址，著作权归作者所有"><span>© 允许规范转载</span>
</div>
</div>

</div>
</article>
</div>

<nav class="m-t-lg m-b-lg">
<ul class="pager">
<li class="next"> <a class="box-shadow-wrap-normal" href="../03/How-to-Deploy-WordPress-on-a-Fedora-Server-en.html" title="How to Deploy WordPress on a Fedora Server (en)" data-toggle="tooltip">
下一篇 </a></li> <li class="previous"> <a class="box-shadow-wrap-normal" href="../18/How-to-Port-Calamares-to-Arch-Linux-en.html" title="How to Port Calamares to Arch Linux (en)" data-toggle="tooltip"> 上一篇 </a></li>
</ul>
</nav>

<style>
            textarea#comment{
                background-image: url('https://s2.ax1x.com/2019/07/20/ZzaGcV.png');
                background-color: #ffffff;
                transition: all 0.25s ease-in-out 0s;
            }
            textarea#comment:focus {
                background-position-y: 105px;
                transition: all 0.25s ease-in-out 0s;
            }
        </style>
<div id="comments">


<div id="respond-post-72" class="respond comment-respond no-borders">
<h4 id="reply-title" class="comment-reply-title m-t-lg m-b">发表评论 <small><i class="glyphicon glyphicon-info-sign" data-toggle="tooltip" title="我们将使用 Cookie 保留您的个人信息以便您下次快速评论，继续评论表示您已同意我们这样做"></i>
</small>
<small class="cancel-comment-reply">
<a id="cancel-comment-reply-link" href="2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html#respond-post-72" rel="nofollow" style="display:none" onclick="if (!window.__cfRLUnblockHandlers) return false; return TypechoComment.cancelReply();" data-cf-modified-af8c7cddc53fcd57c335e7ed-="">取消回复</a> </small>
</h4>
<form id="comment_form" method="post" action="https://static.bobby285271.top/index.php/2020/02/09/2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html/comment" class="comment-form" role="form">
<div class="comment-form-comment form-group">
<label class="padder-v-sm" for="comment">评论 <span class="required text-danger">*</span></label>
<textarea id="comment" class="textarea form-control OwO-textarea" name="text" rows="5" placeholder="说点什么吧……" onkeydown="if (!window.__cfRLUnblockHandlers) return false; if(event.ctrlKey&&event.keyCode==13){document.getElementById('submit').click();return false};" data-cf-modified-af8c7cddc53fcd57c335e7ed-=""></textarea>
<div class="OwO padder-v-sm"></div>
<div class="secret_comment" id="secret_comment" data-toggle="tooltip" data-original-title="开启该功能，您的评论仅作者和评论双方可见">
<label class="secret_comment_label control-label">私密评论</label>
<div class="secret_comment_check">
<label class="i-switch i-switch-sm bg-dark m-b-ss m-r">
<input type="checkbox" id="secret_comment_checkbox">
<i></i>
</label>
</div>
</div>
</div>

<div id="author_info" class="row row-sm">
<div class="comment-form-author form-group col-sm-6 col-md-4">
<label for="author">名称 <span class="required text-danger">*</span></label>
<div>
<img class="author-avatar" src="https://secure.gravatar.com/avatar/d41d8cd98f00b204e9800998ecf8427e?s=65&r=G&d=" nogallery />
<input id="author" class="form-control" name="author" type="text" value="" maxlength="245" placeholder="姓名或昵称">
</div>
</div>
<div class="comment-form-email form-group col-sm-6 col-md-4">
<label for="email">邮箱 <span class="required text-danger">*</span>
</label>
<input type="text" name="mail" id="mail" class="form-control" placeholder="邮箱 (必填,将保密)" value="" />
<input type="hidden" name="receiveMail" id="receiveMail" value="yes" />
</div>
<div class="comment-form-url form-group col-sm-12 col-md-4">
<label for="url">地址</label>
<input id="url" class="form-control" name="url" type="url" value="" maxlength="200" placeholder="网站或博客"></div>
</div>

<div class="form-group">
<button type="submit" name="submit" id="submit" class="submit btn-rounded box-shadow-wrap-lg btn-gd-primary padder-lg">
<span>发表评论</span>
<span class="text-active">提交中...</span>
</button>
<i class="animate-spin fontello fontello-spinner hide" id="spin"></i>
<input type="hidden" name="comment_post_ID" id="comment_post_ID">
<input type="hidden" name="comment_parent" id="comment_parent">
</div>
</form>
</div>
</div>
</div>
</div>

<aside class="asideBar col w-md bg-white-only bg-auto no-border-xs" role="complementary">
<div id="sidebar">
<section id="tabs-4" class="widget widget_tabs clear">
<div class="nav-tabs-alt no-js-hide">
<ul class="nav nav-tabs nav-justified box-shadow-bottom-normal tablist" role="tablist">
<li data-index="0" class="active" role="presentation"> <a href="2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html#widget-tabs-4-hots" role="tab" aria-controls="widget-tabs-4-hots" aria-expanded="true" data-toggle="tab"><div class="sidebar-icon wrapper-sm"><i data-feather="thumbs-up"></i></div><span class="sr-only">热门文章</span> </a></li>
<li role="presentation" data-index="1"> <a href="2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html#widget-tabs-4-comments" role="tab" aria-controls="widget-tabs-4-comments" aria-expanded="false" data-toggle="tab"><div class="sidebar-icon wrapper-sm"><i data-feather="message-square"></i></div> <span class="sr-only">最新评论</span> </a></li>
<li data-index="2" role="presentation"> <a href="2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html#widget-tabs-4-random" role="tab" aria-controls="widget-tabs-4-random" aria-expanded="false" data-toggle="tab"> <div class="sidebar-icon wrapper-sm"><i data-feather="gift"></i></div> <span class="sr-only">随机文章</span>
</a></li>
<span class="navs-slider-bar"></span>
</ul>
</div>
<div class="tab-content">

<div id="widget-tabs-4-hots" class="tab-pane  fade in wrapper-md active" role="tabpanel">
<h5 class="widget-title m-t-none text-md">热门文章</h5>
<ul class="list-group no-bg no-borders pull-in m-b-none">
<li class="list-group-item">
<a href="../../04/15/NixOS-Installation-and-Configuration-Guide.html" class="pull-left thumb-sm m-r"><img src="../../../../usr/themes/handsome/usr/img/sj2/3.jpg" class="img-40px normal-shadow img-square"></a>
<div class="clear">
<h4 class="h5 l-h text-second"> <a href="../../04/15/NixOS-Installation-and-Configuration-Guide.html" title="NixOS Installation and Configuration Guide"> NixOS Installation and Configuration Guide </a></h4>
<small class="text-muted post-head-icon"><span class="meta-date"> <i class="fontello fontello-eye" aria-hidden="true"></i> <span class="sr-only">浏览次数:</span> <span class="meta-value">70</span>
</span>
</small></div></li><li class="list-group-item">
<a href="../18/How-to-Port-Calamares-to-Arch-Linux-en.html" class="pull-left thumb-sm m-r"><img src="../../../../usr/themes/handsome/usr/img/sj2/8.jpg" class="img-40px normal-shadow img-square"></a>
<div class="clear">
<h4 class="h5 l-h text-second"> <a href="../18/How-to-Port-Calamares-to-Arch-Linux-en.html" title="How to Port Calamares to Arch Linux (en)"> How to Port Calamares to Arch Linux (en) </a></h4>
<small class="text-muted post-head-icon"><span class="meta-date"> <i class="fontello fontello-eye" aria-hidden="true"></i> <span class="sr-only">浏览次数:</span> <span class="meta-value">46</span>
</span>
</small></div></li><li class="list-group-item">
<a href="2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html" class="pull-left thumb-sm m-r"><img src="../../../../usr/themes/handsome/usr/img/sj2/5.jpg" class="img-40px normal-shadow img-square"></a>
<div class="clear">
<h4 class="h5 l-h text-second"> <a href="2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html" title="2020 Nowcoder Basic Algorithm Training Camp Solutions"> 2020 Nowcoder Basic Algorithm Training Camp Solutions </a></h4>
<small class="text-muted post-head-icon"><span class="meta-date"> <i class="fontello fontello-eye" aria-hidden="true"></i> <span class="sr-only">浏览次数:</span> <span class="meta-value">42</span>
</span>
</small></div></li><li class="list-group-item">
<a href="../../../2019/12/13/SCNUCS-N-2019-Tour.html" class="pull-left thumb-sm m-r"><img src="../../../../usr/themes/handsome/usr/img/sj2/4.jpg" class="img-40px normal-shadow img-square"></a>
<div class="clear">
<h4 class="h5 l-h text-second"> <a href="../../../2019/12/13/SCNUCS-N-2019-Tour.html" title="SCNUCS-N 2019 Tour"> SCNUCS-N 2019 Tour </a></h4>
<small class="text-muted post-head-icon"><span class="meta-date"> <i class="fontello fontello-eye" aria-hidden="true"></i> <span class="sr-only">浏览次数:</span> <span class="meta-value">38</span>
</span>
</small></div></li><li class="list-group-item">
<a href="../../../2019/12/18/segment-tree.html" class="pull-left thumb-sm m-r"><img src="../../../../usr/themes/handsome/usr/img/sj2/6.jpg" class="img-40px normal-shadow img-square"></a>
<div class="clear">
<h4 class="h5 l-h text-second"> <a href="../../../2019/12/18/segment-tree.html" title="Segment Tree (Luogu P3372)"> Segment Tree (Luogu P3372) </a></h4>
<small class="text-muted post-head-icon"><span class="meta-date"> <i class="fontello fontello-eye" aria-hidden="true"></i> <span class="sr-only">浏览次数:</span> <span class="meta-value">36</span>
</span>
</small></div></li> </ul>
</div>

<div id="widget-tabs-4-comments" class="tab-pane fade wrapper-md no-js-show" role="tabpanel">
<h5 class="widget-title m-t-none text-md">最新评论</h5>
<ul class="list-group no-borders pull-in auto m-b-none no-bg">
</ul>
</div>

<div id="widget-tabs-4-random" class="tab-pane fade wrapper-md no-js-show" role="tabpanel">
<h5 class="widget-title m-t-none text-md">随机文章</h5>
<ul class="list-group no-bg no-borders pull-in">
<li class="list-group-item">
<a href="../../../2019/02/02/Chakra-CCR-Packaging-Guide.html" class="pull-left thumb-sm m-r"><img src="../../../../usr/themes/handsome/usr/img/sj2/3.jpg" class="img-40px normal-shadow img-square"></a>
<div class="clear">
<h4 class="h5 l-h text-second"> <a href="../../../2019/02/02/Chakra-CCR-Packaging-Guide.html" title="Chakra CCR Packaging Guide"> Chakra CCR Packaging Guide </a></h4>
<small class="text-muted post-head-icon"><span class="meta-date"> <i class="fontello fontello-eye" aria-hidden="true"></i> <span class="sr-only">浏览次数:</span> <span class="meta-value">32</span>
</span>
</small></div></li><li class="list-group-item">
<a href="../../../2017/10/21/How-to-Generate-a-Hexo-Blog-and-Deploy-it-on-GitHub.html" class="pull-left thumb-sm m-r"><img src="../../../../usr/themes/handsome/usr/img/sj2/8.jpg" class="img-40px normal-shadow img-square"></a>
<div class="clear">
<h4 class="h5 l-h text-second"> <a href="../../../2017/10/21/How-to-Generate-a-Hexo-Blog-and-Deploy-it-on-GitHub.html" title="How to Generate a Hexo Blog and Deploy it on GitHub"> How to Generate a Hexo Blog and Deploy it on GitHub </a></h4>
<small class="text-muted post-head-icon"><span class="meta-date"> <i class="fontello fontello-eye" aria-hidden="true"></i> <span class="sr-only">浏览次数:</span> <span class="meta-value">35</span>
</span>
</small></div></li><li class="list-group-item">
<a href="../../../2019/12/26/Dynamic-Programming-on-Tree-Structures-Luogu-P2014.html" class="pull-left thumb-sm m-r"><img src="../../../../usr/themes/handsome/usr/img/sj2/5.jpg" class="img-40px normal-shadow img-square"></a>
<div class="clear">
<h4 class="h5 l-h text-second"> <a href="../../../2019/12/26/Dynamic-Programming-on-Tree-Structures-Luogu-P2014.html" title="Dynamic Programming on Tree Structures (Luogu P2014)"> Dynamic Programming on Tree Structures (Luogu P2014) </a></h4>
<small class="text-muted post-head-icon"><span class="meta-date"> <i class="fontello fontello-eye" aria-hidden="true"></i> <span class="sr-only">浏览次数:</span> <span class="meta-value">30</span>
</span>
</small></div></li><li class="list-group-item">
<a href="../../04/15/NixOS-Installation-and-Configuration-Guide.html" class="pull-left thumb-sm m-r"><img src="../../../../usr/themes/handsome/usr/img/sj2/4.jpg" class="img-40px normal-shadow img-square"></a>
<div class="clear">
<h4 class="h5 l-h text-second"> <a href="../../04/15/NixOS-Installation-and-Configuration-Guide.html" title="NixOS Installation and Configuration Guide"> NixOS Installation and Configuration Guide </a></h4>
<small class="text-muted post-head-icon"><span class="meta-date"> <i class="fontello fontello-eye" aria-hidden="true"></i> <span class="sr-only">浏览次数:</span> <span class="meta-value">70</span>
</span>
</small></div></li><li class="list-group-item">
<a href="../../../2019/12/13/SCNUCS-N-2019-Tour.html" class="pull-left thumb-sm m-r"><img src="../../../../usr/themes/handsome/usr/img/sj2/6.jpg" class="img-40px normal-shadow img-square"></a>
<div class="clear">
<h4 class="h5 l-h text-second"> <a href="../../../2019/12/13/SCNUCS-N-2019-Tour.html" title="SCNUCS-N 2019 Tour"> SCNUCS-N 2019 Tour </a></h4>
<small class="text-muted post-head-icon"><span class="meta-date"> <i class="fontello fontello-eye" aria-hidden="true"></i> <span class="sr-only">浏览次数:</span> <span class="meta-value">38</span>
</span>
</small></div></li> </ul>
</div>
</div>
</section>

<section id="blog_info" class="widget widget_categories wrapper-md clear">
<h5 class="widget-title m-t-none text-md">博客信息</h5>
<ul class="list-group box-shadow-wrap-normal">
<li class="list-group-item text-second"><span class="blog-info-icons"> <i data-feather="award"></i></span> <span class="badge
           pull-right">11</span>文章数目</li>
<li class="list-group-item text-second"> <span class="blog-info-icons"> <i data-feather="message-circle"></i></span>
<span class="badge
           pull-right">1</span>评论数目</li>
<li class="list-group-item text-second"><span class="blog-info-icons"> <i data-feather="calendar"></i></span>
<span class="badge
           pull-right">3年140天</span>运行天数</li>
<li class="list-group-item text-second"><span class="blog-info-icons"> <i data-feather="activity"></i></span> <span class="badge
           pull-right">2 星期前</span>最后活动</li>
</ul>
</section>


<section id="tag_cloud-2" class="widget widget_tag_cloud wrapper-md clear">
<h5 class="widget-title m-t-none text-md">标签云</h5>
<div class="post-tags tags l-h-2x">
<a href="../../../tag/Algorithm/index.html">Algorithm</a> <a href="../../../tag/Contest/index.html">Contest</a> <a href="../../../tag/Nowcoder/index.html">Nowcoder</a> </div>
</section>
<div id="tag_toc_body">
<section id="tag_toc" class="widget widget_categories wrapper-md clear">
<h5 class="widget-title m-t-none text-md">文章目录</h5>
<div class="tags l-h-2x box-shadow-wrap-normal">
<div id="toc"></div>
</div>
</section>
<div class="hidden-lg tocify-mobile-panel panel panel-default
              setting_body_panel" aria-hidden="true">
<button class="border-radius-half-left btn btn-default no-shadow pos-abt " data-toggle="tooltip" data-placement="left" data-original-title="目录" data-toggle-class=".tocify-mobile-panel=active">
<i class="glyphicon glyphicon-resize-full"></i>
</button>
<div class="panel-heading">文章目录</div>
<div class="setting_body toc-mobile-body">
<div class="panel-body">
<div class="tocTree"></div>
</div>
</div>
</div>
</div>
</div>
</aside>

</div>
</main>
<div id="morphing-content" class="hidden read_mode_article">
<div class="page">
<h1 class="title">2020 Nowcoder Basic Algorithm Training Camp Solutions</h1>
<div class="metadata singleline"><a href="2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html#" rel="author" class="byline">bobby285271</a>&nbsp;•&nbsp;<span class="delimiter"></span><time class="date">2020 年 02 月 09 日</time></div>
<p>颓废了一个寒假，Codeforces 打来打去都是 Specialist，菜的一批。POJ 又刷到怀疑人生。后来被 Kaidora 神犇安排了这个集训营。当时已经是第四场要开始了，还是去了。果然，哪怕都是自闭五小时每小时过一题，氪了金感觉就是不一样。</p><p>点击下方的页码查看相应场次的记录，第 $i$ 页对应的是第 $i-1$ 场比赛。</p><h1>2020 牛客寒假算法基础集训营 1</h1><blockquote>字符串、贪心、矩阵快速幂、概率论、计算几何、并查集、数论</blockquote><h2>1A. Honoka 和格点三角形</h2><h3>大意</h3><p>给出 $m \times n$ 格点矩阵，问在矩阵里面能找出多少个面积为 $1$，且至少有一条边平行于 $x$ 轴或 $y$ 轴的三角形。答案对 $1000000007$ 取模。</p><h3>思路</h3><p>若存在平行于 $x$ 轴或 $y$ 轴的边且长度为 $2$，一共有 $2(n-1)(m-2)m+2(m-1)(n-2)n$ 种情况。</p><p>若存在平行于 $x$ 轴或 $y$ 轴的边且长度为 $1$，除去已经计算过的情况（即还存在平行于$x$ 轴或 $y$ 轴且长度为 $2$ 的边），一共有 $2(m-1)(m-2)(n-2)+2(n-1)(n-2)(m-2)$ 种情况。</p><p>相加后化简，得到 $2(m+n-2)(2mn-3m-3n+4)$，利用 $ab\ mod\ c = ((a\ mod\ c)(b\ mod\ c))\ mod\ c$ 计算结果。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    long long n, m, tempa, tempb;
    cin &gt;&gt; n &gt;&gt; m;
    tempa = 2 * (m + n - 2);
    tempb = (2 * m * n - 3 * m - 3 * n + 4);
    cout &lt;&lt; (tempa % 1000000007) * (tempb % 1000000007) % 1000000007 &lt;&lt; endl;
    return 0;
}
</code></pre><h2>1B. Kotori 和 Bangdream</h2><h3>大意及思路</h3><p>签到题。求数学期望，也就是可能结果的概率乘以其结果的总和。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    double n, x, a, b;
    cin &gt;&gt; n &gt;&gt; x &gt;&gt; a &gt;&gt; b;
    double ans = (a * x + b * (100 - x)) * n / 100;
    printf(&quot;%.2lf\n&quot;, ans);
    return 0;
}
</code></pre><h2>1C. Umi 和弓道</h2><h3>大意</h3><p>一个人在 $(x_0,y_0)$，给出 $n$ 个靶子，在 $x$ 轴或 $y$ 轴放置挡板，令放置挡板后可以射中的靶子数量不多于 $k$ 个。</p><h3>思路</h3><p>只要靶子和 $(x_0,y_0)$ 不在一个象限就有可能被挡掉。要想挡掉一个靶子，只需求出靶子和 $(x_0,y_0)$ 所在直线与坐标轴的交点，并保证挡板覆盖了这个点。我们只需要恰好覆盖 $n-k$ 个这样的点就行了。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const double inf = 1e18;
vector&lt;double&gt; v1, v2;
int main()
{
    v1.clear();
    v2.clear();
    double x0, y0;
    int n, k, i;
    cin &gt;&gt; x0 &gt;&gt; y0 &gt;&gt; n &gt;&gt; k;
    k = n - k;
    for (i = 0; i &lt; n; i++)
    {
        double x, y;
        cin &gt;&gt; x &gt;&gt; y;
        if (x * x0 &lt; 0)
        {
            v2.push_back(y0 - x0 * (y - y0) / (x - x0));
        }
        if (y * y0 &lt; 0)
        {
            v1.push_back(x0 - y0 * (x - x0) / (y - y0));
        }
    }
    double mi = inf;
    sort(v1.begin(), v1.end());
    sort(v2.begin(), v2.end());
    if (v1.size() &gt;= k)
    {
        double head = 0, tail = k - 1;
        while (tail &lt; v1.size())
        {
            mi = mi &gt; (v1[tail] - v1[head]) ? (v1[tail] - v1[head]) : mi;
            tail++, head++;
        }
    }
    if (v2.size() &gt;= k)
    {
        double head = 0, tail = k - 1;
        while (tail &lt; v2.size())
        {
            mi = mi &gt; (v2[tail] - v2[head]) ? (v2[tail] - v2[head]) : mi;
            tail++, head++;
        }
    }
    if (mi == 1e18)
        cout &lt;&lt; -1;
    else
        printf(&quot;%.7lf&quot;, mi);
    return 0;
}
</code></pre><h2>1D. Hanayo 和米饭</h2><h3>大意</h3><p>给出 $n-1$ 个数，求一个数使得所有的 $n$ 个数经过排序后可形成公差为 $1$ 的等差数列。保证答案存在且唯一。</p><h3>思路</h3><p>签到题。将 $n-1$ 个数排序，看相邻两数的差是否为 $2$。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int n;
    cin &gt;&gt; n;
    int a[n - 1];
    for (int i = 0; i &lt; n - 1; i++)
    {
        cin &gt;&gt; a[i];
    }
    sort(a, a + n - 1);
    for (int i = 0; i &lt; n - 2; i++)
    {
        if (a[i + 1] - a[i] != 1)
        {
            cout &lt;&lt; a[i] + 1 &lt;&lt; endl;
            break;
        }
    }
    return 0;
}
</code></pre><h2>1E. Rin 和快速迭代</h2><h3>大意</h3><p>令 $f(x)$ 为 $x$ 因子个数，将 $f$ 迭代下去，问迭代多少次能得到 $2$。</p><h3>思路</h3><p>模拟就行。求因子个数时注意处理完全平方数。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
long long sol(long long x)
{
    long long temp = 0;
    long long i;
    for (i = 1; i * i &lt;= x; i++)
    {
        if (x % i == 0)
            temp++;
    }
    temp = temp &lt;&lt; 1;
    i--;
    if (i * i == x)
        temp--;
    return temp;
}
int main()
{
    long long n;
    cin &gt;&gt; n;
    int ans = 0;
    while (1)
    {
        n = sol(n);
        ans++;
        if (n == 2)
        {
            cout &lt;&lt; ans &lt;&lt; endl;
            return 0;
        }
    }
    return 0;
}
</code></pre><h2>1F. Maki 和 Tree</h2><h3>大意</h3><p>在树（无向）中有黑白两种点。求 $n$ 个点的树中有多少简单路径有且仅有通过一个黑色点。</p><h3>思路</h3><p>先预处理各个白色连通及其大小，具体思路是读入一条边如果这条边的两端都是白色连通块就连在一起（并查集）。然后再算各个黑点的答案。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
int fa[111111];  //父亲
int kdm[111111]; //孩子数量
string color;
int f(int x)
{ //寻找祖先
    if (fa[x] == x)
        return x;
    return f(fa[x]);
}
void uni(int x, int y)
{ //连接 x 点和 y 点
    int p = f(x), q = f(y);
    if (p != q)
    {
        if (kdm[p] &gt; kdm[q])
        {
            fa[q] = p;
            kdm[p] += kdm[q] + 1;
        }
        else
        {
            fa[p] = q;
            kdm[q] += kdm[p] + 1;
        }
    }
}
ll t[111111]; //统计连通块白点数量
vector&lt;int&gt; g[111111];
ll gao(vector&lt;int&gt; temp)
{ //temp 为黑点的每个相邻白点孩子数量集合
    ll res = 0, i;
    ll n = temp.size();
    if (n == 0)
        return 0;
    ll dp[n] = {0}, sum[n] = {0}, s = 0;
    sum[0] = s = temp[0];
    for (i = 0; i &lt; n; i++)
    {
        res += temp[i];
    }
    for (i = 1; i &lt; n; i++)
    {
        sum[i] = s += temp[i];
    }
    for (i = 1; i &lt; n; i++)
    {
        dp[i] = dp[i - 1] + temp[i] * sum[i - 1];
    }
    return res + dp[n - 1];
}
int main()
{

    int n, i, j;
    cin &gt;&gt; n &gt;&gt; color;
    for (i = 1; i &lt;= n; i++)
        fa[i] = i;
    for (i = 1; i &lt; n; i++)
    {
        int x, y;
        cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y);
        g[y].push_back(x);
        if (color[x - 1] == 'W' &amp;&amp; color[y - 1] == 'W')
            uni(x, y);
    }
    ll sum = 0;
    for (i = 1; i &lt;= n; i++)
        t[i] = kdm[f(i)] + 1;
    for (i = 1; i &lt;= n; i++)
    {
        if (color[i - 1] == 'B')
        {
            vector&lt;int&gt; temp;
            for (j = 0; j &lt; g[i].size(); j++)
            {
                if (color[g[i][j] - 1] == 'W')
                    temp.push_back(t[g[i][j]]); //若相邻点是白点，加入 temp
            }
            sum += gao(temp);
        }
    }
    cout &lt;&lt; sum;
}
</code></pre><h2>1G. Eli 和字符串</h2><h3>大意</h3><p>给出一个字符串，求连续子串的最小长度，要求这个连续子串要包含至少 $k$ 个相同的某个字母。</p><h3>思路</h3><p>前缀和加尺取法。前缀和用于求某个连续子串各个字母出现的次数。尺取法即连续子串两个指针，右指针不断右移，当发现满足条件的连续子串则左指针开始右移，当右指针移动到尽头则停止。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int cnt[26][200010];
int main()
{
    int n, k;
    string a;
    cin &gt;&gt; n &gt;&gt; k &gt;&gt; a;
    int l = a.size();
    for (int i = 0; i &lt; l; i++)
    {
        for (int j = 0; j &lt; 26; j++)
        {
            cnt[j][i + 1] = cnt[j][i];
        }
        cnt[a[i] - 'a'][i + 1]++;
    }
    int p1 = 0, p2 = 1, ans = n + 1;
    while (1)
    {
        int flag = 0;
        for (int i = 0; i &lt; 26; i++)
        {
            if (cnt[i][p2] - cnt[i][p1] &gt;= k)
            {
                ans = min(ans, p2 - p1);
                flag = 1;
            }
        }
        if (flag == 1)
            p1++;
        else
            p2++;
        if (p2 == n + 1)
            break;
    }
    if (ans == n + 1)
        cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;
    else
        cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h2>1H. Nozomi 和字符串</h2><h3>大意</h3><p>一个 $01$ 串，允许你改变其中的 $k$ 个数字，然后找出一个尽可能长的连续子串，这个子串上的所有字符都相同。求这个子串的长度。</p><h3>思路</h3><p>依然是尺取法。分成将 $0$ 变成 $1$ 和将 $1$ 变成 $0$ 两种情况。对于前者，还是两个指针，右指针不断右移，当遇到 $0$ 就用掉一次操作直到次数用尽。接下来右指针继续右移直到再次需要操作的时候，这时左指针右移直到已用操作数恰好减一为止，这时右指针继续右移。后者同理。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    string s;
    int n, k, ans = 0;
    cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;
    int pl = 0, pr = 0, change = 0;
    // 0 =&gt; 1
    for (int i = 0; i &lt; n; i++)
    {
        if (s[i] == '0')
        {
            if (change &lt; k)
            {
                change++;
            }
            else
            {
                while (pl &lt;= pr &amp;&amp; s[pl] != '0')
                    pl++;
                pl++;
            }
        }
        pr++;
        ans = max(ans, pr - pl);
    }
    pl = 0, pr = 0, change = 0;
    for (int i = 0; i &lt; n; i++)
    {
        if (s[i] == '1')
        {
            if (change &lt; k)
            {
                change++;
            }
            else
            {
                while (pl &lt;= pr &amp;&amp; s[pl] != '1')
                    pl++;
                pl++;
            }
        }
        pr++;
        // cout &lt;&lt; pl &lt;&lt; &quot; &quot; &lt;&lt; pr &lt;&lt; endl;
        ans = max(ans, pr - pl);
        // cout &lt;&lt; ans &lt;&lt; endl;
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h2>1I. Nico 和 Niconiconi</h2><h3>大意</h3><p>给出一个字符串，其中 <code>nico</code> 计 $a$ 分，<code>niconi</code> 计 $b$ 分，<code>niconiconi</code> 计 $c$ 分，每个字符都只能参与一次计分，问最大分数。</p><h3>思路</h3><p>简单 DP。$dp[i]$ 可由 $dp[i-1]$、$dp[i-3]$、$dp[i-5]$ 和 $dp[i-9]$ 转移而来，转移后取最大者即可。要注意避免越界。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
long long dp[300010];
int main()
{
    string s;
    long long n, a, b, c;
    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; s;
    for (long long i = 0; i &lt; n; i++)
    {
        if (i &gt; 0)
            dp[i] = dp[i - 1];
        if (i &gt;= 3 &amp;&amp; s.substr(i - 3, 4) == &quot;nico&quot;)
            dp[i] = max(dp[i], dp[i - 3] + a);
        if (i &gt;= 5 &amp;&amp; s.substr(i - 5, 6) == &quot;niconi&quot;)
            dp[i] = max(dp[i], dp[i - 5] + b);
        if (i &gt;= 9 &amp;&amp; s.substr(i - 9, 10) == &quot;niconiconi&quot;)
            dp[i] = max(dp[i], dp[i - 9] + c);
    }
    cout &lt;&lt; dp[n - 1] &lt;&lt; endl;
    return 0;
}
</code></pre><h2>1J. ## TODO</h2><h1>2020 牛客寒假算法基础集训营 2</h1><blockquote>枚举、贪心、DP、数论、思维、数据结构、哈希</blockquote><h2>2A. 做游戏</h2><h3>大意</h3><p>石头剪刀布。已知两人分别出了多少次石头、剪刀和布，求其中一个玩家最多能获胜多少局。</p><h3>思路</h3><p>贪心。让尽量多的剪刀 - 布、石头 - 剪刀和布 - 石头成组，可以直接出答案 $min(A,Y)+min(B,Z)+min(C,X)$。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    long long a, b, c, x, y, z;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; x &gt;&gt; y &gt;&gt; z;
    cout &lt;&lt; min(a, y) + min(b, z) + min(c, x) &lt;&lt; endl;
    return 0;
}
</code></pre><h2>2B. 排数字</h2><h3>大意</h3><p>给出一个字符串 $S$，问将字符串打乱后最多能有多少个不同的连续子串为 $616$ 。</p><h3>思路</h3><p>只需将所有的 $6$ 和 $1$ 集中起来：$6161616...$ ，因此统计 $6$ 和 $1$ 的个数即可，得出答案。注意 $cnt6$ 个 $6$ 最多能只造 $cnt6-1$ 个满足题意的字串，所以是 $min(cnt6-1,cnt1)$。如果算出来小于零应该将答案调整为 $0$。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int n, cnt1 = 0, cnt6 = 0;
    string s;
    cin &gt;&gt; n &gt;&gt; s;
    for (int i = 0; i &lt; n; i++)
    {
        if (s[i] == '1')
            cnt1++;
        else if (s[i] == '6')
            cnt6++;
    }
    cout &lt;&lt; max(0, min(cnt6 - 1, cnt1)) &lt;&lt; endl;
    return 0;
}
</code></pre><h2>2C. 算概率</h2><h3>大意</h3><p>一共 $n$ 道题，第 $i$ 道题的正确率是 $p_i$​，给出这个正确率对 $10^9+7$ 取模的结果，求这 $n$ 题里恰好有 $0,1,\cdots,n$ 题正确的概率分别是多少，同样对 $10^9+7$ 取模。对分数取模的定义已在题目给出。</p><h3>思路</h3><p>简单 DP。一个难点是求状态转移方程，一个是理解题目中对分数取模的概念（本蒟蒻在补第四套题时才会的乘法逆元，做这道题时直接观察样例对 $\frac{1}{2}$ 取模的结果，然后分子分母代进 $a$ 和 $b$ 蒙一把，发现简单粗暴地将概率乘个 $(10^9+7)+1$ 就是了）。要求前 $i$ 题正确 $j$ 题的概率，首先要知道的是前面具体过了哪几道题我们不需要知道（这里有点靠直觉），我们只需要简单粗暴地把它当作一个整体参与后面的计算。接下来，我们要分两种情况讨论，一个是第 $i$ 题对了 $f_{i-1,j} \cdot p_i$，一个是第 $i$ 题错了 $f_{i,j} \cdot (1-p_i)$，加起来就是了。状态转移方程 $f_{i,j} = f_{i-1,j} \cdot p_i+f_{i-1,j} \cdot (1-p_i)$。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

long long n, p[2005], dp[2005][2005];

int main()
{
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++)
    {
        cin &gt;&gt; p[i];
    }
    dp[0][0] = 1;
    for (int i = 1; i &lt;= n; i++)
    {
        dp[i][0] = dp[i - 1][0] * (1000000008 - p[i]) % 1000000007;
        for (int j = 1; j &lt;= i; j++)
            dp[i][j] = (dp[i - 1][j] * (1000000008 - p[i]) + dp[i - 1][j - 1] * p[i]) % 1000000007;
    }
    for (int i = 0; i &lt;= n; i++)
        cout &lt;&lt; dp[n][i] &lt;&lt; ' ';
    return 0;
}

</code></pre><h2>2D. 数三角</h2><h3>大意</h3><p>给出 $n$ 个点，问这 $n$ 个点形成的三角形中，总共有多少个钝角三角形。</p><h3>思路</h3><p>签到。枚举后比较 $a^2+b^2$ 和 $c^2$ 即可，另外注意三点不能共线。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int n, a[505], b[505], ans = 0;

bool f(int i, int j, int k)
{
    int check1 = (a[j] - a[i]) * (a[k] - a[i]) + (b[j] - b[i]) * (b[k] - b[i]);
    int check2 = (a[j] - a[i]) * (b[k] - b[i]) - (a[k] - a[i]) * (b[j] - b[i]);
    return check1 &lt; 0 &amp;&amp; check2 != 0;
}
int main()
{
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++)
        cin &gt;&gt; a[i] &gt;&gt; b[i];
    for (int i = 0; i &lt; n; i++)
    {
        for (int j = i + 1; j &lt; n; j++)
        {
            for (int k = j + 1; k &lt; n; k++)
            {
                if (f(i, j, k) || f(k, i, j) || f(j, i, k))
                {
                    ans++;
                }
            }
        }
    }

    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h2>2E. 做计数</h2><h3>大意</h3><p>求有多少个不同的正整数三元组 $(i,j,k)$ 满足 $\sqrt i+\sqrt j = \sqrt k$，而且 $i \cdot j \leq n$。</p><h3>思路</h3><p>看过一样的题，所以说多去看百度贴吧的营销号推送确实能涨知识。见到根号疯狂平方就对了（必要时候还是要移项的）。等式左右两边平方，$i+j+2 \sqrt {ij}=k$，发现要使 $k$ 为整数，必需要令 $i \cdot j$ 为完全平方数，所以我们就枚举完全平方数，然后再枚举这些完全平方数的因数。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int n, ans;
int main()
{
    cin &gt;&gt; n;
    for (int i = 1; i * i &lt;= n; i++)
    {
        for (int j = 1; j &lt;= i; j++)
            if (i * i % j == 0)
                ans += 2;
        ans--;
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h2>2F. 拿物品</h2><h3>大意</h3><p>多个物品，每个物品两个属性 $a$ 和 $b$， 甲乙两人轮流拿物品，最后甲的得分为其拿到物品的 $a$ 属性的和，乙则为 $b$ 属性的和。问两人最优策略下会拿哪些物品。</p><h3>思路</h3><p>假设两人赛后互换物品 $(a_1,b_1)$ 和 $(a_2,b_2)$，那么两人得分变化分别为 $-a_1+a_2$ 和 $b_1-b_2$，如果想让前者得分更大，要有 $a_1+b_1 &lt; a_2+b_2$。后者同理。所以就按照 $a+b$ 排序。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

const int N = 2e5 + 7;
int n;
vector&lt;int&gt; sa, sb;
struct temp
{
    int a, b, id;
} a[N];

bool cmp(temp a, temp b)
{
    return a.a + a.b &gt; b.a + b.b;
}

int main()
{
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++)
        cin &gt;&gt; a[i].a;
    for (int i = 1; i &lt;= n; i++)
    {
        cin &gt;&gt; a[i].b;
        a[i].id = i;
    }
    sort(a + 1, a + 1 + n, cmp);
    for (int i = 1; i &lt;= n; ++i)
        ((i &amp; 1) ? sa : sb).push_back(a[i].id);
    for (auto i : sa)
        cout &lt;&lt; i &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;
    for (auto i : sb)
        cout &lt;&lt; i &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;
    return 0;
}
</code></pre><h2>2G. 判正误</h2><h3>大意</h3><p>给出七个整数 $a, b, c, d, e, f, g$ 问是否有 $a^d+b^e+c^f=g$。数据范围 $10^9$ 级别，数据量 $10^3$ 级别。</p><h3>思路</h3><p>在模的意义下上快速幂验证，也就是验证 $a^d+b^e+c^f \equiv g \left ( mod \ M\right )$。模数越多，数据越水，就越稳。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int mod[] = {2, 3, 5, 7, 11, 31, 71, 97, 233, 397, 433, 449, 607, 857, 10007, 21179, 36251, 44579, 62003, 72883, 97843, 139991, 232013, 369353, 681521, 692711, 777241, 822821, 1956761, 2145137, 2915837, 6229117, 7788787, 13743493, 17331841, 19260817, 19269293, 19959809, 21006959, 23937083, 24410849, 28452757, 28478603, 29229359, 35570827, 35604011, 35875487, 37370863, 38303347, 38475517, 38819149, 40455791, 44021539, 45641993, 46531301, 48866749, 50529641, 52634191, 52790587, 55180799, 56971613, 58259351, 60954737, 62207269, 63367453, 65072599, 66017821, 67952779, 69475349, 74689217, 77059907, 77907121, 79391659, 84768797, 85584601, 85724879, 85756609, 86850899, 91783511, 92331541, 94519499, 96375241, 99033413, 99486311, 100569829, 106873549, 109329881, 109913681, 111186487, 111894067, 112136617, 112417363, 114011921, 119143363, 122994493, 123747781, 124001021, 126515639, 128191039, 128767909, 132222763, 133587661, 139644719, 145641527, 153388423, 155187077, 156883333, 157989581, 159538063, 161488643, 164039129, 166070447, 169181543, 169554227, 173564801, 175742867, 185469637, 187203899, 191263223, 198691817, 204144887, 211631201, 217903877, 218028203, 220073423, 228143453, 228667423, 232064653, 240519263, 245647159, 247586411, 247936121, 250949197, 253413211, 253464329, 260572729, 260590409, 262887773, 265711423, 266763641, 273585149, 276472817, 276500531, 280543667, 280649591, 281385491, 291366337, 293273159, 296973107, 302890501, 306568693, 315614297, 316729409, 317617121, 320337781, 320613497, 321322823, 324691051, 325963067, 327184157, 329900633, 330670159, 332058781, 332213669, 332300869, 334382221, 341895677, 347938237, 349011827, 349347503, 349906439, 353796941, 364557253, 364755931, 367946441, 372413831, 374358983, 379589897, 381149689, 389431873, 404683493, 405216109, 405495029, 408142403, 408989747, 410841979, 410935093, 412405351, 412592459, 412722139, 412990573, 418171483, 421270357, 424233613, 427938449, 428492083, 429962881, 430883569, 434988383, 435941201, 438816151, 440052953, 440143589, 444693631, 453646433, 455847109, 456640189, 457911511, 458185237, 463116761, 463861417, 469275953, 471298573, 471712513, 478267417, 483824813, 494828483, 497397293, 499657393, 507957479, 512906621, 519346459, 519879973, 520094713, 523213693, 525673273, 529575763, 529883803, 533887031, 534260809, 535328309, 541992667, 542253071, 544780177, 545567609, 552922529, 555129893, 555820037, 558473471, 563484017, 571310471, 578121241, 582251063, 583825639, 584121323, 592038487, 599098811, 601467677, 610073969, 615059213, 619220713, 622457177, 627412609, 630547919, 632342989, 637357363, 638865419, 648268013, 650007487, 651564761, 654115433, 661281713, 662664461, 667914281, 682988213, 691099121, 691445809, 692038043, 692411953, 698620943, 699007259, 701164631, 706806461, 707096251, 707697451, 709566589, 719095829, 725756807, 736880491, 739603867, 743026709, 744236861, 744396049, 747393791, 749395103, 760341121, 762934307, 773124059, 773195911, 776162609, 781629113, 781884613, 786120631, 788314343, 788898377, 788939293, 790209983, 791933183, 796328783, 798643889, 802280047, 803293991, 803847559, 809752739, 818520473, 820434047, 826810489, 829359959, 829707427, 836587463, 841011167, 843763253, 849410557, 851226437, 853058471, 853168793, 853778327, 859086391, 860720017, 863193077, 873061181, 888803059, 893035529, 900902953, 904636883, 917949577, 921817139, 922328707, 931449133, 933074827, 933156233, 935241721, 935632799, 939948881, 957119773, 961329913, 965269573, 965337949, 967551691, 971080093, 973578143, 976825877, 985100197, 985413691, 986124823, 990650057, 998244353, 999058883, 1000000007};
int ff(int a, int m)
{
    return (a % m + m) % m;
}
int Pow(int a, int b, int c)
{
    int ret = 1;
    while (b)
    {
        if (b &amp; 1)
            ret = ret * 1ll * a % c;
        a = a * 1ll * a % c;
        b &gt;&gt;= 1;
    }
    return ret;
}
int a, b, c, d, e, f, g;

bool check(int m)
{
    return ((Pow(ff(a, m), d, m) + Pow(ff(b, m), e, m)) % m + Pow(ff(c, m), f, m)) % m == ff(g, m);
}

int main()
{
    int T;
    cin &gt;&gt; T;
    while (T--)
    {
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f &gt;&gt; g;
        bool flag = 1;
        for (int i = 0; i &lt; 349; ++i)
        {
            if (!check(mod[i]))
            {
                flag = 0;
                break;
            }
        }
        puts(flag ? &quot;Yes&quot; : &quot;No&quot;);
    }
    return 0;
}
</code></pre><p>第三场。</p><h1>2020 牛客寒假算法基础集训营 4</h1><blockquote>搜索、简单 STL、前缀和、二分搜索、位运算、贪心、分治、树</blockquote><h2>4A. 欧几里得</h2><h3>大意</h3><p>给出了一个递归实现的 GCD 的代码，告诉你递归次数，求最开始的两个数，它们不相同且都是非负数，使这两个数的和最小。</p><h3>思路</h3><p>签到题。递归次数为 $0$ 次的时候肯定这两个是 $1$ 和 $0$。递归次数为 $1$ 次的时候则是 $2$ 和 $1$。假设说 $a$ 大于 $b$，其实就是已知 $b$ 和 $a\ mod\ b$，然后要让 $a$ 最小，那么就让 $\left \lfloor \frac{a}{b} \right \rfloor$ 最小。那就让它等于 $1$，可以很快发现是斐波那契数列。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main()
{
    int T;
    cin &gt;&gt; T;
    while (T--)
    {
        long long n;
        cin &gt;&gt; n;
        long long a[n + 10];
        a[0] = 1;
        a[1] = 2;
        for (int i = 2; i &lt; n + 7; i++)
        {
            a[i] = a[i - 1] + a[i - 2];
        }
        if (n == 0)
            cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;
        else
            cout &lt;&lt; a[n + 1] &lt;&lt; endl;
    }
    return 0;
}
</code></pre><h2>4B. 括号序列</h2><h3>大意</h3><p>给出一个仅包含 <code>[</code>、<code>]</code>、<code>(</code>、<code>)</code>、<code>{</code>、<code>}</code> 六种字符的括号序列，判断其是否合法。</p><h3>思路</h3><p>签到题。开一个栈来储存左括号，读到右括号看看栈顶的左括号和它匹不匹配。匹配就 POP 一个左括号。每时每刻都判断一下栈是不是空的。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main()
{
    string a;
    cin &gt;&gt; a;
    stack&lt;char&gt; b;
    for (int i = 0; i &lt; a.size(); i++)
    {
        // cout &lt;&lt; a[i];
        if (a[i] == '[')
            b.push('[');
        else if (a[i] == '{')
            b.push('{');
        else if (a[i] == '(')
            b.push('(');
 
 
        else if (a[i] == ']')
        {
            if (b.empty() || (! b.empty() &amp;&amp; b.top() != '['))
            {
                cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
                return 0;
            }
            else if (! b.empty())
                b.pop();
        }
        else if (a[i] == ')')
        {
            if (b.empty() || (! b.empty() &amp;&amp; b.top() != '('))
            {
                cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
                return 0;
            }
            else if (! b.empty())
                b.pop();
        }
        else if (a[i] == '}')
        {
            if (b.empty() || (! b.empty() &amp;&amp; b.top() != '{'))
            {
                cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
                return 0;
            }
            else if (! b.empty())
                b.pop();
        }
    }
    if (b.empty())
        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
    return 0;
}
</code></pre><h2>4C. 子段乘积</h2><h3>大意</h3><p>给出一个数列和一个数字 $k$，求其长度为 $k$ 的连续子段的乘积对 $998244353$ 取模余数的最大值。</p><h3>思路</h3><p>其实会乘法逆元的话就可以尺取了，可惜我刚开始做这题的时候不会，只好线段树了。反正期间也不用改动数字，懒标记什么的统统不要，把线段树建起来直接开始查询。</p><pre><code>#include &lt;bits/stdc++.h&gt;
 
using namespace std;
 
const int maxn = 200010;
 
int a[maxn + 2];
 
struct tree
{
    int l, r;
    long long pre, add;
} t[4 * maxn + 2];
 
void bulid(int p, int l, int r)
{
    t[p].l = l;
    t[p].r = r;
    if (l == r)
    {
        t[p].pre = a[l];
        return;
    }
    int mid = l + r &gt;&gt; 1;
    bulid(p * 2, l, mid);
    bulid(p * 2 + 1, mid + 1, r);
    t[p].pre = (t[p * 2].pre * t[p * 2 + 1].pre) % 998244353;
}
 
long long ask(int p, int x, int y)
{
    if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
        return t[p].pre;
    int mid = t[p].l + t[p].r &gt;&gt; 1;
    long long ans = 1;
    if (x &lt;= mid)
        ans = ans * ask(p * 2, x, y) % 998244353;
    if (y &gt; mid)
        ans = ans * ask(p * 2 + 1, x, y) % 998244353;
    return ans;
}
 
int main()
{
    int n, m;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; i++)
        scanf(&quot;%d&quot;, &amp;a[i]);
    bulid(1, 1, n);
    long long ans = -1;
    for (int i = 1; i + m - 1 &lt;= n; i++)
    {
        int x, y;
        ans = max(ans, ask(1, i, i + m - 1));
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h2>4D. 子段异或</h2><h3>大意</h3><p>给出一个数列，让你需要输出其中异或值为 $0$ 的不同连续子段的数量。</p><h3>思路</h3><p>首先用到了前缀和的思想，将前缀异或存进一个数组里。然后接合异或的性质：如果 $a\ xor\ b=c$，那么 $c\ xor\ a=b$，那么数组里任意两个数异或就是某一个区间的异或值，反正我们也不用关心这个区间从哪开始从哪结束，又因为 $a\ xor\ a=0$，我们给数组排下序，看看相邻两个数字是否相等就可以啦。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main()
{
    int n;
    cin &gt;&gt; n;
    long long a[n + 10];
    long long temp;
    cin &gt;&gt; temp;
    a[0] = temp;
    for (int i = 1; i &lt; n; i++)
    {
        cin &gt;&gt; temp;
        a[i] = a[i - 1] ^ temp;
    }
    sort(a, a + n);
    long long ans = 0, cnt = 1;
    for (int i = 0; i &lt; n; i++)
    {
        if (a[i] == 0)
            ans++;
        if (i != 0 &amp;&amp; a[i] == a[i - 1])
            cnt++;
        if (i != 0 &amp;&amp; (a[i] != a[i - 1] || i == n - 1))
        {
            ans += cnt * (cnt - 1) / 2;
            cnt = 1;
        }
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h2>4E. 最小表达式</h2><h3>大意</h3><p>给出一个字符串，里面只包含 $1$ 到 $9$ 还有加号。要求给出字符串的一个排列，使排列后是一个合法的算式而且算式的计算结果最小。</p><h3>思路</h3><p>贪心。加号的数字知道后就知道要有多少个数相加。然后我们将大的数字放在个位十位这种低位数，将小的数字放在高位数。然后是大数加法。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int cnt[20];
int sum[500050];

string s;
int main()
{
    cin &gt;&gt; s;
    int ccnt = 1;
    int n = s.size();
    for (int i = 0; i &lt; n; i++)
    {
        if (isdigit(s[i]))
        {
            cnt[s[i] - '0']++;
        }
        else
        {
            ccnt++;
        }
    }
    int p = 0, cp = 0;
    for (int i = 10; i &gt;= 1; i--)
    {
        while (cnt[i])
        {
            sum[cp] += i;
            cnt[i]--;
            p = (p + 1) % ccnt;
            if (p == 0)
                cp++;
        }
    }
    for (int i = 0; i &lt; 500010; i++)
    {
        sum[i + 1] += sum[i] / 10;
        sum[i] %= 10;
    }
    int opt = 0;
    for (int i = 500010; i &gt;= 0; i--)
    {
        if (opt || sum[i])
        {
            cout &lt;&lt; sum[i];
            opt = 1;
        }
    }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre><h2>4J. 二维跑步</h2><h3>完整题目</h3><p>一个点在平面直角坐标系中移动，初始位置 $(0,0)$，移动了 $n$ 次。从 $(i,0)$ 可以移动到 $(i+1,0)$、$(i+1,1)$、$(i+1,2)$、$(i,0)$、$(i-1,1)$、$(i-1,2)$，从 $(i,1)$ 可以移动到 $(i+1,0)$、$(i+1,1)$、$(i+1,2)$、$(i,1)$、$(i-1,0)$、$(i-1,2)$，从 $(i,2)$ 可以移动到 $(i+1,0)$、$(i+1,1)$、$(i+1,2)$、$(i,2)$、$(i-1,0)$、$(i-1,1)$。这里的 $(i,0)$ 移动到 $(i,0)$ 没有打错，而是不变换坐标的前提下消耗一个步数。已知 $n$ 和 $m$，数值均小于 $3 \cdot 10^6$，然后问你有多少种方式使得点的 $x$ 坐标最后落在 $[-m,m]$，答案对 $998244353$ 取模输出。</p><h3>思路</h3><h4>坐标等价</h4><p>理解题目在讲啥后，首先要做的是简化题目条件，你会发现这么多的坐标其中纵坐标只有三种，$0$、$1$ 和 $2$，当横坐标增加的时候（也就是从 $i$ 变成 $i+1$ 了，后面类似），无论初始位置的纵坐标是啥，能够到达的位置的纵坐标都是任意的。当横座标不变，纵坐标都是不变的。当横坐标减少的时候，无论初始位置的纵坐标是啥，能够到达的位置的纵坐标都只有两个可选而且都不等于初始位置的纵坐标。综上所述，我们发现纵坐标在这题是无关紧要的，横坐标相同的三个点是等价的。那么我们就可以将题目理解为：从 $x=i$ 的点到 $x=i+1$ 的点有三种方法，到 $x=i$ 的点有一种方法，到 $x=i-1$ 的点有两种方法。</p><h4>排列组合</h4><p>考虑到 $n$ 步下来本质还是左移、右移、不动三种方式的组合，只需设出三种方式分别的步数，用组合数公式即可。这里不妨设 $x$ 坐标不变的次数为 $i$，其中 $a$ 次 $x$ 坐标增加了，那么就会有 $n-i-a$ 次坐标减少。我们可以知道最后的坐标位置为 $x_{final}=a-(n-i-a)=2a-n+i$。为了让这个坐标处于 $[-m,m]$ 这个区间，我们要有：</p><p>$\left\{\begin{matrix} -m \leq 2a-n+i \leq m \ 0 \leq a \leq n-i \end{matrix}\right. $</p><p>由于 $a$ 还是一个整数，算出来的结果还需要上下取整：</p><p>$max(\left \lceil \frac{-m+n-i}{2} \right \rceil,0)\leq a \leq min(\left \lfloor \frac{m+n-i}{2} \right \rfloor,n-i)$</p><p>结合高中数学内容，我们知道 $i$ 次坐标不变，$a$ 次坐标增加的方案数一共是 $C _{n}^{i}(C _{n-i}^{a} \cdot 3^{a} \cdot 2^{n-i-a})$，我们进行求和操作，得出的结果是：</p><p>$ans = \sum_{i=0}^{n} \textrm{C} _{n}^{i}(\sum_{a=max(\left \lceil \frac{-m+n-i}{2} \right \rceil,0)}^{min(\left \lfloor \frac{m+n-i}{2} \right \rfloor,n-i)} \textrm{C} _{n-i}^{a} \cdot 3^{a} \cdot 2^{n-i-a}) $</p><h4>优化</h4><p>考虑到 $n$ 和 $m$ 的数据范围，直接进行计算肯定是不行，我们尝试将上面的式子拆为多部分。令：</p><p>$\left\{\begin{matrix}f(p,q)=C_p^q \cdot3^q \cdot 2^{p-q} \ L(i)=max(\left \lceil \frac{-m+n-i}{2} \right \rceil,0) \ R(i)=min(\left \lfloor \frac{m+n-i}{2} \right \rfloor,n-i) \ G(i)=\sum_{a=L(i)}^{R(i)}f(n-i,a) \ ans = \sum_{i=0}^{n}C_{n}^{i} G(i) \end{matrix}\right.$</p><p>在这些式子中，我们发现要缩短 $ans$ 的计算时间，就必须缩短 $G(i)$ 的计算时间。考虑到计算 $G(i)$ 时 $L(i)$ 和 $R(i)$ 都是一次性计算完成，但是 $f(p,q)$ 这样的式子我们要算上很多遍，我们我们就尝试优化 $f(p,q)$ 的计算。所谓优化很多时候就是预处理。我们看看对应的式子：组合数，得算阶乘吧，得算 $2$ 的 $p-q$ 次幂吧，得算 $3$ 的 $q$ 次幂吧，全部预处理掉。接下来就比较玄学了，考虑到我们除了要计算 $f(n-i,a)$，还要计算 $f(n-i-1,a)$、$f(n-i+1,a)$ 等等，因为恰好有 $C_p^q=C_{p-1}^{q}+C_{p-1}^{q-1}$ 这个公式，也就有了前项推后项的思路。我们尝试将 $2$ 和 $3$ 的指数和组合数匹配一下，得出 $f(p,q)=2f(p-1,q)+3f(p-1,q-1)$ 这样的式子。</p><p>接下来就不用再管 $f(p,q)$ 等于什么了，回到 $G(i)$ 这个层面。我们用上面的结论尝试展开上面的式子：</p><p>$G(i)=\sum_{a=L(i)}^{R(i)}f(n-i,a)$ <br>$=\sum_{a=L(i)}^{R(i)}(3f(n-(i+1),a-1)+2f(n-(i+1),a))$ <br>$=3f(n-(i+1),L(i)-1)+2f(n-(i+1),L(i))+3f(n-(i+1),L(i))+ \cdots +2f(n-(i+1),R(i)-1))+3f(n-(i+1),R(i)-1)+2f(n-(i+1),R(i))$ <br>$=5 \sum_{a=L(i)}^{R(i)-1}f(n-(i+1),a)+3f(n-(i+1),L(i)-1)+2f(n-(i+1),R(i))$</p><p>你会发现有一项是 $\sum_{a=L(i)}^{R(i)-1}f(n-(i+1),a)$，和 $G(i+1)$ 的形式很像，但是后者是 $\sum_{a=L(i+1)}^{R(i+1)}f(n-(i+1),a)$，还是有点区别。怎么办呢？就人为创造一个 $\sum_{a=L(i+1)}^{R(i+1)}f(n-(i+1),a)$ 呗。还是上面那个式子，我们把所有的 $L(i)$ 换成 $L(i+1)$，把 $R(i)-1$ 换成 $R(i+1)$，但这算出来就和 $G(i)$ 差了几个的 $f(n-i,a)$ 怎么办呢。先标记为 $\Delta$ 到后面再算呗。</p><p>$G(i)=\sum_{a=L(i+1)}^{R(i+1)+1}f(n-i,a)+\Delta$ <br>$=\sum_{a=L(i+1)}^{R(i+1)+1}(3f(n-(i+1),a-1)+2f(n-(i+1),a))+\Delta$ <br>$=3f(n-(i+1),L(i+1)-1)+2f(n-(i+1),L(i+1))+3f(n-(i+1),L(i+1))+ \cdots +2f(n-(i+1),R(i+1)))+3f(n-(i+1),R(i+1))+2f(n-(i+1),R(i+1)+1)+\Delta$ <br>$=5 \sum_{a=L(i+1)}^{R(i+1)}f(n-(i+1),a)+3f(n-(i+1),L(i+1)-1)+2f(n-(i+1),R(i+1)+1)+\Delta$ <br>$=5G(i+1)+3f(n-(i+1),L(i+1)-1)+2f(n-(i+1),R(i+1)+1)+\Delta$</p><h4>代码实现</h4><p>在式子乘个 <code>1ll</code> 可以有效避免溢出的问题。计算高次幂为了避免溢出，在写快速幂的时候也要每步取模。计算组合数的时候需要用到除以比较大的数，还是为了避免溢出这时候也是要取模的。于是就打开了乘法逆元的新世界，道理其实也不是很懂，大概就是如果有一个素数 $p$，根据费马小定理则有 $a^{p-1}\equiv1(mod\;p)$，那么 ${a}\cdot a^{p-2}\equiv1(mod\;p)$，$a^{p-2}$ 就叫 $a\ mod\ p$ 意义下的逆元，照用就是了。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
const int mod = 998244353;
const int N = 3000010;
int n, m, f2[N], f3[N], q[N], p[N], G[N];
 

//////// 快速幂 ////////
int qpow(int a, int b) {
    int ans = 1;
    a %= mod;
    for (; b; b &gt;&gt;= 1) {
        if (b &amp; 1) ans = 1ll * ans * a % mod;
        a = 1ll * a * a % mod;
    }
    return ans;
}

//////// 组合数 ////////
int c(int a, int b) { return 1ll * q[a] * p[b] % mod * p[a - b] % mod; }

//////// 算 f(a,b) ////////
int f(int a, int b) { return 1ll * c(a, b) * f3[b] % mod * f2[a - b] % mod; }

int main() {
    cin &gt;&gt; n &gt;&gt; m;
    f2[0] = f3[0] = q[0] = 1;
    for (int i = 1; i &lt;= n; i++) {
        // 算 i!，2 的 i 次方，3 的 i 次方，对 mod 取模
        q[i] = 1ll * q[i - 1] * i % mod;
        f2[i] = 1ll * f2[i - 1] * 2 % mod;
        f3[i] = 1ll * f3[i - 1] * 3 % mod;
    }

    // 乘法逆元
    p[n] = qpow(q[n], mod - 2);
    for (int i = n - 1; i &gt;= 0; i--) p[i] = 1ll * p[i + 1] * (i + 1) % mod;

    //////// 算 G(i) ////////
    int l = 0, r = 1; G[n] = 1;
    for (int i = n - 1; i &gt;= 0; i--, r++) {

        // 算 5 * G(i + 1) + 3 * f(...) + 5 * f(...)
        G[i] = (5ll * G[i + 1] % mod + 3ll * f(n - i - 1, l - 1) % mod + 2ll * f(n - i - 1, r) % mod) % mod;
        int ql = max((n - i - m + 1) / 2, 0), qr = min((n - i + m) / 2, n - i);
        // 此时 l = L(i + 1), r = R(i + 1) + 1
        // 此时 ql = L(i), qr = R(i)
        
        // 算 delta
        while (l &lt; ql) G[i] = (1ll * G[i] - f(n - i, l) + mod) % mod, l++;
        while (l &gt; ql) l--, G[i] = (1ll * G[i] + f(n - i, l)) % mod;
        while (r &gt; qr) G[i] = (1ll * G[i] - f(n - i, r) + mod) % mod, r--;
        while (r &lt; qr) r++, G[i] = (1ll * G[i] + f(n - i, r)) % mod;
        // 此时 l = L(i), r = R(i)
        // 此时 i--, r++
    }

    //////// 算答案 ////////
    int ans = 0;
    for (int i = n; i &gt;= 0; i--) ans = (ans + 1ll * G[i] * c(n, i) % mod) % mod;
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h1>2020 牛客寒假算法基础集训营 5</h1><blockquote>字符串、二分、哈希、DP、模拟、搜索、数学</blockquote><h2>5A. 模板</h2><h3>大意</h3><p>给出两个字符串，允许对其中一个字符串做任意的替换、删除最后一位、在末尾添加一个字母。问最少的步数，使两个字符串相同。</p><h3>思路</h3><p>签到题。逐个位置匹配，发现不一样则步数加一。当长度较短的字符串匹配完后再加上两个字符串的长度差。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    string a, b;
    cin &gt;&gt; a &gt;&gt; b;
    if (n &lt; m)
    {
        swap(n, m);
        swap(a, b);
    }
    int ans = 0;
 
    for (int i = 0; i &lt; m; i++)
    {
        if (a[i] != b[i])
            ans++;
    }
    ans += n - m;
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h2>5B. 牛牛战队的比赛地</h2><h3>大意</h3><p>已知多个点的坐标，问平面上哪个位置满足到这些点的距离的最大值最小。</p><h3>思路</h3><p>三分答案。大概是因为它是二次函数，每次使用三分都能排除最差的一部分答案。二分答案似乎也是可以的，但二分的依据是单调性，二次函数也没法保证这一点，所以做起来似乎要麻烦很多。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

struct p
{
    int x, y;
} a[100005];
int n;
double check(double x)
{
    double max = 0;
    for (int i = 0; i &lt; n; i++)
    {
        double tmp = sqrt(a[i].y * a[i].y + (a[i].x - x) * (a[i].x - x));
        if (tmp &gt; max)
            max = tmp;
    }
    return max;
}
double tsearch(double left, double right)
{
    int i;
    double mid, midmid;
    for (i = 0; i &lt; 100; i++)
    {
        mid = left + (right - left) / 2;
        midmid = mid + (right - mid) / 2;
        if (check(mid) &gt; check(midmid))
            left = mid;
        else
            right = midmid;
    }
    return mid;
}
int main()
{
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++)
        cin &gt;&gt; a[i].x &gt;&gt; a[i].y;
    double max = tsearch(-10000, 10000);
    cout &lt;&lt; check(max) &lt;&lt; endl;
    return 0;
}
</code></pre><h2>5C. C 语言 IDE</h2><h3>大意</h3><p>输入一份 C 语言代码，要求输出代码中出现的函数。</p><h3>思路</h3><p>哦，是码农大模拟！爱了爱了。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

string source;
void replaceAll(string &amp;s, string oldstr, string newstr)
{
    for (string::size_type pos = 0; pos != string::npos; pos += newstr.length())
        if ((pos = s.find(oldstr, pos)) != string::npos)
            s.replace(pos, oldstr.length(), newstr);
        else
            break;
}
struct functions
{
    string inClass, name, outputType;
    vector&lt;string&gt; inputType;
    functions(string inClass = &quot;&quot;, string name = &quot;&quot;, string outputType = &quot;void&quot;, vector&lt;string&gt; inputType = vector&lt;string&gt;(0))
        : inClass(inClass), name(name), outputType(outputType), inputType(inputType) {}
};
vector&lt;functions&gt; funs;
void solve(string &amp;s)
{
    replaceAll(s, &quot;/*&quot;, &quot; /* &quot;);
    replaceAll(s, &quot;*/&quot;, &quot; */ &quot;);
    replaceAll(s, &quot;//&quot;, &quot; // &quot;);
    replaceAll(s, &quot;(&quot;, &quot; ( &quot;);
    replaceAll(s, &quot;)&quot;, &quot; ) &quot;);
    replaceAll(s, &quot;{&quot;, &quot; { &quot;);
    replaceAll(s, &quot;}&quot;, &quot; } &quot;);
    replaceAll(s, &quot;=&quot;, &quot; = &quot;);
    replaceAll(s, &quot;\&quot;&quot;, &quot; \&quot; &quot;);
    replaceAll(s, &quot;'&quot;, &quot; ' &quot;);
    replaceAll(s, &quot;;&quot;, &quot; ; &quot;);
    replaceAll(s, &quot;,&quot;, &quot; , &quot;);
    replaceAll(s, &quot;+ = &quot;, &quot;+=&quot;);
    replaceAll(s, &quot;- = &quot;, &quot;-=&quot;);
    replaceAll(s, &quot;* = &quot;, &quot;*=&quot;);
    replaceAll(s, &quot;/ = &quot;, &quot;/=&quot;);
    replaceAll(s, &quot;^ = &quot;, &quot;^=&quot;);
    replaceAll(s, &quot;| = &quot;, &quot;|=&quot;);
    replaceAll(s, &quot;&amp; = &quot;, &quot;&amp;=&quot;);
    replaceAll(s, &quot;:&quot;, &quot; : &quot;);
    replaceAll(s, &quot; :  : &quot;, &quot;::&quot;);
    vector&lt;string&gt; tokens;
    string now = &quot;&quot;;
    for (int i = 0; s[i]; i++)
    {
        if (s[i] == ' ' || s[i] == '\t' || s[i] == '\r' || s[i] == '\n' || s[i] == '\0')
        {
            if (now != &quot;&quot;)
            {
                if (now == &quot;:&quot; &amp;&amp; tokens.back() == &quot;)&quot;)
                {
                    string tmpnow = &quot;&quot;;
                    for (int j = i + 1; s[j]; j++)
                    {
                        if (s[j] == ' ' || s[j] == '\t' || s[j] == '\r' || s[j] == '\n' || s[j] == '\0')
                        {
                            if (tmpnow == &quot;{&quot;)
                            {
                                now = &quot;{&quot;;
                                i = j - 1;
                                break;
                            }
                            tmpnow = &quot;&quot;;
                        }
                        else
                            tmpnow += s[j];
                    }
                    continue;
                }
                if (now == &quot;const&quot;)
                {
                    now = &quot;&quot;;
                    continue;
                }
                if (now == &quot;//&quot;)
                {
                    for (int j = i; s[j]; j++)
                    {
                        if (s[j] == '\n')
                        {
                            i = j - 1;
                            break;
                        }
                    }
                    now = &quot;&quot;;
                    continue;
                }
                if (now == &quot;/*&quot;)
                {
                    int num = 1;
                    string tmpnow = &quot;&quot;;
                    for (int j = i + 1; s[j]; j++)
                    {
                        if (s[j] == ' ' || s[j] == '\t' || s[j] == '\r' || s[j] == '\n' || s[j] == '\0')
                        {
                            if (tmpnow == &quot;/*&quot;)
                                num++;
                            if (tmpnow == &quot;*/&quot;)
                            {
                                num--;
                                if (num == 0)
                                {
                                    i = j - 1;
                                    break;
                                }
                            }
                            tmpnow = &quot;&quot;;
                        }
                        else
                            tmpnow += s[j];
                    }
                    now = &quot;&quot;;
                    continue;
                }
                tokens.push_back(now);
                now = &quot;&quot;;
            }
        }
        else
            now += s[i];
    }
    int cnt = 0;
    string nowNamespace = &quot;&quot;;
    for (int i = 1; i &lt; (int)tokens.size(); i++)
    {
        if ((tokens[i] == &quot;struct&quot; || tokens[i] == &quot;class&quot;) &amp;&amp; tokens[i + 2] == &quot;{&quot;)
        {
            cnt = 0;
            nowNamespace = tokens[i + 1];
            i += 2;
        }
        functions tmp(nowNamespace);
        if (tokens[i] == &quot;{&quot; &amp;&amp; tokens[i - 1] == &quot;)&quot;)
        {
            int num = 1;
            for (int j = i - 2; j &gt;= 0; j--)
            {
                if (tokens[j] == &quot;)&quot;)
                    num++;
                if (tokens[j] == &quot;(&quot;)
                {
                    num--;
                    if (num == 0)
                    {
                        tmp.name = tokens[j - 1];
                        tmp.outputType = &quot;&quot;;
                        for (int k = j - 2; k &gt;= 0; k--)
                            if (tokens[k] != &quot;}&quot; &amp;&amp; tokens[k] != &quot;}&quot; &amp;&amp; tokens[k] != &quot;;&quot; &amp;&amp;
                                tokens[k].back() != ':' &amp;&amp; tokens[k] != &quot;inline&quot; &amp;&amp;
                                tokens[k] != &quot;static&quot; &amp;&amp; tokens[k][0] != '#' &amp;&amp;
                                tokens[k].back() != '\&quot;' &amp;&amp; tokens[k].back() != '&gt;')
                                tmp.outputType = tmp.outputType == &quot;&quot; ? tokens[k] : tokens[k] + &quot; &quot; + tmp.outputType;
                            else
                                break;
                        int last = i - 2;
                        for (int k = i - 2; k &gt;= j; k--)
                        {
                            if (tokens[k] == &quot;(&quot; || tokens[k] == &quot;,&quot;)
                            {
                                string tt = &quot;&quot;;
                                for (int t = k + 1; t &lt; last; t++)
                                    tt = tt == &quot;&quot; ? tokens[t] : tt + &quot; &quot; + tokens[t];
                                if (tt != &quot;&quot;)
                                    tmp.inputType.push_back(tt);
                                last = k - 1;
                            }
                            if (tokens[k] == &quot;=&quot; || tokens[k] == &quot;)&quot;)
                                last = k - 1;
                        }
                        reverse(tmp.inputType.begin(), tmp.inputType.end());
                        break;
                    }
                }
            }
            funs.push_back(tmp);
            num = 1;
            for (int j = i + 1; j &lt; (int)tokens.size(); j++)
            {
                if (tokens[j] == &quot;{&quot;)
                    num++;
                if (tokens[j] == &quot;}&quot;)
                {
                    num--;
                    if (num == 0)
                    {
                        i = j;
                        break;
                    }
                }
            }
            continue;
        }
        if (nowNamespace != &quot;&quot;)
        {
            if (tokens[i] == &quot;{&quot;)
                cnt++;
            if (tokens[i] == &quot;}&quot;)
            {
                cnt--;
                if (!cnt)
                    nowNamespace = &quot;&quot;;
            }
        }
    }
}
int main()
{
    char ch;
    while ((ch = getchar()) != EOF)
        source += ch;
    solve(source);
    for (auto &amp;i : funs)
    {
        if (i.outputType != &quot;&quot;)
            cout &lt;&lt; i.outputType &lt;&lt; &quot; &quot;;
        if (i.inClass != &quot;&quot;)
            cout &lt;&lt; i.inClass &lt;&lt; &quot;::&quot;;
        cout &lt;&lt; i.name &lt;&lt; &quot;(&quot;;
        for (int j = 0; j &lt; (int)i.inputType.size(); j++)
            cout &lt;&lt; i.inputType[j] &lt;&lt; (j == (int)i.inputType.size() - 1 ? &quot;)&quot; : &quot;,&quot;);
        if ((int)i.inputType.size() == 0)
            cout &lt;&lt; &quot;)&quot;;
        cout &lt;&lt; endl;
    }
    return 0;
}
</code></pre><h2>5E. Enjoy the Game</h2><h3>大意</h3><p>给出一个规则：$n$ 张卡牌，先手第一步最少拿 $1$ 张，最多拿 $n-1$ 张。接下来每一步，双方最少要拿 $1$ 张，最多拿等同于上一步对方拿的牌数的牌。拿走最后一张牌胜。问对不同的 $n$，先手是否有必胜策略。</p><h3>思路</h3><p>找规律找出来的，只要是二的幂就是 Alice 胜，否则就是 Bob 胜。这题好像把 <code>__builtin_popcount(n)</code> 给卡了，原因不明，反正下次是不敢用了。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
long long lowbit(long long x)
{
    return x&amp;(-x);
}
   
int main()
{
    long long n;
    cin &gt;&gt; n;
    if (lowbit(n) == n)
    {
        cout &lt;&lt; &quot;Alice&quot; &lt;&lt; endl;
        return 0;
    }
    cout &lt;&lt; &quot;Bob&quot; &lt;&lt; endl;
    return 0;
}
</code></pre><h2>5H. Hash</h2><h3>大意</h3><p>给出一个字符串和一个 Hash 函数（核心代码 <code>res = (res * 26 + str[i] - 'a') % mod;</code>），求一个字典序最小且大于该字符串且有着相同 Hash 的字符串。</p><h3>思路</h3><p>其实就是把字符串转成了二十六进制数，然后给它取模。那么要想 Hash 值相同字典序还要大于原字符串，就直接给这个二十六进制数加上模数就好了。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main()
{
    string a;
    int m;
    int ta[6];
    while (cin &gt;&gt; a &gt;&gt; m)
    {
        int org[6], backup[6];
        for (int i = 0; i &lt; 6; i++)
        {
            org[i] = a[i] - 'a';
            backup[i] = org[i];
        }
        string b = a;
        for (int i = 5; i &gt;= 0; i--)
        {
            ta[i] = m % 26;
            m /= 26;
        }
        if (m != 0)
        {
            cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;
        }
        for (int i = 5; i &gt; 0; i--)
        {
            org[i] += ta[i];
            if (org[i] &gt; 25)
            {
                org[i] -= 26;
                org[i - 1]++;
            }
        }
        org[0] += ta[0];
        if (org[0] &lt; 26)
        {
            for (int i = 0; i &lt; 6; i++)
            {
                printf(&quot;%c&quot;, org[i] + 'a');
            }
            cout &lt;&lt; endl;
            continue;
        }
        else
        {
            cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;
            continue;
        }
    }
 
    return 0;
}
</code></pre><h2>5I. I 题是个签到题</h2><h3>大意</h3><p>给出一场比赛参赛人数和各题过题人数，通过人数不低于全场人数的 $80\%$ 或在所有题目中前三多就叫签到题。问 I 题是不是签到题。</p><h3>思路</h3><p>签到题。排序即可，关键是要处理并列的情况。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
struct temp
{
    int num;
    int ac;
} a[20000];
 
bool cmp(temp a, temp b)
{
    return a.ac &gt; b.ac;
}
 
int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 0; i &lt; n; i++)
    {
        cin &gt;&gt; a[i].ac;
        a[i].num = i;
    }
    if (a[8].ac * 10 &gt;= m * 8)
    {
        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
        return 0;
    }
    sort(a, a + n, cmp);
    int cnt = 1;
    int cur = 1;
    if (a[0].num == 8)
    {
        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
        return 0;
    }
    for (int i = 1; i &lt; n; i++)
    {
        if (a[i].ac != a[i - 1].ac)
        {
            cnt += cur;
            cur = 1;
        }
        else
        {
            cur++;
        }
        if (a[i].num == 8 &amp;&amp; cnt &lt;= 3)
        {
            cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
            return 0;
        }
        if (cnt &gt; 3)
        {
            cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
            return 0;
        }
    }
}
</code></pre><h2>5J. 牛牛战队的秀场</h2><h3>大意</h3><p>求圆内接正 $n$ 边形的边长。</p><h3>思路</h3><p>签到。可以很容易地计算每条弦对应的圆心角的大小，然后三角函数。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
#define PI 3.1415926535898
 
int main()
{
    double n, r, i, j;
    cin &gt;&gt; n &gt;&gt; r &gt;&gt; i &gt;&gt; j;
    if (i == j)
    {
        cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;
        return 0;
    }
    if (i &gt; j)
        swap(i, j);
    double ans = min(j - i, i - j + n);
    printf(&quot;%.8lf\n&quot;, ans * 2 * r * sin(360 / n / 2 * PI / 180));
    return 0;
}
</code></pre><h1>2020 牛客寒假算法基础集训营 6</h1><blockquote>贪心、图论、构造、二分、计数、数论、思维</blockquote><h2>6A. 配对</h2><h3>大意</h3><p>给出两个集合，每个集合里有 $N$ 个数，不同集合的两个数配对并求和，要求最大化第 $K$ 大的和。</p><h3>思路</h3><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
typedef long long ll;
 
int main()
{
    ll n, k;
    cin &gt;&gt; n &gt;&gt; k;
    ll a[n], b[n], c[n];
    for (ll i = 0; i &lt; n; i++)
    {
        cin &gt;&gt; a[i];
    }
    for (ll i = 0; i &lt; n; i++)
    {
        cin &gt;&gt; b[i];
    }
    sort(a, a + n);
    sort(b, b + n);
    for (int i = 0; i &lt; k; i++)
    {
        c[i] = a[n - 1 - i] + b[n - k + i];
    }
    sort(c, c + k);
    cout &lt;&lt; c[0] &lt;&lt; endl;
    return 0;
}
</code></pre><h2>B.</h2>
</div>
</div>
<script data-cfasync="false" src="../../../../cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script type="af8c7cddc53fcd57c335e7ed-text/javascript">
        try {
            $("[data-morphing]").fancyMorph({
                hash : 'morphing'
            });
        }catch (e){

        }

            </script>

<script type="af8c7cddc53fcd57c335e7ed-text/javascript">
(function () {
    window.TypechoComment = {
        dom : function (id) {
            return document.getElementById(id);
        },
    
        create : function (tag, attr) {
            var el = document.createElement(tag);
        
            for (var key in attr) {
                el.setAttribute(key, attr[key]);
            }
        
            return el;
        },

        reply : function (cid, coid) {
            var comment = this.dom(cid), parent = comment.parentNode,
                response = this.dom('respond-post-72'), input = this.dom('comment-parent'),
                form = 'form' == response.tagName ? response : response.getElementsByTagName('form')[0],
                textarea = response.getElementsByTagName('textarea')[0];

            if (null == input) {
                input = this.create('input', {
                    'type' : 'hidden',
                    'name' : 'parent',
                    'id'   : 'comment-parent'
                });

                form.appendChild(input);
            }

            input.setAttribute('value', coid);

            if (null == this.dom('comment-form-place-holder')) {
                var holder = this.create('div', {
                    'id' : 'comment-form-place-holder'
                });

                response.parentNode.insertBefore(holder, response);
            }

            comment.appendChild(response);
            this.dom('cancel-comment-reply-link').style.display = '';

            if (null != textarea && 'text' == textarea.name) {
                textarea.focus();
            }

            return false;
        },

        cancelReply : function () {
            var response = this.dom('respond-post-72'),
            holder = this.dom('comment-form-place-holder'), input = this.dom('comment-parent');

            if (null != input) {
                input.parentNode.removeChild(input);
            }

            if (null == holder) {
                return true;
            }

            this.dom('cancel-comment-reply-link').style.display = 'none';
            holder.parentNode.insertBefore(response, holder);
            return false;
        }
    };
})();
</script>
<script type="af8c7cddc53fcd57c335e7ed-text/javascript">
var registCommentEvent = function() {
    var event = document.addEventListener ? {
        add: 'addEventListener',
        focus: 'focus',
        load: 'DOMContentLoaded'
    } : {
        add: 'attachEvent',
        focus: 'onfocus',
        load: 'onload'
    };
    var r = document.getElementById('respond-post-72');
        
    if (null != r) {
        var forms = r.getElementsByTagName('form');
        if (forms.length > 0) {
            var f = forms[0], textarea = f.getElementsByTagName('textarea')[0], added = false;

            if (null != textarea && 'text' == textarea.name) {
                textarea[event.add](event.focus, function () {
                    if (!added) {
                        var input = document.createElement('input');
                        input.type = 'hidden';
                        input.name = '_';
                            input.value = (function () {
    var _3Ajk4D1 = ''///*'o'*/'o'
+/* 'LC5'//'LC5' */''+'Y'//'Y'
+//'n'
'e64'+//'R'
'2f'+'35'//'f6Q'
+//'L1'
'42'+'5f4'//'H7'
+//'yd'
'yd'+//'z'
'2d'+//'X3'
'a98'+'3'//'cY'
+//'g'
'c5'+'9'//'N'
+//'pd4'
'20e'+//'56'
'c'+//'Z'
'38e'+'97'//'l'
+//'jG'
'5'+/* 'xv9'//'xv9' */''+/* 'er'//'er' */''+'c'//'Le6'
, _voXjNY = [[0,1],[12,14]];
    
    for (var i = 0; i < _voXjNY.length; i ++) {
        _3Ajk4D1 = _3Ajk4D1.substring(0, _voXjNY[i][0]) + _3Ajk4D1.substring(_voXjNY[i][1]);
    }

    return _3Ajk4D1;
})();
                    
                        f.appendChild(input);
                        
                        input = document.createElement('input');
                        input.type = 'hidden';
                        input.name = 'checkReferer';
                        input.value = 'false';
                        
                        f.appendChild(input);
                        

                        added = true;
                    }
                });
            }
        }
    }
};
</script></div>
<footer id="footer" class="app-footer" role="footer">
<div class="wrapper bg-light">
<span class="pull-right hidden-xs text-ellipsis">
Powered by <a target="_blank" href="http://www.typecho.org">Typecho</a>&nbsp;|&nbsp;Theme by <a target="_blank" href="https://www.ihewro.com/archives/489/">handsome</a>
</span>
<span class="text-ellipsis">&copy;&nbsp;2020 Copyright&nbsp;</span>
</div>

<style>
          .topButton>.btn{
              top: 0;
          }
          </style>
<div class="topButton panel panel-default">
<button id="goToTop" class="btn btn-default no-shadow pos-abt hide  border-radius-half-left" data-toggle="tooltip" data-placement="left" data-original-title="返回顶部">
<i class="fontello fontello-chevron-circle-up" aria-hidden="true"></i>
</button>
</div>
</footer>
</div>
<script type="af8c7cddc53fcd57c335e7ed-text/javascript">
SearchConfig = {
    url : "https://static.bobby285271.top/usr/plugins/Handsome/cache/search.json"
}
</script>

<script type="af8c7cddc53fcd57c335e7ed-text/javascript">
        window['LocalConst'] = {
            COMMENT_NAME_INFO: '必须填写昵称或姓名',
            COMMENT_EMAIL_INFO: '必须填写电子邮箱地址',
            COMMENT_EMAIL_LEGAL_INFO: '邮箱地址不合法',
            COMMENT_CONTENT_INFO: '必须填写评论内容',
            COMMENT_SUBMIT_ERROR: '提交失败，请重试！',
            COMMENT_CONTENT_LEGAL_INFO: '提交失败,评论被拦截，可能发言太快或内容不符合规则',

            LOGIN_USERNAME_INFO: '必须填写用户名',
            LOGIN_PASSWORD_INFO: '请填写密码',
            LOGIN_SUBMIT_ERROR: '登录失败，请重新登录',
            LOGIN_SUBMIT_INFO: '用户名或者密码错误，请重试',
            LOGIN_SUBMIT_SUCCESS: '登录成功',
            CLICK_TO_REFRESH: '点击以刷新页面',
            LOGOUT_SUCCESS_REFRESH: '退出成功，正在刷新当前页面',

            LOGOUT_ERROR: '退出失败，请重试',
            LOGOUT_SUCCESS: '退出成功',

            SUBMIT_PASSWORD_INFO: '密码错误，请重试',
            COMMENT_TITLE: '评论通知',
            LOGIN_TITLE: '登录通知',
            ChANGYAN_APP_KEY: '',
            CHANGYAN_CONF: '',

            COMMENT_SYSTEM: '0',
            COMMENT_SYSTEM_ROOT: '0',
            COMMENT_SYSTEM_CHANGYAN: '1',
            COMMENT_SYSTEM_OTHERS: '2',
            EMOJI: '表情',
            IS_PJAX: '1',
            IS_PAJX_COMMENT: '1',
            BASE_SCRIPT_URL: 'https://static.bobby285271.top/usr/themes/handsome/',
            BLOG_URL: 'https://static.bobby285271.top/',
            BLOG_URL_PHP: 'https://static.bobby285271.top/index.php/',
            THEME_COLOR: '14',
            THEME_COLOR_EDIT: 'white-white-white',
            THEME_HEADER_FIX: '1',
            THEME_ASIDE_FIX: '1',
            THEME_ASIDE_FOLDED: '',
            THEME_ASIDE_DOCK: '',
            THEME_CONTAINER_BOX: '1',
            THEME_HIGHLIGHT_CODE: '1',
            THEME_TOC: '1',
            TOC_TITLE: '文章目录',
            HEADER_FIX: '固定头部',
            ASIDE_FIX: '固定导航',
            ASIDE_FOLDED: '折叠导航',
            ASIDE_DOCK: '置顶导航',
            CONTAINER_BOX: '盒子模型',
            OFF_SCROLL_HEIGHT: '50',
            COMMENT_REJECT_PLACEHOLDER: '居然什么也不说，哼',
            COMMENT_PLACEHOLDER: '说点什么吧……',
            SHOW_SETTING_BUTTON: '',
            THEME_VERSION: '6.0.020191205',

            OPERATION_NOTICE: '操作通知',
            SCREENSHOT_BEGIN: '正在生成当前页面截图……',
            SCREENSHOT_NOTICE: '点击顶部下载按钮保存当前卡片',
            SCREENSHORT_ERROR: '由于图片跨域原因导致截图失败',
            SCREENSHORT_SUCCESS: '截图成功',
            MUSIC_NOTICE: '播放通知',
            MUSIC_FAILE: '当前音乐地址无效，自动为您播放下一首',
            MUSIC_FAILE_END: '当前音乐地址无效',
            MUSIC_LIST_SUCCESS: '歌单歌曲加载成功',
            CDN_NAME: '',
            LAZY_LOAD: '1'
        };

    </script>

<script src="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js" type="af8c7cddc53fcd57c335e7ed-text/javascript"></script>
<script src="../../../../usr/themes/handsome/assets/js/features/jquery.pjax.min.js" type="af8c7cddc53fcd57c335e7ed-text/javascript"></script>
<script type="af8c7cddc53fcd57c335e7ed-text/javascript">
        $(document).pjax('a[href^="https://static.bobby285271.top/"]:not(a[target="_blank"], a[no-pjax])', {
            container: '#content',
            fragment: '#content',
            timeout: 8000
        }).on('pjax:send',function () {
                        $('#loading').removeClass('hide');
                    }).on('pjax:click', function() {

            window['Page'].doPJAXClickAction();
            
                        $('body,html').animate({scrollTop:0},100);
            

        }).on('pjax:complete', function() {
            window['Page'].doPJAXCompleteAction();
            if ($(".post-position").length > 0){
                window['Page'].doPJAXCompletePostAction();
            }
                                            $("#post-content img").lazyload({
                    effect: "fadeIn",
                    threshold: "200"
                });
                $(".lazy").lazyload({
                    effect: "fadeIn",
                    threshold: "200"
                });
                                                    $('#loading').addClass('hide');
            
                                    MathJax.Hub.Queue(["Typeset",MathJax.Hub,"body"]);
            

        })
    </script>


<script src="../../../../usr/themes/handsome/assets/js/features/lazyload.min.js" type="af8c7cddc53fcd57c335e7ed-text/javascript"></script>
<script type="af8c7cddc53fcd57c335e7ed-text/javascript">
        $("img").lazyload({
            effect: "fadeIn",
            threshold: "200"
        });

        $(".lazy").lazyload({
            effect: "fadeIn",
            threshold: "200"
        });

        //后退的时候
        if (window.history && window.history.pushState) {
            $(window).on('popstate', function () {
                /// 当点击浏览器的 后退和前进按钮 时才会被触发，
                window.history.pushState('forward', null, '');
                window.history.forward(1);//当前页 ,
                $("img").lazyload({
                    effect: "fadeIn",
                    threshold: "200"
                });

                $(".lazy").lazyload({
                    effect: "fadeIn",
                    threshold: "200"
                });
            });
        }
        //在ie中必须有这两行
        window.history.pushState('forward', null, '');
        window.history.forward(1);
    </script>
<script src="../../../../usr/themes/handsome/assets/js/features/feather.min.js%3Fv=6.0.020191205" type="af8c7cddc53fcd57c335e7ed-text/javascript"></script>

<script src="https://cdn.staticfile.org/mathjax/2.7.0/MathJax.js" type="af8c7cddc53fcd57c335e7ed-text/javascript"></script>
<script src="https://cdn.staticfile.org/mathjax/2.7.0/config/TeX-AMS-MML_SVG.js" type="af8c7cddc53fcd57c335e7ed-text/javascript"></script>

<script src="../../../../usr/themes/handsome/assets/js/features/jquery.fancybox.min.js%3Fv=6.0.020191205" type="af8c7cddc53fcd57c335e7ed-text/javascript"></script>
<script src="../../../../usr/themes/handsome/assets/js/features/easypiechart.min.js%3Fv=6.0.020191205" type="af8c7cddc53fcd57c335e7ed-text/javascript"></script>

<script src="../../../../usr/themes/handsome/assets/js/features/OwO.min.js%3Fv=6.0.020191205" type="af8c7cddc53fcd57c335e7ed-text/javascript"></script>



<script src="../../../../usr/themes/handsome/assets/js/function.min.js%3Fv=6.0.020191205" type="af8c7cddc53fcd57c335e7ed-text/javascript"></script>
<script src="../../../../usr/themes/handsome/assets/js/core.min.js%3Fv=6.0.020191205" type="af8c7cddc53fcd57c335e7ed-text/javascript"></script>
<script type="af8c7cddc53fcd57c335e7ed-text/javascript">
            </script>
<script src="https://ajax.cloudflare.com/cdn-cgi/scripts/7089c43e/cloudflare-static/rocket-loader.min.js" data-cf-settings="af8c7cddc53fcd57c335e7ed-|49" defer=""></script></body>
</html>

