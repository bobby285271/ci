<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
xmlns:content="http://purl.org/rss/1.0/modules/content/"
xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
xmlns:atom="http://www.w3.org/2005/Atom"
xmlns:wfw="http://wellformedweb.org/CommentAPI/">
<channel>
<title>Dasyatis - Algorithm</title>
<link>https://static.bobby285271.top/index.php/tag/Algorithm/</link>
<atom:link href="https://static.bobby285271.top/index.php/feed/tag/Algorithm/" rel="self" type="application/rss+xml" />
<language>zh-CN</language>
<description></description>
<lastBuildDate>Sat, 08 Feb 2020 16:00:00 +0000</lastBuildDate>
<pubDate>Sat, 08 Feb 2020 16:00:00 +0000</pubDate>
<item>
<title>2020 Nowcoder Basic Algorithm Training Camp Solutions</title>
<link>https://static.bobby285271.top/index.php/2020/02/09/2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html</link>
<guid>https://static.bobby285271.top/index.php/2020/02/09/2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html</guid>
<pubDate>Sat, 08 Feb 2020 16:00:00 +0000</pubDate>
<dc:creator>bobby285271</dc:creator>
<description><![CDATA[颓废了一个寒假，Codeforces 打来打去都是 Specialist，菜的一批。POJ 又刷到怀疑人生。后来被 Kaidora 神犇安排了这个集训营。当时已经是第四场要开始了，还是去了。果然...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>颓废了一个寒假，Codeforces 打来打去都是 Specialist，菜的一批。POJ 又刷到怀疑人生。后来被 Kaidora 神犇安排了这个集训营。当时已经是第四场要开始了，还是去了。果然，哪怕都是自闭五小时每小时过一题，氪了金感觉就是不一样。</p><p>点击下方的页码查看相应场次的记录，第 $i$ 页对应的是第 $i-1$ 场比赛。</p><h1>2020 牛客寒假算法基础集训营 1</h1><blockquote>字符串、贪心、矩阵快速幂、概率论、计算几何、并查集、数论</blockquote><h2>1A. Honoka 和格点三角形</h2><h3>大意</h3><p>给出 $m \times n$ 格点矩阵，问在矩阵里面能找出多少个面积为 $1$，且至少有一条边平行于 $x$ 轴或 $y$ 轴的三角形。答案对 $1000000007$ 取模。</p><h3>思路</h3><p>若存在平行于 $x$ 轴或 $y$ 轴的边且长度为 $2$，一共有 $2(n-1)(m-2)m+2(m-1)(n-2)n$ 种情况。</p><p>若存在平行于 $x$ 轴或 $y$ 轴的边且长度为 $1$，除去已经计算过的情况（即还存在平行于$x$ 轴或 $y$ 轴且长度为 $2$ 的边），一共有 $2(m-1)(m-2)(n-2)+2(n-1)(n-2)(m-2)$ 种情况。</p><p>相加后化简，得到 $2(m+n-2)(2mn-3m-3n+4)$，利用 $ab\ mod\ c = ((a\ mod\ c)(b\ mod\ c))\ mod\ c$ 计算结果。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    long long n, m, tempa, tempb;
    cin &gt;&gt; n &gt;&gt; m;
    tempa = 2 * (m + n - 2);
    tempb = (2 * m * n - 3 * m - 3 * n + 4);
    cout &lt;&lt; (tempa % 1000000007) * (tempb % 1000000007) % 1000000007 &lt;&lt; endl;
    return 0;
}
</code></pre><h2>1B. Kotori 和 Bangdream</h2><h3>大意及思路</h3><p>签到题。求数学期望，也就是可能结果的概率乘以其结果的总和。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    double n, x, a, b;
    cin &gt;&gt; n &gt;&gt; x &gt;&gt; a &gt;&gt; b;
    double ans = (a * x + b * (100 - x)) * n / 100;
    printf(&quot;%.2lf\n&quot;, ans);
    return 0;
}
</code></pre><h2>1C. Umi 和弓道</h2><h3>大意</h3><p>一个人在 $(x_0,y_0)$，给出 $n$ 个靶子，在 $x$ 轴或 $y$ 轴放置挡板，令放置挡板后可以射中的靶子数量不多于 $k$ 个。</p><h3>思路</h3><p>只要靶子和 $(x_0,y_0)$ 不在一个象限就有可能被挡掉。要想挡掉一个靶子，只需求出靶子和 $(x_0,y_0)$ 所在直线与坐标轴的交点，并保证挡板覆盖了这个点。我们只需要恰好覆盖 $n-k$ 个这样的点就行了。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const double inf = 1e18;
vector&lt;double&gt; v1, v2;
int main()
{
    v1.clear();
    v2.clear();
    double x0, y0;
    int n, k, i;
    cin &gt;&gt; x0 &gt;&gt; y0 &gt;&gt; n &gt;&gt; k;
    k = n - k;
    for (i = 0; i &lt; n; i++)
    {
        double x, y;
        cin &gt;&gt; x &gt;&gt; y;
        if (x * x0 &lt; 0)
        {
            v2.push_back(y0 - x0 * (y - y0) / (x - x0));
        }
        if (y * y0 &lt; 0)
        {
            v1.push_back(x0 - y0 * (x - x0) / (y - y0));
        }
    }
    double mi = inf;
    sort(v1.begin(), v1.end());
    sort(v2.begin(), v2.end());
    if (v1.size() &gt;= k)
    {
        double head = 0, tail = k - 1;
        while (tail &lt; v1.size())
        {
            mi = mi &gt; (v1[tail] - v1[head]) ? (v1[tail] - v1[head]) : mi;
            tail++, head++;
        }
    }
    if (v2.size() &gt;= k)
    {
        double head = 0, tail = k - 1;
        while (tail &lt; v2.size())
        {
            mi = mi &gt; (v2[tail] - v2[head]) ? (v2[tail] - v2[head]) : mi;
            tail++, head++;
        }
    }
    if (mi == 1e18)
        cout &lt;&lt; -1;
    else
        printf(&quot;%.7lf&quot;, mi);
    return 0;
}
</code></pre><h2>1D. Hanayo 和米饭</h2><h3>大意</h3><p>给出 $n-1$ 个数，求一个数使得所有的 $n$ 个数经过排序后可形成公差为 $1$ 的等差数列。保证答案存在且唯一。</p><h3>思路</h3><p>签到题。将 $n-1$ 个数排序，看相邻两数的差是否为 $2$。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int n;
    cin &gt;&gt; n;
    int a[n - 1];
    for (int i = 0; i &lt; n - 1; i++)
    {
        cin &gt;&gt; a[i];
    }
    sort(a, a + n - 1);
    for (int i = 0; i &lt; n - 2; i++)
    {
        if (a[i + 1] - a[i] != 1)
        {
            cout &lt;&lt; a[i] + 1 &lt;&lt; endl;
            break;
        }
    }
    return 0;
}
</code></pre><h2>1E. Rin 和快速迭代</h2><h3>大意</h3><p>令 $f(x)$ 为 $x$ 因子个数，将 $f$ 迭代下去，问迭代多少次能得到 $2$。</p><h3>思路</h3><p>模拟就行。求因子个数时注意处理完全平方数。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
long long sol(long long x)
{
    long long temp = 0;
    long long i;
    for (i = 1; i * i &lt;= x; i++)
    {
        if (x % i == 0)
            temp++;
    }
    temp = temp &lt;&lt; 1;
    i--;
    if (i * i == x)
        temp--;
    return temp;
}
int main()
{
    long long n;
    cin &gt;&gt; n;
    int ans = 0;
    while (1)
    {
        n = sol(n);
        ans++;
        if (n == 2)
        {
            cout &lt;&lt; ans &lt;&lt; endl;
            return 0;
        }
    }
    return 0;
}
</code></pre><h2>1F. Maki 和 Tree</h2><h3>大意</h3><p>在树（无向）中有黑白两种点。求 $n$ 个点的树中有多少简单路径有且仅有通过一个黑色点。</p><h3>思路</h3><p>先预处理各个白色连通及其大小，具体思路是读入一条边如果这条边的两端都是白色连通块就连在一起（并查集）。然后再算各个黑点的答案。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
int fa[111111];  //父亲
int kdm[111111]; //孩子数量
string color;
int f(int x)
{ //寻找祖先
    if (fa[x] == x)
        return x;
    return f(fa[x]);
}
void uni(int x, int y)
{ //连接 x 点和 y 点
    int p = f(x), q = f(y);
    if (p != q)
    {
        if (kdm[p] &gt; kdm[q])
        {
            fa[q] = p;
            kdm[p] += kdm[q] + 1;
        }
        else
        {
            fa[p] = q;
            kdm[q] += kdm[p] + 1;
        }
    }
}
ll t[111111]; //统计连通块白点数量
vector&lt;int&gt; g[111111];
ll gao(vector&lt;int&gt; temp)
{ //temp 为黑点的每个相邻白点孩子数量集合
    ll res = 0, i;
    ll n = temp.size();
    if (n == 0)
        return 0;
    ll dp[n] = {0}, sum[n] = {0}, s = 0;
    sum[0] = s = temp[0];
    for (i = 0; i &lt; n; i++)
    {
        res += temp[i];
    }
    for (i = 1; i &lt; n; i++)
    {
        sum[i] = s += temp[i];
    }
    for (i = 1; i &lt; n; i++)
    {
        dp[i] = dp[i - 1] + temp[i] * sum[i - 1];
    }
    return res + dp[n - 1];
}
int main()
{

    int n, i, j;
    cin &gt;&gt; n &gt;&gt; color;
    for (i = 1; i &lt;= n; i++)
        fa[i] = i;
    for (i = 1; i &lt; n; i++)
    {
        int x, y;
        cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y);
        g[y].push_back(x);
        if (color[x - 1] == 'W' &amp;&amp; color[y - 1] == 'W')
            uni(x, y);
    }
    ll sum = 0;
    for (i = 1; i &lt;= n; i++)
        t[i] = kdm[f(i)] + 1;
    for (i = 1; i &lt;= n; i++)
    {
        if (color[i - 1] == 'B')
        {
            vector&lt;int&gt; temp;
            for (j = 0; j &lt; g[i].size(); j++)
            {
                if (color[g[i][j] - 1] == 'W')
                    temp.push_back(t[g[i][j]]); //若相邻点是白点，加入 temp
            }
            sum += gao(temp);
        }
    }
    cout &lt;&lt; sum;
}
</code></pre><h2>1G. Eli 和字符串</h2><h3>大意</h3><p>给出一个字符串，求连续子串的最小长度，要求这个连续子串要包含至少 $k$ 个相同的某个字母。</p><h3>思路</h3><p>前缀和加尺取法。前缀和用于求某个连续子串各个字母出现的次数。尺取法即连续子串两个指针，右指针不断右移，当发现满足条件的连续子串则左指针开始右移，当右指针移动到尽头则停止。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int cnt[26][200010];
int main()
{
    int n, k;
    string a;
    cin &gt;&gt; n &gt;&gt; k &gt;&gt; a;
    int l = a.size();
    for (int i = 0; i &lt; l; i++)
    {
        for (int j = 0; j &lt; 26; j++)
        {
            cnt[j][i + 1] = cnt[j][i];
        }
        cnt[a[i] - 'a'][i + 1]++;
    }
    int p1 = 0, p2 = 1, ans = n + 1;
    while (1)
    {
        int flag = 0;
        for (int i = 0; i &lt; 26; i++)
        {
            if (cnt[i][p2] - cnt[i][p1] &gt;= k)
            {
                ans = min(ans, p2 - p1);
                flag = 1;
            }
        }
        if (flag == 1)
            p1++;
        else
            p2++;
        if (p2 == n + 1)
            break;
    }
    if (ans == n + 1)
        cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;
    else
        cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h2>1H. Nozomi 和字符串</h2><h3>大意</h3><p>一个 $01$ 串，允许你改变其中的 $k$ 个数字，然后找出一个尽可能长的连续子串，这个子串上的所有字符都相同。求这个子串的长度。</p><h3>思路</h3><p>依然是尺取法。分成将 $0$ 变成 $1$ 和将 $1$ 变成 $0$ 两种情况。对于前者，还是两个指针，右指针不断右移，当遇到 $0$ 就用掉一次操作直到次数用尽。接下来右指针继续右移直到再次需要操作的时候，这时左指针右移直到已用操作数恰好减一为止，这时右指针继续右移。后者同理。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    string s;
    int n, k, ans = 0;
    cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;
    int pl = 0, pr = 0, change = 0;
    // 0 =&gt; 1
    for (int i = 0; i &lt; n; i++)
    {
        if (s[i] == '0')
        {
            if (change &lt; k)
            {
                change++;
            }
            else
            {
                while (pl &lt;= pr &amp;&amp; s[pl] != '0')
                    pl++;
                pl++;
            }
        }
        pr++;
        ans = max(ans, pr - pl);
    }
    pl = 0, pr = 0, change = 0;
    for (int i = 0; i &lt; n; i++)
    {
        if (s[i] == '1')
        {
            if (change &lt; k)
            {
                change++;
            }
            else
            {
                while (pl &lt;= pr &amp;&amp; s[pl] != '1')
                    pl++;
                pl++;
            }
        }
        pr++;
        // cout &lt;&lt; pl &lt;&lt; &quot; &quot; &lt;&lt; pr &lt;&lt; endl;
        ans = max(ans, pr - pl);
        // cout &lt;&lt; ans &lt;&lt; endl;
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h2>1I. Nico 和 Niconiconi</h2><h3>大意</h3><p>给出一个字符串，其中 <code>nico</code> 计 $a$ 分，<code>niconi</code> 计 $b$ 分，<code>niconiconi</code> 计 $c$ 分，每个字符都只能参与一次计分，问最大分数。</p><h3>思路</h3><p>简单 DP。$dp[i]$ 可由 $dp[i-1]$、$dp[i-3]$、$dp[i-5]$ 和 $dp[i-9]$ 转移而来，转移后取最大者即可。要注意避免越界。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
long long dp[300010];
int main()
{
    string s;
    long long n, a, b, c;
    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; s;
    for (long long i = 0; i &lt; n; i++)
    {
        if (i &gt; 0)
            dp[i] = dp[i - 1];
        if (i &gt;= 3 &amp;&amp; s.substr(i - 3, 4) == &quot;nico&quot;)
            dp[i] = max(dp[i], dp[i - 3] + a);
        if (i &gt;= 5 &amp;&amp; s.substr(i - 5, 6) == &quot;niconi&quot;)
            dp[i] = max(dp[i], dp[i - 5] + b);
        if (i &gt;= 9 &amp;&amp; s.substr(i - 9, 10) == &quot;niconiconi&quot;)
            dp[i] = max(dp[i], dp[i - 9] + c);
    }
    cout &lt;&lt; dp[n - 1] &lt;&lt; endl;
    return 0;
}
</code></pre><h2>1J. ## TODO</h2><h1>2020 牛客寒假算法基础集训营 2</h1><blockquote>枚举、贪心、DP、数论、思维、数据结构、哈希</blockquote><h2>2A. 做游戏</h2><h3>大意</h3><p>石头剪刀布。已知两人分别出了多少次石头、剪刀和布，求其中一个玩家最多能获胜多少局。</p><h3>思路</h3><p>贪心。让尽量多的剪刀 - 布、石头 - 剪刀和布 - 石头成组，可以直接出答案 $min(A,Y)+min(B,Z)+min(C,X)$。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    long long a, b, c, x, y, z;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; x &gt;&gt; y &gt;&gt; z;
    cout &lt;&lt; min(a, y) + min(b, z) + min(c, x) &lt;&lt; endl;
    return 0;
}
</code></pre><h2>2B. 排数字</h2><h3>大意</h3><p>给出一个字符串 $S$，问将字符串打乱后最多能有多少个不同的连续子串为 $616$ 。</p><h3>思路</h3><p>只需将所有的 $6$ 和 $1$ 集中起来：$6161616...$ ，因此统计 $6$ 和 $1$ 的个数即可，得出答案。注意 $cnt6$ 个 $6$ 最多能只造 $cnt6-1$ 个满足题意的字串，所以是 $min(cnt6-1,cnt1)$。如果算出来小于零应该将答案调整为 $0$。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int n, cnt1 = 0, cnt6 = 0;
    string s;
    cin &gt;&gt; n &gt;&gt; s;
    for (int i = 0; i &lt; n; i++)
    {
        if (s[i] == '1')
            cnt1++;
        else if (s[i] == '6')
            cnt6++;
    }
    cout &lt;&lt; max(0, min(cnt6 - 1, cnt1)) &lt;&lt; endl;
    return 0;
}
</code></pre><h2>2C. 算概率</h2><h3>大意</h3><p>一共 $n$ 道题，第 $i$ 道题的正确率是 $p_i$​，给出这个正确率对 $10^9+7$ 取模的结果，求这 $n$ 题里恰好有 $0,1,\cdots,n$ 题正确的概率分别是多少，同样对 $10^9+7$ 取模。对分数取模的定义已在题目给出。</p><h3>思路</h3><p>简单 DP。一个难点是求状态转移方程，一个是理解题目中对分数取模的概念（本蒟蒻在补第四套题时才会的乘法逆元，做这道题时直接观察样例对 $\frac{1}{2}$ 取模的结果，然后分子分母代进 $a$ 和 $b$ 蒙一把，发现简单粗暴地将概率乘个 $(10^9+7)+1$ 就是了）。要求前 $i$ 题正确 $j$ 题的概率，首先要知道的是前面具体过了哪几道题我们不需要知道（这里有点靠直觉），我们只需要简单粗暴地把它当作一个整体参与后面的计算。接下来，我们要分两种情况讨论，一个是第 $i$ 题对了 $f_{i-1,j} \cdot p_i$，一个是第 $i$ 题错了 $f_{i,j} \cdot (1-p_i)$，加起来就是了。状态转移方程 $f_{i,j} = f_{i-1,j} \cdot p_i+f_{i-1,j} \cdot (1-p_i)$。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

long long n, p[2005], dp[2005][2005];

int main()
{
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++)
    {
        cin &gt;&gt; p[i];
    }
    dp[0][0] = 1;
    for (int i = 1; i &lt;= n; i++)
    {
        dp[i][0] = dp[i - 1][0] * (1000000008 - p[i]) % 1000000007;
        for (int j = 1; j &lt;= i; j++)
            dp[i][j] = (dp[i - 1][j] * (1000000008 - p[i]) + dp[i - 1][j - 1] * p[i]) % 1000000007;
    }
    for (int i = 0; i &lt;= n; i++)
        cout &lt;&lt; dp[n][i] &lt;&lt; ' ';
    return 0;
}

</code></pre><h2>2D. 数三角</h2><h3>大意</h3><p>给出 $n$ 个点，问这 $n$ 个点形成的三角形中，总共有多少个钝角三角形。</p><h3>思路</h3><p>签到。枚举后比较 $a^2+b^2$ 和 $c^2$ 即可，另外注意三点不能共线。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int n, a[505], b[505], ans = 0;

bool f(int i, int j, int k)
{
    int check1 = (a[j] - a[i]) * (a[k] - a[i]) + (b[j] - b[i]) * (b[k] - b[i]);
    int check2 = (a[j] - a[i]) * (b[k] - b[i]) - (a[k] - a[i]) * (b[j] - b[i]);
    return check1 &lt; 0 &amp;&amp; check2 != 0;
}
int main()
{
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++)
        cin &gt;&gt; a[i] &gt;&gt; b[i];
    for (int i = 0; i &lt; n; i++)
    {
        for (int j = i + 1; j &lt; n; j++)
        {
            for (int k = j + 1; k &lt; n; k++)
            {
                if (f(i, j, k) || f(k, i, j) || f(j, i, k))
                {
                    ans++;
                }
            }
        }
    }

    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h2>2E. 做计数</h2><h3>大意</h3><p>求有多少个不同的正整数三元组 $(i,j,k)$ 满足 $\sqrt i+\sqrt j = \sqrt k$，而且 $i \cdot j \leq n$。</p><h3>思路</h3><p>看过一样的题，所以说多去看百度贴吧的营销号推送确实能涨知识。见到根号疯狂平方就对了（必要时候还是要移项的）。等式左右两边平方，$i+j+2 \sqrt {ij}=k$，发现要使 $k$ 为整数，必需要令 $i \cdot j$ 为完全平方数，所以我们就枚举完全平方数，然后再枚举这些完全平方数的因数。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int n, ans;
int main()
{
    cin &gt;&gt; n;
    for (int i = 1; i * i &lt;= n; i++)
    {
        for (int j = 1; j &lt;= i; j++)
            if (i * i % j == 0)
                ans += 2;
        ans--;
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h2>2F. 拿物品</h2><h3>大意</h3><p>多个物品，每个物品两个属性 $a$ 和 $b$， 甲乙两人轮流拿物品，最后甲的得分为其拿到物品的 $a$ 属性的和，乙则为 $b$ 属性的和。问两人最优策略下会拿哪些物品。</p><h3>思路</h3><p>假设两人赛后互换物品 $(a_1,b_1)$ 和 $(a_2,b_2)$，那么两人得分变化分别为 $-a_1+a_2$ 和 $b_1-b_2$，如果想让前者得分更大，要有 $a_1+b_1 &lt; a_2+b_2$。后者同理。所以就按照 $a+b$ 排序。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

const int N = 2e5 + 7;
int n;
vector&lt;int&gt; sa, sb;
struct temp
{
    int a, b, id;
} a[N];

bool cmp(temp a, temp b)
{
    return a.a + a.b &gt; b.a + b.b;
}

int main()
{
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++)
        cin &gt;&gt; a[i].a;
    for (int i = 1; i &lt;= n; i++)
    {
        cin &gt;&gt; a[i].b;
        a[i].id = i;
    }
    sort(a + 1, a + 1 + n, cmp);
    for (int i = 1; i &lt;= n; ++i)
        ((i &amp; 1) ? sa : sb).push_back(a[i].id);
    for (auto i : sa)
        cout &lt;&lt; i &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;
    for (auto i : sb)
        cout &lt;&lt; i &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;
    return 0;
}
</code></pre><h2>2G. 判正误</h2><h3>大意</h3><p>给出七个整数 $a, b, c, d, e, f, g$ 问是否有 $a^d+b^e+c^f=g$。数据范围 $10^9$ 级别，数据量 $10^3$ 级别。</p><h3>思路</h3><p>在模的意义下上快速幂验证，也就是验证 $a^d+b^e+c^f \equiv g \left ( mod \ M\right )$。模数越多，数据越水，就越稳。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int mod[] = {2, 3, 5, 7, 11, 31, 71, 97, 233, 397, 433, 449, 607, 857, 10007, 21179, 36251, 44579, 62003, 72883, 97843, 139991, 232013, 369353, 681521, 692711, 777241, 822821, 1956761, 2145137, 2915837, 6229117, 7788787, 13743493, 17331841, 19260817, 19269293, 19959809, 21006959, 23937083, 24410849, 28452757, 28478603, 29229359, 35570827, 35604011, 35875487, 37370863, 38303347, 38475517, 38819149, 40455791, 44021539, 45641993, 46531301, 48866749, 50529641, 52634191, 52790587, 55180799, 56971613, 58259351, 60954737, 62207269, 63367453, 65072599, 66017821, 67952779, 69475349, 74689217, 77059907, 77907121, 79391659, 84768797, 85584601, 85724879, 85756609, 86850899, 91783511, 92331541, 94519499, 96375241, 99033413, 99486311, 100569829, 106873549, 109329881, 109913681, 111186487, 111894067, 112136617, 112417363, 114011921, 119143363, 122994493, 123747781, 124001021, 126515639, 128191039, 128767909, 132222763, 133587661, 139644719, 145641527, 153388423, 155187077, 156883333, 157989581, 159538063, 161488643, 164039129, 166070447, 169181543, 169554227, 173564801, 175742867, 185469637, 187203899, 191263223, 198691817, 204144887, 211631201, 217903877, 218028203, 220073423, 228143453, 228667423, 232064653, 240519263, 245647159, 247586411, 247936121, 250949197, 253413211, 253464329, 260572729, 260590409, 262887773, 265711423, 266763641, 273585149, 276472817, 276500531, 280543667, 280649591, 281385491, 291366337, 293273159, 296973107, 302890501, 306568693, 315614297, 316729409, 317617121, 320337781, 320613497, 321322823, 324691051, 325963067, 327184157, 329900633, 330670159, 332058781, 332213669, 332300869, 334382221, 341895677, 347938237, 349011827, 349347503, 349906439, 353796941, 364557253, 364755931, 367946441, 372413831, 374358983, 379589897, 381149689, 389431873, 404683493, 405216109, 405495029, 408142403, 408989747, 410841979, 410935093, 412405351, 412592459, 412722139, 412990573, 418171483, 421270357, 424233613, 427938449, 428492083, 429962881, 430883569, 434988383, 435941201, 438816151, 440052953, 440143589, 444693631, 453646433, 455847109, 456640189, 457911511, 458185237, 463116761, 463861417, 469275953, 471298573, 471712513, 478267417, 483824813, 494828483, 497397293, 499657393, 507957479, 512906621, 519346459, 519879973, 520094713, 523213693, 525673273, 529575763, 529883803, 533887031, 534260809, 535328309, 541992667, 542253071, 544780177, 545567609, 552922529, 555129893, 555820037, 558473471, 563484017, 571310471, 578121241, 582251063, 583825639, 584121323, 592038487, 599098811, 601467677, 610073969, 615059213, 619220713, 622457177, 627412609, 630547919, 632342989, 637357363, 638865419, 648268013, 650007487, 651564761, 654115433, 661281713, 662664461, 667914281, 682988213, 691099121, 691445809, 692038043, 692411953, 698620943, 699007259, 701164631, 706806461, 707096251, 707697451, 709566589, 719095829, 725756807, 736880491, 739603867, 743026709, 744236861, 744396049, 747393791, 749395103, 760341121, 762934307, 773124059, 773195911, 776162609, 781629113, 781884613, 786120631, 788314343, 788898377, 788939293, 790209983, 791933183, 796328783, 798643889, 802280047, 803293991, 803847559, 809752739, 818520473, 820434047, 826810489, 829359959, 829707427, 836587463, 841011167, 843763253, 849410557, 851226437, 853058471, 853168793, 853778327, 859086391, 860720017, 863193077, 873061181, 888803059, 893035529, 900902953, 904636883, 917949577, 921817139, 922328707, 931449133, 933074827, 933156233, 935241721, 935632799, 939948881, 957119773, 961329913, 965269573, 965337949, 967551691, 971080093, 973578143, 976825877, 985100197, 985413691, 986124823, 990650057, 998244353, 999058883, 1000000007};
int ff(int a, int m)
{
    return (a % m + m) % m;
}
int Pow(int a, int b, int c)
{
    int ret = 1;
    while (b)
    {
        if (b &amp; 1)
            ret = ret * 1ll * a % c;
        a = a * 1ll * a % c;
        b &gt;&gt;= 1;
    }
    return ret;
}
int a, b, c, d, e, f, g;

bool check(int m)
{
    return ((Pow(ff(a, m), d, m) + Pow(ff(b, m), e, m)) % m + Pow(ff(c, m), f, m)) % m == ff(g, m);
}

int main()
{
    int T;
    cin &gt;&gt; T;
    while (T--)
    {
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f &gt;&gt; g;
        bool flag = 1;
        for (int i = 0; i &lt; 349; ++i)
        {
            if (!check(mod[i]))
            {
                flag = 0;
                break;
            }
        }
        puts(flag ? &quot;Yes&quot; : &quot;No&quot;);
    }
    return 0;
}
</code></pre><p>第三场。</p><h1>2020 牛客寒假算法基础集训营 4</h1><blockquote>搜索、简单 STL、前缀和、二分搜索、位运算、贪心、分治、树</blockquote><h2>4A. 欧几里得</h2><h3>大意</h3><p>给出了一个递归实现的 GCD 的代码，告诉你递归次数，求最开始的两个数，它们不相同且都是非负数，使这两个数的和最小。</p><h3>思路</h3><p>签到题。递归次数为 $0$ 次的时候肯定这两个是 $1$ 和 $0$。递归次数为 $1$ 次的时候则是 $2$ 和 $1$。假设说 $a$ 大于 $b$，其实就是已知 $b$ 和 $a\ mod\ b$，然后要让 $a$ 最小，那么就让 $\left \lfloor \frac{a}{b} \right \rfloor$ 最小。那就让它等于 $1$，可以很快发现是斐波那契数列。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main()
{
    int T;
    cin &gt;&gt; T;
    while (T--)
    {
        long long n;
        cin &gt;&gt; n;
        long long a[n + 10];
        a[0] = 1;
        a[1] = 2;
        for (int i = 2; i &lt; n + 7; i++)
        {
            a[i] = a[i - 1] + a[i - 2];
        }
        if (n == 0)
            cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;
        else
            cout &lt;&lt; a[n + 1] &lt;&lt; endl;
    }
    return 0;
}
</code></pre><h2>4B. 括号序列</h2><h3>大意</h3><p>给出一个仅包含 <code>[</code>、<code>]</code>、<code>(</code>、<code>)</code>、<code>{</code>、<code>}</code> 六种字符的括号序列，判断其是否合法。</p><h3>思路</h3><p>签到题。开一个栈来储存左括号，读到右括号看看栈顶的左括号和它匹不匹配。匹配就 POP 一个左括号。每时每刻都判断一下栈是不是空的。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main()
{
    string a;
    cin &gt;&gt; a;
    stack&lt;char&gt; b;
    for (int i = 0; i &lt; a.size(); i++)
    {
        // cout &lt;&lt; a[i];
        if (a[i] == '[')
            b.push('[');
        else if (a[i] == '{')
            b.push('{');
        else if (a[i] == '(')
            b.push('(');
 
 
        else if (a[i] == ']')
        {
            if (b.empty() || (! b.empty() &amp;&amp; b.top() != '['))
            {
                cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
                return 0;
            }
            else if (! b.empty())
                b.pop();
        }
        else if (a[i] == ')')
        {
            if (b.empty() || (! b.empty() &amp;&amp; b.top() != '('))
            {
                cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
                return 0;
            }
            else if (! b.empty())
                b.pop();
        }
        else if (a[i] == '}')
        {
            if (b.empty() || (! b.empty() &amp;&amp; b.top() != '{'))
            {
                cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
                return 0;
            }
            else if (! b.empty())
                b.pop();
        }
    }
    if (b.empty())
        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
    return 0;
}
</code></pre><h2>4C. 子段乘积</h2><h3>大意</h3><p>给出一个数列和一个数字 $k$，求其长度为 $k$ 的连续子段的乘积对 $998244353$ 取模余数的最大值。</p><h3>思路</h3><p>其实会乘法逆元的话就可以尺取了，可惜我刚开始做这题的时候不会，只好线段树了。反正期间也不用改动数字，懒标记什么的统统不要，把线段树建起来直接开始查询。</p><pre><code>#include &lt;bits/stdc++.h&gt;
 
using namespace std;
 
const int maxn = 200010;
 
int a[maxn + 2];
 
struct tree
{
    int l, r;
    long long pre, add;
} t[4 * maxn + 2];
 
void bulid(int p, int l, int r)
{
    t[p].l = l;
    t[p].r = r;
    if (l == r)
    {
        t[p].pre = a[l];
        return;
    }
    int mid = l + r &gt;&gt; 1;
    bulid(p * 2, l, mid);
    bulid(p * 2 + 1, mid + 1, r);
    t[p].pre = (t[p * 2].pre * t[p * 2 + 1].pre) % 998244353;
}
 
long long ask(int p, int x, int y)
{
    if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
        return t[p].pre;
    int mid = t[p].l + t[p].r &gt;&gt; 1;
    long long ans = 1;
    if (x &lt;= mid)
        ans = ans * ask(p * 2, x, y) % 998244353;
    if (y &gt; mid)
        ans = ans * ask(p * 2 + 1, x, y) % 998244353;
    return ans;
}
 
int main()
{
    int n, m;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; i++)
        scanf(&quot;%d&quot;, &amp;a[i]);
    bulid(1, 1, n);
    long long ans = -1;
    for (int i = 1; i + m - 1 &lt;= n; i++)
    {
        int x, y;
        ans = max(ans, ask(1, i, i + m - 1));
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h2>4D. 子段异或</h2><h3>大意</h3><p>给出一个数列，让你需要输出其中异或值为 $0$ 的不同连续子段的数量。</p><h3>思路</h3><p>首先用到了前缀和的思想，将前缀异或存进一个数组里。然后接合异或的性质：如果 $a\ xor\ b=c$，那么 $c\ xor\ a=b$，那么数组里任意两个数异或就是某一个区间的异或值，反正我们也不用关心这个区间从哪开始从哪结束，又因为 $a\ xor\ a=0$，我们给数组排下序，看看相邻两个数字是否相等就可以啦。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main()
{
    int n;
    cin &gt;&gt; n;
    long long a[n + 10];
    long long temp;
    cin &gt;&gt; temp;
    a[0] = temp;
    for (int i = 1; i &lt; n; i++)
    {
        cin &gt;&gt; temp;
        a[i] = a[i - 1] ^ temp;
    }
    sort(a, a + n);
    long long ans = 0, cnt = 1;
    for (int i = 0; i &lt; n; i++)
    {
        if (a[i] == 0)
            ans++;
        if (i != 0 &amp;&amp; a[i] == a[i - 1])
            cnt++;
        if (i != 0 &amp;&amp; (a[i] != a[i - 1] || i == n - 1))
        {
            ans += cnt * (cnt - 1) / 2;
            cnt = 1;
        }
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h2>4E. 最小表达式</h2><h3>大意</h3><p>给出一个字符串，里面只包含 $1$ 到 $9$ 还有加号。要求给出字符串的一个排列，使排列后是一个合法的算式而且算式的计算结果最小。</p><h3>思路</h3><p>贪心。加号的数字知道后就知道要有多少个数相加。然后我们将大的数字放在个位十位这种低位数，将小的数字放在高位数。然后是大数加法。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int cnt[20];
int sum[500050];

string s;
int main()
{
    cin &gt;&gt; s;
    int ccnt = 1;
    int n = s.size();
    for (int i = 0; i &lt; n; i++)
    {
        if (isdigit(s[i]))
        {
            cnt[s[i] - '0']++;
        }
        else
        {
            ccnt++;
        }
    }
    int p = 0, cp = 0;
    for (int i = 10; i &gt;= 1; i--)
    {
        while (cnt[i])
        {
            sum[cp] += i;
            cnt[i]--;
            p = (p + 1) % ccnt;
            if (p == 0)
                cp++;
        }
    }
    for (int i = 0; i &lt; 500010; i++)
    {
        sum[i + 1] += sum[i] / 10;
        sum[i] %= 10;
    }
    int opt = 0;
    for (int i = 500010; i &gt;= 0; i--)
    {
        if (opt || sum[i])
        {
            cout &lt;&lt; sum[i];
            opt = 1;
        }
    }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre><h2>4J. 二维跑步</h2><h3>完整题目</h3><p>一个点在平面直角坐标系中移动，初始位置 $(0,0)$，移动了 $n$ 次。从 $(i,0)$ 可以移动到 $(i+1,0)$、$(i+1,1)$、$(i+1,2)$、$(i,0)$、$(i-1,1)$、$(i-1,2)$，从 $(i,1)$ 可以移动到 $(i+1,0)$、$(i+1,1)$、$(i+1,2)$、$(i,1)$、$(i-1,0)$、$(i-1,2)$，从 $(i,2)$ 可以移动到 $(i+1,0)$、$(i+1,1)$、$(i+1,2)$、$(i,2)$、$(i-1,0)$、$(i-1,1)$。这里的 $(i,0)$ 移动到 $(i,0)$ 没有打错，而是不变换坐标的前提下消耗一个步数。已知 $n$ 和 $m$，数值均小于 $3 \cdot 10^6$，然后问你有多少种方式使得点的 $x$ 坐标最后落在 $[-m,m]$，答案对 $998244353$ 取模输出。</p><h3>思路</h3><h4>坐标等价</h4><p>理解题目在讲啥后，首先要做的是简化题目条件，你会发现这么多的坐标其中纵坐标只有三种，$0$、$1$ 和 $2$，当横坐标增加的时候（也就是从 $i$ 变成 $i+1$ 了，后面类似），无论初始位置的纵坐标是啥，能够到达的位置的纵坐标都是任意的。当横座标不变，纵坐标都是不变的。当横坐标减少的时候，无论初始位置的纵坐标是啥，能够到达的位置的纵坐标都只有两个可选而且都不等于初始位置的纵坐标。综上所述，我们发现纵坐标在这题是无关紧要的，横坐标相同的三个点是等价的。那么我们就可以将题目理解为：从 $x=i$ 的点到 $x=i+1$ 的点有三种方法，到 $x=i$ 的点有一种方法，到 $x=i-1$ 的点有两种方法。</p><h4>排列组合</h4><p>考虑到 $n$ 步下来本质还是左移、右移、不动三种方式的组合，只需设出三种方式分别的步数，用组合数公式即可。这里不妨设 $x$ 坐标不变的次数为 $i$，其中 $a$ 次 $x$ 坐标增加了，那么就会有 $n-i-a$ 次坐标减少。我们可以知道最后的坐标位置为 $x_{final}=a-(n-i-a)=2a-n+i$。为了让这个坐标处于 $[-m,m]$ 这个区间，我们要有：</p><p>$\left\{\begin{matrix} -m \leq 2a-n+i \leq m \ 0 \leq a \leq n-i \end{matrix}\right. $</p><p>由于 $a$ 还是一个整数，算出来的结果还需要上下取整：</p><p>$max(\left \lceil \frac{-m+n-i}{2} \right \rceil,0)\leq a \leq min(\left \lfloor \frac{m+n-i}{2} \right \rfloor,n-i)$</p><p>结合高中数学内容，我们知道 $i$ 次坐标不变，$a$ 次坐标增加的方案数一共是 $C _{n}^{i}(C _{n-i}^{a} \cdot 3^{a} \cdot 2^{n-i-a})$，我们进行求和操作，得出的结果是：</p><p>$ans = \sum_{i=0}^{n} \textrm{C} _{n}^{i}(\sum_{a=max(\left \lceil \frac{-m+n-i}{2} \right \rceil,0)}^{min(\left \lfloor \frac{m+n-i}{2} \right \rfloor,n-i)} \textrm{C} _{n-i}^{a} \cdot 3^{a} \cdot 2^{n-i-a}) $</p><h4>优化</h4><p>考虑到 $n$ 和 $m$ 的数据范围，直接进行计算肯定是不行，我们尝试将上面的式子拆为多部分。令：</p><p>$\left\{\begin{matrix}f(p,q)=C_p^q \cdot3^q \cdot 2^{p-q} \ L(i)=max(\left \lceil \frac{-m+n-i}{2} \right \rceil,0) \ R(i)=min(\left \lfloor \frac{m+n-i}{2} \right \rfloor,n-i) \ G(i)=\sum_{a=L(i)}^{R(i)}f(n-i,a) \ ans = \sum_{i=0}^{n}C_{n}^{i} G(i) \end{matrix}\right.$</p><p>在这些式子中，我们发现要缩短 $ans$ 的计算时间，就必须缩短 $G(i)$ 的计算时间。考虑到计算 $G(i)$ 时 $L(i)$ 和 $R(i)$ 都是一次性计算完成，但是 $f(p,q)$ 这样的式子我们要算上很多遍，我们我们就尝试优化 $f(p,q)$ 的计算。所谓优化很多时候就是预处理。我们看看对应的式子：组合数，得算阶乘吧，得算 $2$ 的 $p-q$ 次幂吧，得算 $3$ 的 $q$ 次幂吧，全部预处理掉。接下来就比较玄学了，考虑到我们除了要计算 $f(n-i,a)$，还要计算 $f(n-i-1,a)$、$f(n-i+1,a)$ 等等，因为恰好有 $C_p^q=C_{p-1}^{q}+C_{p-1}^{q-1}$ 这个公式，也就有了前项推后项的思路。我们尝试将 $2$ 和 $3$ 的指数和组合数匹配一下，得出 $f(p,q)=2f(p-1,q)+3f(p-1,q-1)$ 这样的式子。</p><p>接下来就不用再管 $f(p,q)$ 等于什么了，回到 $G(i)$ 这个层面。我们用上面的结论尝试展开上面的式子：</p><p>$G(i)=\sum_{a=L(i)}^{R(i)}f(n-i,a)$  <br>$=\sum_{a=L(i)}^{R(i)}(3f(n-(i+1),a-1)+2f(n-(i+1),a))$  <br>$=3f(n-(i+1),L(i)-1)+2f(n-(i+1),L(i))+3f(n-(i+1),L(i))+ \cdots +2f(n-(i+1),R(i)-1))+3f(n-(i+1),R(i)-1)+2f(n-(i+1),R(i))$  <br>$=5 \sum_{a=L(i)}^{R(i)-1}f(n-(i+1),a)+3f(n-(i+1),L(i)-1)+2f(n-(i+1),R(i))$</p><p>你会发现有一项是 $\sum_{a=L(i)}^{R(i)-1}f(n-(i+1),a)$，和 $G(i+1)$ 的形式很像，但是后者是 $\sum_{a=L(i+1)}^{R(i+1)}f(n-(i+1),a)$，还是有点区别。怎么办呢？就人为创造一个 $\sum_{a=L(i+1)}^{R(i+1)}f(n-(i+1),a)$ 呗。还是上面那个式子，我们把所有的 $L(i)$ 换成 $L(i+1)$，把 $R(i)-1$ 换成 $R(i+1)$，但这算出来就和 $G(i)$ 差了几个的 $f(n-i,a)$ 怎么办呢。先标记为 $\Delta$ 到后面再算呗。</p><p>$G(i)=\sum_{a=L(i+1)}^{R(i+1)+1}f(n-i,a)+\Delta$  <br>$=\sum_{a=L(i+1)}^{R(i+1)+1}(3f(n-(i+1),a-1)+2f(n-(i+1),a))+\Delta$  <br>$=3f(n-(i+1),L(i+1)-1)+2f(n-(i+1),L(i+1))+3f(n-(i+1),L(i+1))+ \cdots +2f(n-(i+1),R(i+1)))+3f(n-(i+1),R(i+1))+2f(n-(i+1),R(i+1)+1)+\Delta$  <br>$=5 \sum_{a=L(i+1)}^{R(i+1)}f(n-(i+1),a)+3f(n-(i+1),L(i+1)-1)+2f(n-(i+1),R(i+1)+1)+\Delta$  <br>$=5G(i+1)+3f(n-(i+1),L(i+1)-1)+2f(n-(i+1),R(i+1)+1)+\Delta$</p><h4>代码实现</h4><p>在式子乘个 <code>1ll</code> 可以有效避免溢出的问题。计算高次幂为了避免溢出，在写快速幂的时候也要每步取模。计算组合数的时候需要用到除以比较大的数，还是为了避免溢出这时候也是要取模的。于是就打开了乘法逆元的新世界，道理其实也不是很懂，大概就是如果有一个素数 $p$，根据费马小定理则有 $a^{p-1}\equiv1(mod\;p)$，那么 ${a}\cdot a^{p-2}\equiv1(mod\;p)$，$a^{p-2}$ 就叫 $a\ mod\ p$ 意义下的逆元，照用就是了。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
const int mod = 998244353;
const int N = 3000010;
int n, m, f2[N], f3[N], q[N], p[N], G[N];
 

//////// 快速幂 ////////
int qpow(int a, int b) {
    int ans = 1;
    a %= mod;
    for (; b; b &gt;&gt;= 1) {
        if (b &amp; 1) ans = 1ll * ans * a % mod;
        a = 1ll * a * a % mod;
    }
    return ans;
}

//////// 组合数 ////////
int c(int a, int b) { return 1ll * q[a] * p[b] % mod * p[a - b] % mod; }

//////// 算 f(a,b) ////////
int f(int a, int b) { return 1ll * c(a, b) * f3[b] % mod * f2[a - b] % mod; }

int main() {
    cin &gt;&gt; n &gt;&gt; m;
    f2[0] = f3[0] = q[0] = 1;
    for (int i = 1; i &lt;= n; i++) {
        // 算 i!，2 的 i 次方，3 的 i 次方，对 mod 取模
        q[i] = 1ll * q[i - 1] * i % mod;
        f2[i] = 1ll * f2[i - 1] * 2 % mod;
        f3[i] = 1ll * f3[i - 1] * 3 % mod;
    }

    // 乘法逆元
    p[n] = qpow(q[n], mod - 2);
    for (int i = n - 1; i &gt;= 0; i--) p[i] = 1ll * p[i + 1] * (i + 1) % mod;

    //////// 算 G(i) ////////
    int l = 0, r = 1; G[n] = 1;
    for (int i = n - 1; i &gt;= 0; i--, r++) {

        // 算 5 * G(i + 1) + 3 * f(...) + 5 * f(...)
        G[i] = (5ll * G[i + 1] % mod + 3ll * f(n - i - 1, l - 1) % mod + 2ll * f(n - i - 1, r) % mod) % mod;
        int ql = max((n - i - m + 1) / 2, 0), qr = min((n - i + m) / 2, n - i);
        // 此时 l = L(i + 1), r = R(i + 1) + 1
        // 此时 ql = L(i), qr = R(i)
        
        // 算 delta
        while (l &lt; ql) G[i] = (1ll * G[i] - f(n - i, l) + mod) % mod, l++;
        while (l &gt; ql) l--, G[i] = (1ll * G[i] + f(n - i, l)) % mod;
        while (r &gt; qr) G[i] = (1ll * G[i] - f(n - i, r) + mod) % mod, r--;
        while (r &lt; qr) r++, G[i] = (1ll * G[i] + f(n - i, r)) % mod;
        // 此时 l = L(i), r = R(i)
        // 此时 i--, r++
    }

    //////// 算答案 ////////
    int ans = 0;
    for (int i = n; i &gt;= 0; i--) ans = (ans + 1ll * G[i] * c(n, i) % mod) % mod;
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h1>2020 牛客寒假算法基础集训营 5</h1><blockquote>字符串、二分、哈希、DP、模拟、搜索、数学</blockquote><h2>5A. 模板</h2><h3>大意</h3><p>给出两个字符串，允许对其中一个字符串做任意的替换、删除最后一位、在末尾添加一个字母。问最少的步数，使两个字符串相同。</p><h3>思路</h3><p>签到题。逐个位置匹配，发现不一样则步数加一。当长度较短的字符串匹配完后再加上两个字符串的长度差。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    string a, b;
    cin &gt;&gt; a &gt;&gt; b;
    if (n &lt; m)
    {
        swap(n, m);
        swap(a, b);
    }
    int ans = 0;
 
    for (int i = 0; i &lt; m; i++)
    {
        if (a[i] != b[i])
            ans++;
    }
    ans += n - m;
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h2>5B. 牛牛战队的比赛地</h2><h3>大意</h3><p>已知多个点的坐标，问平面上哪个位置满足到这些点的距离的最大值最小。</p><h3>思路</h3><p>三分答案。大概是因为它是二次函数，每次使用三分都能排除最差的一部分答案。二分答案似乎也是可以的，但二分的依据是单调性，二次函数也没法保证这一点，所以做起来似乎要麻烦很多。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

struct p
{
    int x, y;
} a[100005];
int n;
double check(double x)
{
    double max = 0;
    for (int i = 0; i &lt; n; i++)
    {
        double tmp = sqrt(a[i].y * a[i].y + (a[i].x - x) * (a[i].x - x));
        if (tmp &gt; max)
            max = tmp;
    }
    return max;
}
double tsearch(double left, double right)
{
    int i;
    double mid, midmid;
    for (i = 0; i &lt; 100; i++)
    {
        mid = left + (right - left) / 2;
        midmid = mid + (right - mid) / 2;
        if (check(mid) &gt; check(midmid))
            left = mid;
        else
            right = midmid;
    }
    return mid;
}
int main()
{
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++)
        cin &gt;&gt; a[i].x &gt;&gt; a[i].y;
    double max = tsearch(-10000, 10000);
    cout &lt;&lt; check(max) &lt;&lt; endl;
    return 0;
}
</code></pre><h2>5C. C 语言 IDE</h2><h3>大意</h3><p>输入一份 C 语言代码，要求输出代码中出现的函数。</p><h3>思路</h3><p>哦，是码农大模拟！爱了爱了。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

string source;
void replaceAll(string &amp;s, string oldstr, string newstr)
{
    for (string::size_type pos = 0; pos != string::npos; pos += newstr.length())
        if ((pos = s.find(oldstr, pos)) != string::npos)
            s.replace(pos, oldstr.length(), newstr);
        else
            break;
}
struct functions
{
    string inClass, name, outputType;
    vector&lt;string&gt; inputType;
    functions(string inClass = &quot;&quot;, string name = &quot;&quot;, string outputType = &quot;void&quot;, vector&lt;string&gt; inputType = vector&lt;string&gt;(0))
        : inClass(inClass), name(name), outputType(outputType), inputType(inputType) {}
};
vector&lt;functions&gt; funs;
void solve(string &amp;s)
{
    replaceAll(s, &quot;/*&quot;, &quot; /* &quot;);
    replaceAll(s, &quot;*/&quot;, &quot; */ &quot;);
    replaceAll(s, &quot;//&quot;, &quot; // &quot;);
    replaceAll(s, &quot;(&quot;, &quot; ( &quot;);
    replaceAll(s, &quot;)&quot;, &quot; ) &quot;);
    replaceAll(s, &quot;{&quot;, &quot; { &quot;);
    replaceAll(s, &quot;}&quot;, &quot; } &quot;);
    replaceAll(s, &quot;=&quot;, &quot; = &quot;);
    replaceAll(s, &quot;\&quot;&quot;, &quot; \&quot; &quot;);
    replaceAll(s, &quot;'&quot;, &quot; ' &quot;);
    replaceAll(s, &quot;;&quot;, &quot; ; &quot;);
    replaceAll(s, &quot;,&quot;, &quot; , &quot;);
    replaceAll(s, &quot;+ = &quot;, &quot;+=&quot;);
    replaceAll(s, &quot;- = &quot;, &quot;-=&quot;);
    replaceAll(s, &quot;* = &quot;, &quot;*=&quot;);
    replaceAll(s, &quot;/ = &quot;, &quot;/=&quot;);
    replaceAll(s, &quot;^ = &quot;, &quot;^=&quot;);
    replaceAll(s, &quot;| = &quot;, &quot;|=&quot;);
    replaceAll(s, &quot;&amp; = &quot;, &quot;&amp;=&quot;);
    replaceAll(s, &quot;:&quot;, &quot; : &quot;);
    replaceAll(s, &quot; :  : &quot;, &quot;::&quot;);
    vector&lt;string&gt; tokens;
    string now = &quot;&quot;;
    for (int i = 0; s[i]; i++)
    {
        if (s[i] == ' ' || s[i] == '\t' || s[i] == '\r' || s[i] == '\n' || s[i] == '\0')
        {
            if (now != &quot;&quot;)
            {
                if (now == &quot;:&quot; &amp;&amp; tokens.back() == &quot;)&quot;)
                {
                    string tmpnow = &quot;&quot;;
                    for (int j = i + 1; s[j]; j++)
                    {
                        if (s[j] == ' ' || s[j] == '\t' || s[j] == '\r' || s[j] == '\n' || s[j] == '\0')
                        {
                            if (tmpnow == &quot;{&quot;)
                            {
                                now = &quot;{&quot;;
                                i = j - 1;
                                break;
                            }
                            tmpnow = &quot;&quot;;
                        }
                        else
                            tmpnow += s[j];
                    }
                    continue;
                }
                if (now == &quot;const&quot;)
                {
                    now = &quot;&quot;;
                    continue;
                }
                if (now == &quot;//&quot;)
                {
                    for (int j = i; s[j]; j++)
                    {
                        if (s[j] == '\n')
                        {
                            i = j - 1;
                            break;
                        }
                    }
                    now = &quot;&quot;;
                    continue;
                }
                if (now == &quot;/*&quot;)
                {
                    int num = 1;
                    string tmpnow = &quot;&quot;;
                    for (int j = i + 1; s[j]; j++)
                    {
                        if (s[j] == ' ' || s[j] == '\t' || s[j] == '\r' || s[j] == '\n' || s[j] == '\0')
                        {
                            if (tmpnow == &quot;/*&quot;)
                                num++;
                            if (tmpnow == &quot;*/&quot;)
                            {
                                num--;
                                if (num == 0)
                                {
                                    i = j - 1;
                                    break;
                                }
                            }
                            tmpnow = &quot;&quot;;
                        }
                        else
                            tmpnow += s[j];
                    }
                    now = &quot;&quot;;
                    continue;
                }
                tokens.push_back(now);
                now = &quot;&quot;;
            }
        }
        else
            now += s[i];
    }
    int cnt = 0;
    string nowNamespace = &quot;&quot;;
    for (int i = 1; i &lt; (int)tokens.size(); i++)
    {
        if ((tokens[i] == &quot;struct&quot; || tokens[i] == &quot;class&quot;) &amp;&amp; tokens[i + 2] == &quot;{&quot;)
        {
            cnt = 0;
            nowNamespace = tokens[i + 1];
            i += 2;
        }
        functions tmp(nowNamespace);
        if (tokens[i] == &quot;{&quot; &amp;&amp; tokens[i - 1] == &quot;)&quot;)
        {
            int num = 1;
            for (int j = i - 2; j &gt;= 0; j--)
            {
                if (tokens[j] == &quot;)&quot;)
                    num++;
                if (tokens[j] == &quot;(&quot;)
                {
                    num--;
                    if (num == 0)
                    {
                        tmp.name = tokens[j - 1];
                        tmp.outputType = &quot;&quot;;
                        for (int k = j - 2; k &gt;= 0; k--)
                            if (tokens[k] != &quot;}&quot; &amp;&amp; tokens[k] != &quot;}&quot; &amp;&amp; tokens[k] != &quot;;&quot; &amp;&amp;
                                tokens[k].back() != ':' &amp;&amp; tokens[k] != &quot;inline&quot; &amp;&amp;
                                tokens[k] != &quot;static&quot; &amp;&amp; tokens[k][0] != '#' &amp;&amp;
                                tokens[k].back() != '\&quot;' &amp;&amp; tokens[k].back() != '&gt;')
                                tmp.outputType = tmp.outputType == &quot;&quot; ? tokens[k] : tokens[k] + &quot; &quot; + tmp.outputType;
                            else
                                break;
                        int last = i - 2;
                        for (int k = i - 2; k &gt;= j; k--)
                        {
                            if (tokens[k] == &quot;(&quot; || tokens[k] == &quot;,&quot;)
                            {
                                string tt = &quot;&quot;;
                                for (int t = k + 1; t &lt; last; t++)
                                    tt = tt == &quot;&quot; ? tokens[t] : tt + &quot; &quot; + tokens[t];
                                if (tt != &quot;&quot;)
                                    tmp.inputType.push_back(tt);
                                last = k - 1;
                            }
                            if (tokens[k] == &quot;=&quot; || tokens[k] == &quot;)&quot;)
                                last = k - 1;
                        }
                        reverse(tmp.inputType.begin(), tmp.inputType.end());
                        break;
                    }
                }
            }
            funs.push_back(tmp);
            num = 1;
            for (int j = i + 1; j &lt; (int)tokens.size(); j++)
            {
                if (tokens[j] == &quot;{&quot;)
                    num++;
                if (tokens[j] == &quot;}&quot;)
                {
                    num--;
                    if (num == 0)
                    {
                        i = j;
                        break;
                    }
                }
            }
            continue;
        }
        if (nowNamespace != &quot;&quot;)
        {
            if (tokens[i] == &quot;{&quot;)
                cnt++;
            if (tokens[i] == &quot;}&quot;)
            {
                cnt--;
                if (!cnt)
                    nowNamespace = &quot;&quot;;
            }
        }
    }
}
int main()
{
    char ch;
    while ((ch = getchar()) != EOF)
        source += ch;
    solve(source);
    for (auto &amp;i : funs)
    {
        if (i.outputType != &quot;&quot;)
            cout &lt;&lt; i.outputType &lt;&lt; &quot; &quot;;
        if (i.inClass != &quot;&quot;)
            cout &lt;&lt; i.inClass &lt;&lt; &quot;::&quot;;
        cout &lt;&lt; i.name &lt;&lt; &quot;(&quot;;
        for (int j = 0; j &lt; (int)i.inputType.size(); j++)
            cout &lt;&lt; i.inputType[j] &lt;&lt; (j == (int)i.inputType.size() - 1 ? &quot;)&quot; : &quot;,&quot;);
        if ((int)i.inputType.size() == 0)
            cout &lt;&lt; &quot;)&quot;;
        cout &lt;&lt; endl;
    }
    return 0;
}
</code></pre><h2>5E. Enjoy the Game</h2><h3>大意</h3><p>给出一个规则：$n$ 张卡牌，先手第一步最少拿 $1$ 张，最多拿 $n-1$ 张。接下来每一步，双方最少要拿 $1$ 张，最多拿等同于上一步对方拿的牌数的牌。拿走最后一张牌胜。问对不同的 $n$，先手是否有必胜策略。</p><h3>思路</h3><p>找规律找出来的，只要是二的幂就是 Alice 胜，否则就是 Bob 胜。这题好像把 <code>__builtin_popcount(n)</code> 给卡了，原因不明，反正下次是不敢用了。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
long long lowbit(long long x)
{
    return x&amp;(-x);
}
   
int main()
{
    long long n;
    cin &gt;&gt; n;
    if (lowbit(n) == n)
    {
        cout &lt;&lt; &quot;Alice&quot; &lt;&lt; endl;
        return 0;
    }
    cout &lt;&lt; &quot;Bob&quot; &lt;&lt; endl;
    return 0;
}
</code></pre><h2>5H. Hash</h2><h3>大意</h3><p>给出一个字符串和一个 Hash 函数（核心代码 <code>res = (res * 26 + str[i] - 'a') % mod;</code>），求一个字典序最小且大于该字符串且有着相同 Hash 的字符串。</p><h3>思路</h3><p>其实就是把字符串转成了二十六进制数，然后给它取模。那么要想 Hash 值相同字典序还要大于原字符串，就直接给这个二十六进制数加上模数就好了。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main()
{
    string a;
    int m;
    int ta[6];
    while (cin &gt;&gt; a &gt;&gt; m)
    {
        int org[6], backup[6];
        for (int i = 0; i &lt; 6; i++)
        {
            org[i] = a[i] - 'a';
            backup[i] = org[i];
        }
        string b = a;
        for (int i = 5; i &gt;= 0; i--)
        {
            ta[i] = m % 26;
            m /= 26;
        }
        if (m != 0)
        {
            cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;
        }
        for (int i = 5; i &gt; 0; i--)
        {
            org[i] += ta[i];
            if (org[i] &gt; 25)
            {
                org[i] -= 26;
                org[i - 1]++;
            }
        }
        org[0] += ta[0];
        if (org[0] &lt; 26)
        {
            for (int i = 0; i &lt; 6; i++)
            {
                printf(&quot;%c&quot;, org[i] + 'a');
            }
            cout &lt;&lt; endl;
            continue;
        }
        else
        {
            cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;
            continue;
        }
    }
 
    return 0;
}
</code></pre><h2>5I. I 题是个签到题</h2><h3>大意</h3><p>给出一场比赛参赛人数和各题过题人数，通过人数不低于全场人数的 $80\%$ 或在所有题目中前三多就叫签到题。问 I 题是不是签到题。</p><h3>思路</h3><p>签到题。排序即可，关键是要处理并列的情况。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
struct temp
{
    int num;
    int ac;
} a[20000];
 
bool cmp(temp a, temp b)
{
    return a.ac &gt; b.ac;
}
 
int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 0; i &lt; n; i++)
    {
        cin &gt;&gt; a[i].ac;
        a[i].num = i;
    }
    if (a[8].ac * 10 &gt;= m * 8)
    {
        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
        return 0;
    }
    sort(a, a + n, cmp);
    int cnt = 1;
    int cur = 1;
    if (a[0].num == 8)
    {
        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
        return 0;
    }
    for (int i = 1; i &lt; n; i++)
    {
        if (a[i].ac != a[i - 1].ac)
        {
            cnt += cur;
            cur = 1;
        }
        else
        {
            cur++;
        }
        if (a[i].num == 8 &amp;&amp; cnt &lt;= 3)
        {
            cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
            return 0;
        }
        if (cnt &gt; 3)
        {
            cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
            return 0;
        }
    }
}
</code></pre><h2>5J. 牛牛战队的秀场</h2><h3>大意</h3><p>求圆内接正 $n$ 边形的边长。</p><h3>思路</h3><p>签到。可以很容易地计算每条弦对应的圆心角的大小，然后三角函数。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
#define PI 3.1415926535898
 
int main()
{
    double n, r, i, j;
    cin &gt;&gt; n &gt;&gt; r &gt;&gt; i &gt;&gt; j;
    if (i == j)
    {
        cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;
        return 0;
    }
    if (i &gt; j)
        swap(i, j);
    double ans = min(j - i, i - j + n);
    printf(&quot;%.8lf\n&quot;, ans * 2 * r * sin(360 / n / 2 * PI / 180));
    return 0;
}
</code></pre><h1>2020 牛客寒假算法基础集训营 6</h1><blockquote>贪心、图论、构造、二分、计数、数论、思维</blockquote><h2>6A. 配对</h2><h3>大意</h3><p>给出两个集合，每个集合里有 $N$ 个数，不同集合的两个数配对并求和，要求最大化第 $K$ 大的和。</p><h3>思路</h3><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
typedef long long ll;
 
int main()
{
    ll n, k;
    cin &gt;&gt; n &gt;&gt; k;
    ll a[n], b[n], c[n];
    for (ll i = 0; i &lt; n; i++)
    {
        cin &gt;&gt; a[i];
    }
    for (ll i = 0; i &lt; n; i++)
    {
        cin &gt;&gt; b[i];
    }
    sort(a, a + n);
    sort(b, b + n);
    for (int i = 0; i &lt; k; i++)
    {
        c[i] = a[n - 1 - i] + b[n - k + i];
    }
    sort(c, c + k);
    cout &lt;&lt; c[0] &lt;&lt; endl;
    return 0;
}
</code></pre><h2>B.</h2>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://static.bobby285271.top/index.php/2020/02/09/2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html#comments</comments>
<wfw:commentRss>https://static.bobby285271.top/index.php/feed/2020/02/09/2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html</wfw:commentRss>
</item>
<item>
<title>Dynamic Programming on Tree Structures (Luogu P2014)</title>
<link>https://static.bobby285271.top/index.php/2019/12/26/Dynamic-Programming-on-Tree-Structures-Luogu-P2014.html</link>
<guid>https://static.bobby285271.top/index.php/2019/12/26/Dynamic-Programming-on-Tree-Structures-Luogu-P2014.html</guid>
<pubDate>Thu, 26 Dec 2019 09:22:00 +0000</pubDate>
<dc:creator>bobby285271</dc:creator>
<description><![CDATA[题目https://www.luogu.com.cn/problem/P2014思路以下内容仅为个人理解，可能存在错误。树的孩子兄弟表示法想要使用孩子兄弟表示法储存上面这样的一棵树，我们就要从根...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<h2>题目</h2><p><a href="https://www.luogu.com.cn/problem/P2014">https://www.luogu.com.cn/problem/P2014</a></p><h2>思路</h2><blockquote>以下内容<strong>仅为个人理解，可能存在错误</strong>。</blockquote><h3>树的孩子兄弟表示法</h3><p><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/p2014-2.gif" alt="" title=""></p><p>想要使用孩子兄弟表示法储存上面这样的一棵树，我们就要从根节点开始，依次用链表存储各个节点的孩子节点和兄弟节点。因此，该链表中的节点应包含以下三部分内容：</p><ul><li>节点的值。</li><li>指向孩子节点的指针。</li><li>指向兄弟节点的指针。</li></ul><p><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/p2014-1.gif" alt="" title=""></p><p>在这里，每个节点是一门课程，孩子节点其实就是后续课程，兄弟节点其实就是前导课程相同的一门课程。不妨将第 i 门课程编号为 i，那么每一门课都会有一个独一无二的课程编号。这个课程编号本应放在数据域，但是考虑到它的独一无二性和连续性，也方便我们查找某一课程的「后续课程」和「前导课程相同的一门课程」的课程编号，以获取它的学分，我们不妨直接用数组下标来储存这个，就不开数据域了。</p><h3>树形动归</h3><blockquote><strong>TODO</strong>：此部分自认为没有理解透彻，下面给出的思路也不够自然。</blockquote><p>考虑之前发过的几道题，LXY 点菜，我们逐道菜过目；上山采药，我们逐件药品过目。这里我们照葫芦画瓢，就逐门课过目。树形动归和线性动归又有些啥不同呢？首先要遵循从最简单的子问题开始，逐步扩大子问题规模的原则，从子树上动归，最后进行合并。如何体现合并这一操作呢？就是在过目某一节点（课程）的时候同时考虑这个节点（课程）的后续课程。</p><p>不妨就将根节点（假设其编号为 now）的所有孩子过目完，假设现在过目了 a 门课程，选择了 b 门课程。对于这个第 a 门课程依然是两个选择，<strong>选和不选</strong>。不选的话和我过目 a - 1 门课程，选择了 b 门课程效果是一样的，而第 a 门课程我不选自然就拿不了学分，其后续课程我也选不了就无需考虑了。但如果我选择呢，我不但选了第 a 门课程，而且还要考虑它的后续课程。假设已知我过目完 a - 1 门课程时，选择了 b - c 门课程。过目第 a 门课程显然我就考虑了第 a 门课的后续课程并选择了 c 门课程（包含 a）。此时为了求出过目了 a 门课程，选择了 b 门课程的最大学分，我就要求出过目 a - 1 门课程，选择了 b - c 门课程的最大学分和考虑了第 a 门课的<strong>所有</strong>后续课程并选择了 c 门课程（包含 a）的最大学分。而由于我们从子树开始动归，所以后者我们是已经求出过的。考虑完选和不选两种情况后，取最大值即可。</p><p>假设 <code>son</code> 是 <code>now</code> 的一个子节点，有：</p><pre><code class="lang-cpp">f[now][i][j] = max(f[now][i - 1][j], f[son][所有节点数][k] + f[now][i - 1][j - k]);</code></pre><p>和线性动态规划一样，由于过目了 i 门课程的情况永远由过目 i - 1 门课程的情况推出来，于是这一维可以被去掉。</p><pre><code class="lang-cpp">f[now][j] = max(f[now][j], f[son][k] + f[now][j - k]);</code></pre><h2>AC 代码</h2><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
//n、m 如题所述，f[i][j] 表示 i 为子树的根节点，在子树中选 j 门课的最大学分
int n, m, f[1000][1000], fa;
struct node //用结构体储存节点信息
{
    int pre, to; //pre 为兄弟节点在数组 e 中的下标，to 为孩子节点在数组 e 中的下标
} e[1000];       //考虑到课程编号的唯一性，这题 e 数组下标可用来表示课程编号，我们也不用开数据域了

void dp(int now) //在「根节点编号为 now 的树」中动归
{
    //遍历 now 的所有孩子节点，也就是先访问 now 的「第一个」儿子节点，然后再访问这个儿子节点的兄弟节点
    for (int i = e[now].to; i != 0; i = e[i].pre)
    {
        dp(i);                           //在「根节点编号为 i 的树」中动归
        for (int j = m + 1; j &gt;= 1; j--) //关于为什么要反向遍历，前面的文章有提及
        {
            for (int k = 0; k &lt; j; k++)
                f[now][j] = max(f[now][j], f[i][k] + f[now][j - k]); //状态转移方程
        }
    }
}
int main()
{
    ios::sync_with_stdio(false); //是输入输出挂
    cin.tie(0);                  //还是输入输出挂
    cout.tie(0);                 //依然是输入输出挂
    cin &gt;&gt; n &gt;&gt; m;
    //我们令 i 为节点（课程）的编号
    //不妨假定存在一门编号为 0 的课，是所有课程的先修课程且学分为 0
    //这样子我们就可以将所有的课程标在一棵树上
    for (int i = 1; i &lt;= n; i++) //接下来我们从 i = 1 开始读入 n 个节点（课程）
    {
        cin &gt;&gt; fa;           //fa 是节点 i 的父节点（先修课程）的编号
        cin &gt;&gt; f[i][1];      //显然 j == 1 时最大学分就是编号为 i 的这门课本身的学分
        e[i].pre = e[fa].to; //指明节点 i 的兄弟节点是节点 fa 的「第一个」儿子节点
        e[fa].to = i;        //更新节点 fa 的「第一个」儿子节点为节点 i
    }
    dp(0); //从编号为 0 的根节点开始动归
    //输出 0 为根节点，选 m + 1 门课的最大学分
    //m + 1 门课是因为我们无中生有了一门「所有课程的先修课」，也就是编号为 0 的这门课
    cout &lt;&lt; f[0][m + 1] &lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://static.bobby285271.top/index.php/2019/12/26/Dynamic-Programming-on-Tree-Structures-Luogu-P2014.html#comments</comments>
<wfw:commentRss>https://static.bobby285271.top/index.php/feed/2019/12/26/Dynamic-Programming-on-Tree-Structures-Luogu-P2014.html</wfw:commentRss>
</item>
<item>
<title>Segment Tree (Luogu P3372)</title>
<link>https://static.bobby285271.top/index.php/2019/12/18/segment-tree.html</link>
<guid>https://static.bobby285271.top/index.php/2019/12/18/segment-tree.html</guid>
<pubDate>Wed, 18 Dec 2019 15:35:00 +0000</pubDate>
<dc:creator>bobby285271</dc:creator>
<description><![CDATA[SCNUACM 新生赛的 C 题被我用 N 方算法水过去了，很惭愧，还是想了解一下正解。当然了，一切的基础，就是熟悉相关的模板咯！题目https://www.luogu.com.cn/probl...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>SCNUACM 新生赛的 C 题被我用 N 方算法水过去了，很惭愧，还是想了解一下正解。当然了，一切的基础，就是熟悉相关的模板咯！</p><h2>题目</h2><p><a href="https://www.luogu.com.cn/problem/P3372">https://www.luogu.com.cn/problem/P3372</a></p><h2>思路</h2><blockquote>以下内容<strong>仅为个人理解，可能存在错误</strong>。</blockquote><p>显然，对给出的区间中的每一个数逐个加 k（操作 1）或者一个一个数累加下去来求和（操作 2）是会超时的。我们先抛开操作 1 不谈，试想一下对于操作 2，如果我们可以把这个区间分成几个小块，然后又事先知道每一小块中的元素求和的结果，那我求和的时候是不是就不需要算那么多项呢？是不是也就快一点呢？于是就有了分块思想。如果我们把这个思想给贯彻地彻底一些，事先将几个小块拼在一起形成一个大块，又事先算出每一大块中的元素求和的结果，会不会再更快一些呢？以此类推，树形结构就被我们构建出来了。事实上，线段树就是一种二叉树（但不一定是完全二叉树，下面配图就是一个反例，感谢 CGY 提醒）。它的每一个子节点都表示整个序列中的一段子区间，每个叶子节点都表示序列中的单个元素信息，父节点整合了他的每一个子节点的信息。</p><blockquote>有人会问既然是求和，直接前缀和不就好了吗。刚开始我也是这样想的，果然后来我就看到了树状数组的模板，后面也会去试一下。但是上面这个思路可以处理更多的情况，例如我求个最大值最小值我也可以应用。</blockquote><p>假设我的序列已经读入完毕并储存到数组 a 了（这个简单）：</p><pre><code class="lang-cpp">long long a[maxn + 2];
long long n, m;
scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);
for (long long i = 1; i &lt;= n; i++)
    scanf(&quot;%lld&quot;, &amp;a[i]);</code></pre><p>虽然说不一定是完全二叉数，但是可以用<strong>类似于</strong>创建完全二叉树的方式来创建线段树。首先，考虑单个节点。我们使用一个结构体来储存节点的信息，<code>l</code> 和 <code>r</code> 是这个节点维护的区间范围，<code>sum</code> 储存这个区间的和（也就是说 <code>sum</code> 储存了从 <code>a[l]</code> 到 <code>a[r]</code> 所有元素的和）。这里不妨结合图来理解（转载自洛谷）：</p><p><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/xianduanshu.png" alt="" title=""></p><p>接下来我们考虑整棵数。我们使用数组 t 存这颗树，用数组 t 的下标表示每个节点的编号。为什么数组要开数据量的四倍呢，可以通过计算树的高度，然后用等比数列求和公式得出。</p><pre><code class="lang-cpp">struct tree
{
    long long l, r;
    long long sum;
} t[4 * maxn + 2];</code></pre><p>接下来我们就开始建树。自然要从根开始一层一层地建下去。我们整一个建树函数，考虑向它传入三个参数，其中 <code>p</code> 是该节点的编号（其实就是数组 t 的下标），<code>l</code> 和 <code>r</code> 是这个节点维护的区间范围。</p><pre><code class="lang-cpp">void build(long long p, long long l, long long r);</code></pre><p>我们把这个节点建好了之后就去建它的左右儿子两个节点，显然它们的编号是 <code>p * 2</code> 和 <code>p * 2 + 1</code>（还是数组 t 的下标），这两个子节点维护的区间范围自然就要减半了。我们假设 <code>mid = (l + r) / 2</code>，那么就让左儿子维护 <code>l</code> 到 <code>mid</code>，右儿子维护 <code>mid + 1</code> 到 <code>r</code>。</p><p>当然，我们不可能一直建下去，当 <code>l == r</code> 的时候这个节点只维护一个元素，这个元素正正是 <code>a[l]</code>（或者 <code>a[r]</code>）。这时就可以开始求 <code>sum</code> 而无需再往下建树了。你会发现 <code>t[p].sum = a[l];</code>，<code>p</code> 依然是这个节点本身的编号。那么那些 <code>l != r</code> 的节点又怎样计算 <code>sum</code> 呢？就利用上面所说的思想，直接把两个子节点的 <code>sum</code> 加在一起就是自己的 <code>sum</code> 了。</p><pre><code class="lang-cpp">void build(long long p, long long l, long long r)
{
    t[p].l = l;
    t[p].r = r;
    if (l == r)
    {
        t[p].sum = a[l];
        return;
    }
    long long mid = (l + r) / 2;
    build(p * 2, l, mid);
    build(p * 2 + 1, mid + 1, r);
    t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;
}</code></pre><p>让我们在 main 函数中调用这个函数，我们让根节点的编号为 1，按照题意根节点维护的区间范围自然是 <code>l</code> 到 <code>n</code>：</p><pre><code class="lang-cpp">build(1, 1, n);</code></pre><p>好了我们现在再来考虑一下操作 1，操作 1 是否也可以应用类似的思想呢？我们很容易想到一种看起来很简单的方法。同样是将序列分成一个一个的小块，我们直接给整个小块打上一个标签，告诉大家「这个小块里面的元素都应该被加上 k」。而小块中的元素我就干脆不碰它了。于是<strong>懒标签</strong>也就有了。我们在结构体中添加一 <code>lazy</code>，用作这个「标签」。</p><pre><code class="lang-cpp">struct tree
{
    long long l, r;
    long long sum, lazy;
} t[4 * maxn + 2];</code></pre><p>假设我现在让 <code>x</code> 到 <code>y</code> 这个区间的所有元素全部加 z。根据分块思想，我可以拆分这个区间为几个小的区间，使这些小区间的 <code>sum</code> 我都在建树的时候提前算过。我假设其中一个小的区间，也就是刚才建好的树的其中一个节点（假设它的编号为 p）维护的区间范围为 <code>t[p].r</code> 到 <code>t[p].l</code>。我们准备一个函数来处理这件事：</p><pre><code class="lang-cpp">void change(long long p, long long x, long long y, long long z);</code></pre><p>我们直接对 <code>sum</code> 加上「元素个数」个 z，然后打上标签，声明 <code>t[p].r</code> 到 <code>t[p].l</code> 中所有数都应该被加上 z。</p><pre><code class="lang-cpp">t[p].sum += z * (t[p].r - t[p].l + 1);
t[p].lazy += z;</code></pre><p>但是问题也来了，如何正确地<strong>拆分给定区间为几个小的区间</strong>呢。显然我们要让这些<strong>小的区间</strong>的数量尽量少，一个简单粗暴的方法就是：既然我们有一棵树，树上每个节点都有标明它维护的区间范围，我们就从这棵树的根开始，从上往下枚举这些区间，只到找到合适的区间。何为合适？</p><pre><code class="lang-cpp">if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
{
    t[p].sum += z * (t[p].r - t[p].l + 1);
    t[p].lazy += z;
}</code></pre><p>如果条件满足，我们就成功地找到了一个<strong>小的区间</strong>。如果条件不满足，我们还需要继续寻找其它的<strong>小的区间</strong>直到这些小区间拼起来正好是给定的区间。显然一个节点的左儿子和右儿子如果都是上面所说的<strong>合适的</strong>小区间，那么<strong>小的区间</strong>的数量就不是最小了，因为这个节点本身也必然是合适的。于是我们直接考虑下一层的节点。</p><pre><code class="lang-cpp">long long mid = (t[p].l + t[p].r) / 2;
if (x &lt;= mid)
    change(p * 2, x, y, z);
if (y &gt; mid)
    change(p * 2 + 1, x, y, z);</code></pre><p>要注意的是，当子节点的 <code>sum</code> 被改变了，要及时地将变更传递回来。</p><pre><code class="lang-cpp">t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;</code></pre><p>按理来说这个 change 函数我们基本就实现出来了。但是有一个非常坑的地方，就是如果我连续进行多个操作 1，在第一个操作 1 时，我的 <code>t[p].sum</code> 恰好是一个合适的小区间，被修改了，但是 <code>t[p * 2].sum</code> 和 <code>t[p * 2 + 1].sum</code> 是没有变动的，因为变更都被拦截在 <code>t[p].lazy</code> 那里了。在第二个操作 1 时，<code>t[p].sum</code> 可能不是一个合适的小区间，但 <code>t[p * 2].sum</code> 是。<code>t[p * 2].sum</code> 被修改了，而且通过上面这一行代码传了回去。试想一下 <code>t[p].sum</code> 的值是不是会出现错误呢？于是在必要的时候，懒标记储存的更改还是得下放下去。那懒标记存在的意义到底在哪里？要知道的是我下放懒标记仅仅是因为 <code>t[p].sum</code> 不是一个合适的小区间。如果它是的话，这个懒标记还是可以节约时间的。</p><p>懒标记的下放很简单，就是将左右儿子的 <code>sum</code> 和 <code>lazy</code> 给改过来，<strong>把自己的懒标记归零</strong>：</p><pre><code class="lang-cpp">void spread(long long p)
{
    if (t[p].lazy)
    {
        t[p * 2].sum += t[p].lazy * (t[p * 2].r - t[p * 2].l + 1);
        t[p * 2 + 1].sum += t[p].lazy * (t[p * 2 + 1].r - t[p * 2 + 1].l + 1);
        t[p * 2].lazy += t[p].lazy;
        t[p * 2 + 1].lazy += t[p].lazy;
        t[p].lazy = 0;
    }
}</code></pre><p>这样子我们的 change 函数也就完成了！</p><pre><code class="lang-cpp">void change(long long p, long long x, long long y, long long z)
{
    if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
    {
        t[p].sum += z * (t[p].r - t[p].l + 1);
        t[p].lazy += z;
        return;
    }
    spread(p);
    long long mid = (t[p].l + t[p].r) / 2;
    if (x &lt;= mid)
        change(p * 2, x, y, z);
    if (y &gt; mid)
        change(p * 2 + 1, x, y, z);
    t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;
}</code></pre><p>我们回到开头，我们希望让 <code>x</code> 到 <code>y</code> 这个区间的所有元素全部加 z，那么我们来调用这个函数。要让这些<strong>小的区间</strong>的数量尽量少，我们从树根开始查找：</p><pre><code class="lang-cpp">long long q, x, y, z;
scanf(&quot;%lld&quot;, &amp;q);
if (q == 1)
{
    scanf(&quot;%lld%lld%lld&quot;, &amp;x, &amp;y, &amp;z);
    change(1, x, y, z);
}</code></pre><p>那么如果我想求出给定区间的和，按照上面的思想，同样也是<strong>拆分给定区间为几个小的区间</strong>。我们开一个 <code>ans</code> 变量，当找到合适的小区间时就把它的 <code>sum</code> 给累加进去。其实和 change 函数的实现几乎一样。但要注意的是，如果发现有懒标记没有下放而这个区间又不是一个合适的小区间的时候，还是要下放。不然如果它的左右孩子有一个是合适的小区间，累加进去的 <code>sum</code> 就是错的。</p><pre><code class="lang-cpp">long long ask(long long p, long long x, long long y)
{
    if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
        return t[p].sum;
    spread(p);
    long long mid = (t[p].l + t[p].r) / 2;
    long long ans = 0;
    if (x &lt;= mid)
        ans += ask(p * 2, x, y);
    if (y &gt; mid)
        ans += ask(p * 2 + 1, x, y);
    return ans;
}</code></pre><p>在 main 函数里面调用的时候，还是要从树根开始选取合适的小区间。</p><pre><code class="lang-cpp">long long q, x, y;
scanf(&quot;%lld&quot;, &amp;q);
if (q == 2)
{
    scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
    printf(&quot;%lld\n&quot;, ask(1, x, y));
}</code></pre><h2>AC 代码</h2><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const long long maxn = 100010;
long long a[maxn + 2];
struct tree
{
    long long l, r;
    long long sum, lazy;
} t[4 * maxn + 2];

void build(long long p, long long l, long long r)
{
    t[p].l = l;
    t[p].r = r;
    if (l == r)
    {
        t[p].sum = a[l];
        return;
    }
    long long mid = (l + r) / 2;
    build(p * 2, l, mid);
    build(p * 2 + 1, mid + 1, r);
    t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;
}

void spread(long long p)
{
    if (t[p].lazy)
    {
        t[p * 2].sum += t[p].lazy * (t[p * 2].r - t[p * 2].l + 1);
        t[p * 2 + 1].sum += t[p].lazy * (t[p * 2 + 1].r - t[p * 2 + 1].l + 1);
        t[p * 2].lazy += t[p].lazy;
        t[p * 2 + 1].lazy += t[p].lazy;
        t[p].lazy = 0;
    }
}

void change(long long p, long long x, long long y, long long z)
{
    if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
    {
        t[p].sum += z * (t[p].r - t[p].l + 1);
        t[p].lazy += z;
        return;
    }
    spread(p);
    long long mid = (t[p].l + t[p].r) / 2;
    if (x &lt;= mid)
        change(p * 2, x, y, z);
    if (y &gt; mid)
        change(p * 2 + 1, x, y, z);
    t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;
}

long long ask(long long p, long long x, long long y)
{
    if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
        return t[p].sum;
    spread(p);
    long long mid = (t[p].l + t[p].r) / 2;
    long long ans = 0;
    if (x &lt;= mid)
        ans += ask(p * 2, x, y);
    if (y &gt; mid)
        ans += ask(p * 2 + 1, x, y);
    return ans;
}

int main()
{
    long long n, m;
    scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);
    for (long long i = 1; i &lt;= n; i++)
        scanf(&quot;%lld&quot;, &amp;a[i]);
    build(1, 1, n);
    for (long long i = 1; i &lt;= m; i++)
    {
        long long q, x, y, z;
        scanf(&quot;%lld&quot;, &amp;q);
        if (q == 1)
        {
            scanf(&quot;%lld%lld%lld&quot;, &amp;x, &amp;y, &amp;z);
            change(1, x, y, z);
        }
        else
        {
            scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
            printf(&quot;%lld\n&quot;,ask(1, x, y));
        }
    }
    return 0;
}</code></pre>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://static.bobby285271.top/index.php/2019/12/18/segment-tree.html#comments</comments>
<wfw:commentRss>https://static.bobby285271.top/index.php/feed/2019/12/18/segment-tree.html</wfw:commentRss>
</item>
<item>
<title>Dynamic Prgramming - 0/1 Backpack Problem (Luogu P1164, P1048, P1020)</title>
<link>https://static.bobby285271.top/index.php/2019/11/17/Dynamic-Prgramming---0-1-Backpack-Problem-Luogu-P1164-P1048-P1020.html</link>
<guid>https://static.bobby285271.top/index.php/2019/11/17/Dynamic-Prgramming---0-1-Backpack-Problem-Luogu-P1164-P1048-P1020.html</guid>
<pubDate>Sun, 17 Nov 2019 15:29:00 +0000</pubDate>
<dc:creator>bobby285271</dc:creator>
<description><![CDATA[为啥突然想要看动态规划呢，是因为昨天做了去年蓝桥杯预选赛 16/17 的题，做到 B 题发现正解其实应该是动态规划的。虽然我交了一发贪心过了，但想到两个星期后就是热身赛还是得搞搞突击才行。引入周...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>为啥突然想要看动态规划呢，是因为昨天做了去年蓝桥杯预选赛 16/17 的题，做到 B 题发现正解其实应该是动态规划的。虽然我交了一发贪心过了，但想到两个星期后就是热身赛还是得搞搞突击才行。</p><h2>引入</h2><p>周四香农先修班讲了一个斐波拉契数列的专题，有一个问题是这样的：假设有 n 级楼梯，我从底部往上爬，每次可以上 1 级，也可以上 2 级楼梯，问从底部到顶部一共有多少种爬楼梯的方法。</p><p>我第一时间想到的是搜索和回溯，但是既然是斐波拉契数列的专题，也就有了 $f(n) = f(n-1) + f(n-2)$ 这个公式。我简单说一下这个式子是怎么来的吧。我们不妨假设我们走了 x 步之后上到了第 n 级，那我第 x-1 步在什么位置呢？只能是第 n-1 和 n-2 级。$f(n-1)$ 是走到 n-1 级楼梯时的方法数，$f(n-2)$ 同理。考虑一下边界情况，就是斐波拉契数列了呗。</p><h2>P1164 -（二维 DP）</h2><p>题目：<a href="https://www.luogu.org/problem/P1164">https://www.luogu.org/problem/P1164</a></p><p>不妨就来考虑一下「引入」小节的思路（模拟退火是啥我也不会），我们要求吃够 m 块钱，和爬 n 级楼梯其实是一回事。我<strong>上 1 级台阶还是 2 级台阶</strong>，其实和对于一道菜，我<strong>吃还是不吃</strong>是一回事。区别在哪呢，这里我们有很多不同的菜。然而我们也不用想太多，就让它们按顺序逐个上菜好了，然后我们<strong>逐个</strong>决定是吃还是不吃，顺便记下到底花了多少钱<del>（注意上菜不代表我们就要吃嘛对吧，吃了才花钱）</del>。</p><p>我们定义 <code>f[i][j]</code> 为上了 i 道菜用光 j 元钱的办法总数。假设我们现在已经上了 i-1 道菜，接下来上第 i 道菜。我们就有两个选择：</p><ul><li>吃（花钱）。</li><li>不吃（不花钱）。</li></ul><p>如果不吃，那我上 i 道菜用光 j 元钱的方法数，和上了 i-1 道菜用光 j 元钱的方法数一样。如果我吃，那我上 i 道菜用光 j 元钱的方法数，和上了 i-1 道菜用光（j-这道菜的价格）的方法数一样。将两种情况和在一起，于是有：</p><pre><code class="lang-cpp">f[i][j] = f[i - 1][j] + f[i - 1][j - 第i道菜的价格];</code></pre><p>通常来讲这就结束了，但是这道菜的价格我们却没有讨论清楚。首先，如果我没钱吃着道菜呢？那就只能不吃了呗。</p><pre><code class="lang-cpp">if(j &lt; 第i道菜的价格) f[i][j] = f[i - 1][j];
if(j &gt;= 第i道菜的价格) f[i][j] = f[i - 1][j] + f[i - 1][j - 第i道菜的价格];</code></pre><p>有些人想问 <code>j == 第i道菜的价格</code> 这种情况怎么搞，我们将这种情况代入到上面的代码，其实就是 <code>f[i][j] = f[i - 1][j] + f[i - 1][0]</code>，<code>f[i - 1][0]</code> 其实就是上了 i-1 个菜我全不吃，消费 0 元嘛，显然只有一种情况。但形如 <code>f[i][0]</code> 的数据又可以从哪推出呢？不如特判一下，当然直接给他们赋值也是可以的：</p><pre><code class="lang-cpp">if(j &lt; 第i道菜的价格) f[i][j] = f[i - 1][j];
if(j == 第i道菜的价格) f[i][j] = f[i - 1][j] + 1;
if(j &gt; 第i道菜的价格) f[i][j] = f[i - 1][j] + f[i - 1][j - 第i道菜的价格];</code></pre><p>既然有了递推式（状态转移方程），我们要的是上完 n 道菜后花掉 m 块钱的方案，那就遍历一下这个数组直到得出答案为止呗。上代码：</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int a[101], f[101][10001];
int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; i++)
    {
        cin &gt;&gt; a[i];
    }
    for (int i = 1; i &lt;= n; i++)
    {
        for (int j = 1; j &lt;= m; j++)
        {
            if (j &gt; a[i])
                f[i][j] = f[i - 1][j] + f[i - 1][j - a[i]];
            if (j == a[i])
                f[i][j] = f[i - 1][j] + 1;
            if (j &lt; a[i])
                f[i][j] = f[i - 1][j];
        }
    }
    cout &lt;&lt; f[n][m] &lt;&lt; endl;
    return 0;
}</code></pre><h2>P1048（一维 DP）</h2><p>题目：<a href="https://www.luogu.org/problem/P1048">https://www.luogu.org/problem/P1048</a></p><p>这道题按照上面的思路打大概是怎样的呢？<del>显然</del>，我们开一个二位数组 <code>f[i][j]</code> 来表示过目 i 件药材（过目意味着我在采摘和不采摘中二选一）耗去 j 时间后的最大价值就可以了。时间如果足够，就考虑一下要不要采摘这个药材。同样地，<strong>采摘</strong>第 i 件药材耗去 j 时间的这种情况下的最大价值是过目 i-1 件药材时耗去（j-药材采摘时间）时间的最大价值。<strong>不采摘</strong>第 i 件药材耗去 j 时间的这种情况下的最大价值是过目 i-1 件药材时耗去 j 时间的最大价值。对于两种情况我们取较大者即可。</p><p>那我们为啥提出希望降维呢？我们看上面的代码：</p><pre><code class="lang-cpp">if (j &gt; a[i])
    f[i][j] = f[i - 1][j] + f[i - 1][j - a[i]];
if (j == a[i])
    f[i][j] = f[i - 1][j] + 1;
if (j &lt; a[i])
    f[i][j] = f[i - 1][j];</code></pre><p>再来看一下这一题的核心代码（<code>a[i]</code> 为采摘时间，<code>v[i]</code> 为药材价值）：</p><pre><code class="lang-cpp">if (j &gt;= a[i])
    f[i][j] = max(f[i - 1][j - a[i]] + v[i], f[i - 1][j]);
else
    f[i][j] = f[i - 1][j];</code></pre><p>第 i 件物品需要求的信息永远是从第 i-1 件物品那里得出来的。如果我们最后只需要第 i 件物品的答案而不需要 i-1、i-2... 件物品的答案，我们为何不用新的信息覆盖旧的信息呢？修改的方法很简单：</p><pre><code class="lang-cpp">if (j &gt;= a[i])
    f[j] = max(f[j - a[i]] + v[i], f[j]);
// 下面的没必要保留了吧。
// else
//     f[j] = f[j];</code></pre><p>虽然降维了，但遍历还是要以上面的方式来，于是我们就得到一个似乎很有道理的代码。</p><pre><code class="lang-cpp">for (int i = 1; i &lt;= m; i++)
{
    for (int j = a[i]; j &lt;= t; j++) // 既然上面只有一个分支结构，那我在循环条件那里保证就好了。
    {
        f[j] = max(f[j - a[i]] + v[i], f[j]);
    }
}
cout &lt;&lt; f[t] &lt;&lt; endl;</code></pre><p>这却是一个非常典型的错误，因为按照原本的意思，第 i 个物品的数据要从 i-1 个物品的数据推出来，但我在上面求第 i 个物品的 <code>f[j]</code> 的时候却使用到了已经更新过的，已经是第 i 个物品的数据 f[j - a[i]]。怎样避免呢：</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int t, m;
    cin &gt;&gt; t &gt;&gt; m;
    int a[m + 10], v[m + 10];
    for (int i = 1; i &lt;= m; i++)
    {
        cin &gt;&gt; a[i] &gt;&gt; v[i];
    }
    int f[t + 10];
    memset(f, 0, sizeof(f));
    for (int i = 1; i &lt;= m; i++)
    {
        for (int j = t; j &gt;= a[i]; j--)
        {
            f[j] = max(f[j], f[j - a[i]] + v[i]);
        }
    }
    cout &lt;&lt; f[t] &lt;&lt; endl;
    return 0;
}</code></pre><p>附：<a href="https://www.luogu.org/blog/lenfrey/post-ti-xie-p1048-cai-yao">一位神犇提供的题解，感觉比较易懂</a></p><h2>P1020（最大上升子序列）</h2><p>题目：<a href="https://www.luogu.com.cn/problem/P1020">https://www.luogu.com.cn/problem/P1020</a></p><p>第二问知道是求最大上升序列之后就很简单了，最大的问题在于为什么是求这个。试给出以下解释（严格证明需要组合数学的知识）：对于给出的序列（输入数据），必定存在至少一个的最大上升子序列。任取一个最大上升子序列，其中任两个元素（导弹）必定由两套不同系统进行拦截。意味着如果最大上升子序列长度为 n，我们最少需要的系统数目必定大于或等于 n。<br>接下来可以用数学归纳法去解释为什么当最大上升子序列长度为 n 时最少只需要 n 套系统。<br>当 n = 1 时，给出的序列（输入数据）是单调递减的，显然只需要一套系统，结论成立。<br>假设 n = k 时结论成立。也就是只需要 k 套系统。当 n = k + 1 时，试将给出的序列一分为二分别求解，具体方法如下：枚举出所有的最大上升子序列，将每个最大上升子序列的尾元素分别取出。如果某个数是多个最大上升子序列的尾元素则只取出一次。将取出的数按照原本的先后顺序排列生成一个新的序列（假设叫序列 1）。未取出的数也按照原来的先后顺序排列形成另一个新的序列（假设叫序列 2）。<br>此时序列 2 的最大上升子序列长度必定为 k，那么根据前面的假设，需要 k 套系统。而序列 1 是单调递减的（可用反证法证明），由已知需要 1 套系统。所以加起来就是 k + 1 套系统。因为 k + 1 套系统可以拦截所有导弹，而由已知，需要配备的系统数需要大于等于 k + 1，所以 n = k + 1 时结论也成立。</p><p>100 分代码（n 方算法）</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

int a[100005], num = 1;
int ans[100005];
int main()
{
    while (cin &gt;&gt; a[num])
        num++;
    num--;
    a[0] = 50001;
    int maxans = 0;
    for (int i = 1; i &lt;= num; i++)
    {
        for (int j = 0; j &lt; i; j++)
        {
            if (a[i] &lt;= a[j])
            {
                // cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot; &lt;&lt; ans[j] + 1 &lt;&lt; endl;
                ans[i] = max(ans[i], ans[j] + 1);
            }
        }
        // cout &lt;&lt; ans[i] &lt;&lt; endl;
        if (ans[i] &gt; maxans)
            maxans = ans[i];
    }
    cout &lt;&lt; maxans &lt;&lt; endl;

    memset(ans,0,sizeof(ans));
    maxans = 0;
    a[0] = 0;
    for (int i = 1; i &lt;= num; i++)
    {
        for (int j = 0; j &lt; i; j++)
        {
            if (a[i] &gt; a[j])
            {
                // cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot; &lt;&lt; ans[j] + 1 &lt;&lt; endl;
                ans[i] = max(ans[i], ans[j] + 1);
            }
        }
        // cout &lt;&lt; ans[i] &lt;&lt; endl;
        if (ans[i] &gt; maxans)
            maxans = ans[i];
    }
    cout &lt;&lt; maxans &lt;&lt; endl;
    return 0;
}</code></pre><p>200 分代码（nlogn 算法）</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int a[100010], b[100010];
int num = 0, p, ans;

bool cmp(int a, int b)
{
    return a &gt; b;
}

int main()
{
    while (cin &gt;&gt; a[num])
        num++;

    ans = 1;
    b[0] = a[0];
    for (int i = 1; i &lt; num; i++)
    {
        if (a[i] &lt;= b[ans - 1]){
            b[ans] = a[i];
            ans++;
        }
        else
        {
            p = upper_bound(b, b + ans, a[i], cmp) - b;
            b[p] = a[i];
        }
    }
    // for (int i = 0; i &lt; ans; i++)
    // {
    //     cout &lt;&lt; b[i] &lt;&lt; &quot; &quot;;
    // }
    // cout &lt;&lt; endl;
    cout &lt;&lt; ans &lt;&lt; endl;

    ans = 1;
    b[0] = a[0];
    for (int i = 1; i &lt; num; i++)
    {
        if (a[i] &gt; b[ans - 1]){
            b[ans] = a[i];
            ans++;
        }
        else
        {
            p = lower_bound(b, b + ans, a[i]) - b;
            b[p] = a[i];
        }
    }
    // for (int i = 0; i &lt; ans; i++)
    // {
    //     cout &lt;&lt; b[i] &lt;&lt; &quot; &quot;;
    // }
    // cout &lt;&lt; endl;
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}</code></pre>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://static.bobby285271.top/index.php/2019/11/17/Dynamic-Prgramming---0-1-Backpack-Problem-Luogu-P1164-P1048-P1020.html#comments</comments>
<wfw:commentRss>https://static.bobby285271.top/index.php/feed/2019/11/17/Dynamic-Prgramming---0-1-Backpack-Problem-Luogu-P1164-P1048-P1020.html</wfw:commentRss>
</item>
</channel>
</rss>