<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
xmlns:content="http://purl.org/rss/1.0/modules/content/"
xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
xmlns:atom="http://www.w3.org/2005/Atom"
xmlns:wfw="http://wellformedweb.org/CommentAPI/">
<channel>
<title>Dasyatis - Tree</title>
<link>https://static.bobby285271.top/index.php/tag/Tree/</link>
<atom:link href="https://static.bobby285271.top/index.php/feed/tag/Tree/" rel="self" type="application/rss+xml" />
<language>zh-CN</language>
<description></description>
<lastBuildDate>Thu, 26 Dec 2019 09:22:00 +0000</lastBuildDate>
<pubDate>Thu, 26 Dec 2019 09:22:00 +0000</pubDate>
<item>
<title>Dynamic Programming on Tree Structures (Luogu P2014)</title>
<link>https://static.bobby285271.top/index.php/2019/12/26/Dynamic-Programming-on-Tree-Structures-Luogu-P2014.html</link>
<guid>https://static.bobby285271.top/index.php/2019/12/26/Dynamic-Programming-on-Tree-Structures-Luogu-P2014.html</guid>
<pubDate>Thu, 26 Dec 2019 09:22:00 +0000</pubDate>
<dc:creator>Bobby Rong</dc:creator>
<description><![CDATA[题目https://www.luogu.com.cn/problem/P2014思路以下内容仅为个人理解，可能存在错误。树的孩子兄弟表示法想要使用孩子兄弟表示法储存上面这样的一棵树，我们就要从根...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<h2>题目</h2><p><a href="https://www.luogu.com.cn/problem/P2014">https://www.luogu.com.cn/problem/P2014</a></p><h2>思路</h2><blockquote>以下内容<strong>仅为个人理解，可能存在错误</strong>。</blockquote><h3>树的孩子兄弟表示法</h3><p><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/p2014-2.gif" alt="" title=""></p><p>想要使用孩子兄弟表示法储存上面这样的一棵树，我们就要从根节点开始，依次用链表存储各个节点的孩子节点和兄弟节点。因此，该链表中的节点应包含以下三部分内容：</p><ul><li>节点的值。</li><li>指向孩子节点的指针。</li><li>指向兄弟节点的指针。</li></ul><p><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/p2014-1.gif" alt="" title=""></p><p>在这里，每个节点是一门课程，孩子节点其实就是后续课程，兄弟节点其实就是前导课程相同的一门课程。不妨将第 i 门课程编号为 i，那么每一门课都会有一个独一无二的课程编号。这个课程编号本应放在数据域，但是考虑到它的独一无二性和连续性，也方便我们查找某一课程的「后续课程」和「前导课程相同的一门课程」的课程编号，以获取它的学分，我们不妨直接用数组下标来储存这个，就不开数据域了。</p><h3>树形动归</h3><blockquote><strong>TODO</strong>：此部分自认为没有理解透彻，下面给出的思路也不够自然。</blockquote><p>考虑之前发过的几道题，LXY 点菜，我们逐道菜过目；上山采药，我们逐件药品过目。这里我们照葫芦画瓢，就逐门课过目。树形动归和线性动归又有些啥不同呢？首先要遵循从最简单的子问题开始，逐步扩大子问题规模的原则，从子树上动归，最后进行合并。如何体现合并这一操作呢？就是在过目某一节点（课程）的时候同时考虑这个节点（课程）的后续课程。</p><p>不妨就将根节点（假设其编号为 now）的所有孩子过目完，假设现在过目了 a 门课程，选择了 b 门课程。对于这个第 a 门课程依然是两个选择，<strong>选和不选</strong>。不选的话和我过目 a - 1 门课程，选择了 b 门课程效果是一样的，而第 a 门课程我不选自然就拿不了学分，其后续课程我也选不了就无需考虑了。但如果我选择呢，我不但选了第 a 门课程，而且还要考虑它的后续课程。假设已知我过目完 a - 1 门课程时，选择了 b - c 门课程。过目第 a 门课程显然我就考虑了第 a 门课的后续课程并选择了 c 门课程（包含 a）。此时为了求出过目了 a 门课程，选择了 b 门课程的最大学分，我就要求出过目 a - 1 门课程，选择了 b - c 门课程的最大学分和考虑了第 a 门课的<strong>所有</strong>后续课程并选择了 c 门课程（包含 a）的最大学分。而由于我们从子树开始动归，所以后者我们是已经求出过的。考虑完选和不选两种情况后，取最大值即可。</p><p>假设 <code>son</code> 是 <code>now</code> 的一个子节点，有：</p><pre><code class="lang-cpp">f[now][i][j] = max(f[now][i - 1][j], f[son][所有节点数][k] + f[now][i - 1][j - k]);</code></pre><p>和线性动态规划一样，由于过目了 i 门课程的情况永远由过目 i - 1 门课程的情况推出来，于是这一维可以被去掉。</p><pre><code class="lang-cpp">f[now][j] = max(f[now][j], f[son][k] + f[now][j - k]);</code></pre><h2>AC 代码</h2><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
//n、m 如题所述，f[i][j] 表示 i 为子树的根节点，在子树中选 j 门课的最大学分
int n, m, f[1000][1000], fa;
struct node //用结构体储存节点信息
{
    int pre, to; //pre 为兄弟节点在数组 e 中的下标，to 为孩子节点在数组 e 中的下标
} e[1000];       //考虑到课程编号的唯一性，这题 e 数组下标可用来表示课程编号，我们也不用开数据域了

void dp(int now) //在「根节点编号为 now 的树」中动归
{
    //遍历 now 的所有孩子节点，也就是先访问 now 的「第一个」儿子节点，然后再访问这个儿子节点的兄弟节点
    for (int i = e[now].to; i != 0; i = e[i].pre)
    {
        dp(i);                           //在「根节点编号为 i 的树」中动归
        for (int j = m + 1; j &gt;= 1; j--) //关于为什么要反向遍历，前面的文章有提及
        {
            for (int k = 0; k &lt; j; k++)
                f[now][j] = max(f[now][j], f[i][k] + f[now][j - k]); //状态转移方程
        }
    }
}
int main()
{
    ios::sync_with_stdio(false); //是输入输出挂
    cin.tie(0);                  //还是输入输出挂
    cout.tie(0);                 //依然是输入输出挂
    cin &gt;&gt; n &gt;&gt; m;
    //我们令 i 为节点（课程）的编号
    //不妨假定存在一门编号为 0 的课，是所有课程的先修课程且学分为 0
    //这样子我们就可以将所有的课程标在一棵树上
    for (int i = 1; i &lt;= n; i++) //接下来我们从 i = 1 开始读入 n 个节点（课程）
    {
        cin &gt;&gt; fa;           //fa 是节点 i 的父节点（先修课程）的编号
        cin &gt;&gt; f[i][1];      //显然 j == 1 时最大学分就是编号为 i 的这门课本身的学分
        e[i].pre = e[fa].to; //指明节点 i 的兄弟节点是节点 fa 的「第一个」儿子节点
        e[fa].to = i;        //更新节点 fa 的「第一个」儿子节点为节点 i
    }
    dp(0); //从编号为 0 的根节点开始动归
    //输出 0 为根节点，选 m + 1 门课的最大学分
    //m + 1 门课是因为我们无中生有了一门「所有课程的先修课」，也就是编号为 0 的这门课
    cout &lt;&lt; f[0][m + 1] &lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://static.bobby285271.top/index.php/2019/12/26/Dynamic-Programming-on-Tree-Structures-Luogu-P2014.html#comments</comments>
<wfw:commentRss>https://static.bobby285271.top/index.php/feed/2019/12/26/Dynamic-Programming-on-Tree-Structures-Luogu-P2014.html</wfw:commentRss>
</item>
<item>
<title>Introduction to Segment Tree (Luogu P3372)</title>
<link>https://static.bobby285271.top/index.php/2019/12/18/Introduction-to-Segment-Tree-Luogu-P3372.html</link>
<guid>https://static.bobby285271.top/index.php/2019/12/18/Introduction-to-Segment-Tree-Luogu-P3372.html</guid>
<pubDate>Wed, 18 Dec 2019 15:35:00 +0000</pubDate>
<dc:creator>Bobby Rong</dc:creator>
<description><![CDATA[SCNUACM 新生赛的 C 题被我用 N 方算法水过去了，很惭愧，还是想了解一下正解。当然了，一切的基础，就是熟悉相关的模板咯！题目https://www.luogu.com.cn/probl...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>SCNUACM 新生赛的 C 题被我用 N 方算法水过去了，很惭愧，还是想了解一下正解。当然了，一切的基础，就是熟悉相关的模板咯！</p><h2>题目</h2><p><a href="https://www.luogu.com.cn/problem/P3372">https://www.luogu.com.cn/problem/P3372</a></p><h2>思路</h2><blockquote>以下内容<strong>仅为个人理解，可能存在错误</strong>。</blockquote><p>显然，对给出的区间中的每一个数逐个加 k（操作 1）或者一个一个数累加下去来求和（操作 2）是会超时的。我们先抛开操作 1 不谈，试想一下对于操作 2，如果我们可以把这个区间分成几个小块，然后又事先知道每一小块中的元素求和的结果，那我求和的时候是不是就不需要算那么多项呢？是不是也就快一点呢？于是就有了分块思想。如果我们把这个思想给贯彻地彻底一些，事先将几个小块拼在一起形成一个大块，又事先算出每一大块中的元素求和的结果，会不会再更快一些呢？以此类推，树形结构就被我们构建出来了。事实上，线段树就是一种二叉树（但不一定是完全二叉树，下面配图就是一个反例，感谢 CGY 提醒）。它的每一个子节点都表示整个序列中的一段子区间，每个叶子节点都表示序列中的单个元素信息，父节点整合了他的每一个子节点的信息。</p><blockquote>有人会问既然是求和，直接前缀和不就好了吗。刚开始我也是这样想的，果然后来我就看到了树状数组的模板，后面也会去试一下。但是上面这个思路可以处理更多的情况，例如我求个最大值最小值我也可以应用。</blockquote><p>假设我的序列已经读入完毕并储存到数组 a 了（这个简单）：</p><pre><code class="lang-cpp">long long a[maxn + 2];
long long n, m;
scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);
for (long long i = 1; i &lt;= n; i++)
    scanf(&quot;%lld&quot;, &amp;a[i]);</code></pre><p>虽然说不一定是完全二叉数，但是可以用<strong>类似于</strong>创建完全二叉树的方式来创建线段树。首先，考虑单个节点。我们使用一个结构体来储存节点的信息，<code>l</code> 和 <code>r</code> 是这个节点维护的区间范围，<code>sum</code> 储存这个区间的和（也就是说 <code>sum</code> 储存了从 <code>a[l]</code> 到 <code>a[r]</code> 所有元素的和）。这里不妨结合图来理解（转载自洛谷）：</p><p><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/xianduanshu.png" alt="" title=""></p><p>接下来我们考虑整棵数。我们使用数组 t 存这颗树，用数组 t 的下标表示每个节点的编号。为什么数组要开数据量的四倍呢，可以通过计算树的高度，然后用等比数列求和公式得出。</p><pre><code class="lang-cpp">struct tree
{
    long long l, r;
    long long sum;
} t[4 * maxn + 2];</code></pre><p>接下来我们就开始建树。自然要从根开始一层一层地建下去。我们整一个建树函数，考虑向它传入三个参数，其中 <code>p</code> 是该节点的编号（其实就是数组 t 的下标），<code>l</code> 和 <code>r</code> 是这个节点维护的区间范围。</p><pre><code class="lang-cpp">void build(long long p, long long l, long long r);</code></pre><p>我们把这个节点建好了之后就去建它的左右儿子两个节点，显然它们的编号是 <code>p * 2</code> 和 <code>p * 2 + 1</code>（还是数组 t 的下标），这两个子节点维护的区间范围自然就要减半了。我们假设 <code>mid = (l + r) / 2</code>，那么就让左儿子维护 <code>l</code> 到 <code>mid</code>，右儿子维护 <code>mid + 1</code> 到 <code>r</code>。</p><p>当然，我们不可能一直建下去，当 <code>l == r</code> 的时候这个节点只维护一个元素，这个元素正正是 <code>a[l]</code>（或者 <code>a[r]</code>）。这时就可以开始求 <code>sum</code> 而无需再往下建树了。你会发现 <code>t[p].sum = a[l];</code>，<code>p</code> 依然是这个节点本身的编号。那么那些 <code>l != r</code> 的节点又怎样计算 <code>sum</code> 呢？就利用上面所说的思想，直接把两个子节点的 <code>sum</code> 加在一起就是自己的 <code>sum</code> 了。</p><pre><code class="lang-cpp">void build(long long p, long long l, long long r)
{
    t[p].l = l;
    t[p].r = r;
    if (l == r)
    {
        t[p].sum = a[l];
        return;
    }
    long long mid = (l + r) / 2;
    build(p * 2, l, mid);
    build(p * 2 + 1, mid + 1, r);
    t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;
}</code></pre><p>让我们在 main 函数中调用这个函数，我们让根节点的编号为 1，按照题意根节点维护的区间范围自然是 <code>l</code> 到 <code>n</code>：</p><pre><code class="lang-cpp">build(1, 1, n);</code></pre><p>好了我们现在再来考虑一下操作 1，操作 1 是否也可以应用类似的思想呢？我们很容易想到一种看起来很简单的方法。同样是将序列分成一个一个的小块，我们直接给整个小块打上一个标签，告诉大家「这个小块里面的元素都应该被加上 k」。而小块中的元素我就干脆不碰它了。于是<strong>懒标签</strong>也就有了。我们在结构体中添加一 <code>lazy</code>，用作这个「标签」。</p><pre><code class="lang-cpp">struct tree
{
    long long l, r;
    long long sum, lazy;
} t[4 * maxn + 2];</code></pre><p>假设我现在让 <code>x</code> 到 <code>y</code> 这个区间的所有元素全部加 z。根据分块思想，我可以拆分这个区间为几个小的区间，使这些小区间的 <code>sum</code> 我都在建树的时候提前算过。我假设其中一个小的区间，也就是刚才建好的树的其中一个节点（假设它的编号为 p）维护的区间范围为 <code>t[p].r</code> 到 <code>t[p].l</code>。我们准备一个函数来处理这件事：</p><pre><code class="lang-cpp">void change(long long p, long long x, long long y, long long z);</code></pre><p>我们直接对 <code>sum</code> 加上「元素个数」个 z，然后打上标签，声明 <code>t[p].r</code> 到 <code>t[p].l</code> 中所有数都应该被加上 z。</p><pre><code class="lang-cpp">t[p].sum += z * (t[p].r - t[p].l + 1);
t[p].lazy += z;</code></pre><p>但是问题也来了，如何正确地<strong>拆分给定区间为几个小的区间</strong>呢。显然我们要让这些<strong>小的区间</strong>的数量尽量少，一个简单粗暴的方法就是：既然我们有一棵树，树上每个节点都有标明它维护的区间范围，我们就从这棵树的根开始，从上往下枚举这些区间，只到找到合适的区间。何为合适？</p><pre><code class="lang-cpp">if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
{
    t[p].sum += z * (t[p].r - t[p].l + 1);
    t[p].lazy += z;
}</code></pre><p>如果条件满足，我们就成功地找到了一个<strong>小的区间</strong>。如果条件不满足，我们还需要继续寻找其它的<strong>小的区间</strong>直到这些小区间拼起来正好是给定的区间。显然一个节点的左儿子和右儿子如果都是上面所说的<strong>合适的</strong>小区间，那么<strong>小的区间</strong>的数量就不是最小了，因为这个节点本身也必然是合适的。于是我们直接考虑下一层的节点。</p><pre><code class="lang-cpp">long long mid = (t[p].l + t[p].r) / 2;
if (x &lt;= mid)
    change(p * 2, x, y, z);
if (y &gt; mid)
    change(p * 2 + 1, x, y, z);</code></pre><p>要注意的是，当子节点的 <code>sum</code> 被改变了，要及时地将变更传递回来。</p><pre><code class="lang-cpp">t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;</code></pre><p>按理来说这个 change 函数我们基本就实现出来了。但是有一个非常坑的地方，就是如果我连续进行多个操作 1，在第一个操作 1 时，我的 <code>t[p].sum</code> 恰好是一个合适的小区间，被修改了，但是 <code>t[p * 2].sum</code> 和 <code>t[p * 2 + 1].sum</code> 是没有变动的，因为变更都被拦截在 <code>t[p].lazy</code> 那里了。在第二个操作 1 时，<code>t[p].sum</code> 可能不是一个合适的小区间，但 <code>t[p * 2].sum</code> 是。<code>t[p * 2].sum</code> 被修改了，而且通过上面这一行代码传了回去。试想一下 <code>t[p].sum</code> 的值是不是会出现错误呢？于是在必要的时候，懒标记储存的更改还是得下放下去。那懒标记存在的意义到底在哪里？要知道的是我下放懒标记仅仅是因为 <code>t[p].sum</code> 不是一个合适的小区间。如果它是的话，这个懒标记还是可以节约时间的。</p><p>懒标记的下放很简单，就是将左右儿子的 <code>sum</code> 和 <code>lazy</code> 给改过来，<strong>把自己的懒标记归零</strong>：</p><pre><code class="lang-cpp">void spread(long long p)
{
    if (t[p].lazy)
    {
        t[p * 2].sum += t[p].lazy * (t[p * 2].r - t[p * 2].l + 1);
        t[p * 2 + 1].sum += t[p].lazy * (t[p * 2 + 1].r - t[p * 2 + 1].l + 1);
        t[p * 2].lazy += t[p].lazy;
        t[p * 2 + 1].lazy += t[p].lazy;
        t[p].lazy = 0;
    }
}</code></pre><p>这样子我们的 change 函数也就完成了！</p><pre><code class="lang-cpp">void change(long long p, long long x, long long y, long long z)
{
    if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
    {
        t[p].sum += z * (t[p].r - t[p].l + 1);
        t[p].lazy += z;
        return;
    }
    spread(p);
    long long mid = (t[p].l + t[p].r) / 2;
    if (x &lt;= mid)
        change(p * 2, x, y, z);
    if (y &gt; mid)
        change(p * 2 + 1, x, y, z);
    t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;
}</code></pre><p>我们回到开头，我们希望让 <code>x</code> 到 <code>y</code> 这个区间的所有元素全部加 z，那么我们来调用这个函数。要让这些<strong>小的区间</strong>的数量尽量少，我们从树根开始查找：</p><pre><code class="lang-cpp">long long q, x, y, z;
scanf(&quot;%lld&quot;, &amp;q);
if (q == 1)
{
    scanf(&quot;%lld%lld%lld&quot;, &amp;x, &amp;y, &amp;z);
    change(1, x, y, z);
}</code></pre><p>那么如果我想求出给定区间的和，按照上面的思想，同样也是<strong>拆分给定区间为几个小的区间</strong>。我们开一个 <code>ans</code> 变量，当找到合适的小区间时就把它的 <code>sum</code> 给累加进去。其实和 change 函数的实现几乎一样。但要注意的是，如果发现有懒标记没有下放而这个区间又不是一个合适的小区间的时候，还是要下放。不然如果它的左右孩子有一个是合适的小区间，累加进去的 <code>sum</code> 就是错的。</p><pre><code class="lang-cpp">long long ask(long long p, long long x, long long y)
{
    if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
        return t[p].sum;
    spread(p);
    long long mid = (t[p].l + t[p].r) / 2;
    long long ans = 0;
    if (x &lt;= mid)
        ans += ask(p * 2, x, y);
    if (y &gt; mid)
        ans += ask(p * 2 + 1, x, y);
    return ans;
}</code></pre><p>在 main 函数里面调用的时候，还是要从树根开始选取合适的小区间。</p><pre><code class="lang-cpp">long long q, x, y;
scanf(&quot;%lld&quot;, &amp;q);
if (q == 2)
{
    scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
    printf(&quot;%lld\n&quot;, ask(1, x, y));
}</code></pre><h2>AC 代码</h2><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const long long maxn = 100010;
long long a[maxn + 2];
struct tree
{
    long long l, r;
    long long sum, lazy;
} t[4 * maxn + 2];

void build(long long p, long long l, long long r)
{
    t[p].l = l;
    t[p].r = r;
    if (l == r)
    {
        t[p].sum = a[l];
        return;
    }
    long long mid = (l + r) / 2;
    build(p * 2, l, mid);
    build(p * 2 + 1, mid + 1, r);
    t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;
}

void spread(long long p)
{
    if (t[p].lazy)
    {
        t[p * 2].sum += t[p].lazy * (t[p * 2].r - t[p * 2].l + 1);
        t[p * 2 + 1].sum += t[p].lazy * (t[p * 2 + 1].r - t[p * 2 + 1].l + 1);
        t[p * 2].lazy += t[p].lazy;
        t[p * 2 + 1].lazy += t[p].lazy;
        t[p].lazy = 0;
    }
}

void change(long long p, long long x, long long y, long long z)
{
    if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
    {
        t[p].sum += z * (t[p].r - t[p].l + 1);
        t[p].lazy += z;
        return;
    }
    spread(p);
    long long mid = (t[p].l + t[p].r) / 2;
    if (x &lt;= mid)
        change(p * 2, x, y, z);
    if (y &gt; mid)
        change(p * 2 + 1, x, y, z);
    t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;
}

long long ask(long long p, long long x, long long y)
{
    if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
        return t[p].sum;
    spread(p);
    long long mid = (t[p].l + t[p].r) / 2;
    long long ans = 0;
    if (x &lt;= mid)
        ans += ask(p * 2, x, y);
    if (y &gt; mid)
        ans += ask(p * 2 + 1, x, y);
    return ans;
}

int main()
{
    long long n, m;
    scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);
    for (long long i = 1; i &lt;= n; i++)
        scanf(&quot;%lld&quot;, &amp;a[i]);
    build(1, 1, n);
    for (long long i = 1; i &lt;= m; i++)
    {
        long long q, x, y, z;
        scanf(&quot;%lld&quot;, &amp;q);
        if (q == 1)
        {
            scanf(&quot;%lld%lld%lld&quot;, &amp;x, &amp;y, &amp;z);
            change(1, x, y, z);
        }
        else
        {
            scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
            printf(&quot;%lld\n&quot;,ask(1, x, y));
        }
    }
    return 0;
}</code></pre>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://static.bobby285271.top/index.php/2019/12/18/Introduction-to-Segment-Tree-Luogu-P3372.html#comments</comments>
<wfw:commentRss>https://static.bobby285271.top/index.php/feed/2019/12/18/Introduction-to-Segment-Tree-Luogu-P3372.html</wfw:commentRss>
</item>
</channel>
</rss>