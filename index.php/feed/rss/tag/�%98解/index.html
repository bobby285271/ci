<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://static.bobby285271.top/index.php/feed/rss/tag/%E9%A2%98%E8%A7%A3/">
<title>Dasyatis - 题解</title>
<link>https://static.bobby285271.top/index.php/tag/题解/</link>
<description></description>
<items>
<rdf:Seq>
<rdf:li resource="https://static.bobby285271.top/index.php/2019/12/18/segment-tree.html"/>
<rdf:li resource="https://static.bobby285271.top/index.php/2019/11/17/dynamic-prgramming-01-backpack-problem.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://static.bobby285271.top/index.php/2019/12/18/segment-tree.html">
<title>线段树 - 区间操作与查询（洛谷 P3372）</title>
<link>https://static.bobby285271.top/index.php/2019/12/18/segment-tree.html</link>
<dc:date>2019-12-18T15:35:00+00:00</dc:date>
<description>SCNUACM 新生赛的 C 题被我用 N 方算法水过去了，很惭愧，还是想了解一下正解。当然了，一切的基础，就是熟悉相关的模板咯！题目https://www.luogu.com.cn/problem/P3372思路以下内容仅为个人理解，可能存在错误。显然，对给出的区间中的每一个数逐个加 k（操作 1）或者一个一个数累加下去来求和（操作 2）是会超时的。我们先抛开操作 1 不谈，试想一下对于操作 2，如果我们可以把这个区间分成几个小块，然后又事先知道每一小块中的元素求和的结果，那我求和的时候是不是就不需要算那么多项呢？是不是也就快一点呢？于是就有了分块思想。如果我们把这个思想给贯彻地彻底一些，事先将几个小块拼在一起形成一个大块，又事先算出每一大块中的元素求和的结果，会不会再更快一些呢？以此类推，树形结构就被我们构建出来了。事实上，线段树就是一种二叉树（但不一定是完全二叉树，下面配图就是一个反例，感谢 CGY 提醒）。它的每一个子节点都表示整个序列中的一段子区间，每个叶子节点都表示序列中的单个元素信息，父节点整合了他的每一个子节点的信息。有人会问既然是求和，直接前缀和不就好了吗。刚开始我也是这样想的，果然后来我就看到了树状数组的模板，后面也会去试一下。但是上面这个思路可以处理更多的情况，例如我求个最大值最小值我也可以应用。假设我的序列已经读入完毕并储存到数组 a 了（这个简单）：long long a[maxn + 2];
long long n, m;
scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);
for (long long i = 1; i &lt;= n; i++)
    scanf(&quot;%lld&quot;, &amp;a[i]);虽然说不一定是完全二叉数，但是可以用类似于创建完全二叉树的方式来创建线段树。首先，考虑单个节点。我们使用一个结构体来储存节点的信息，l 和 r 是这个节点维护的区间范围，sum 储存这个区间的和（也就是说 sum 储存了从 a[l] 到 a[r] 所有元素的和）。这里不妨结合图来理解（转载自洛谷）：接下来我们考虑整棵数。我们使用数组 t 存这颗树，用数组 t 的下标表示每个节点的编号。为什么数组要开数据量的四倍呢，可以通过计算树的高度，然后用等比数列求和公式得出。struct tree
{
    long long l, r;
    long long sum;
} t[4 * maxn + 2];接下来我们就开始建树。自然要从根开始一层一层地建下去。我们整一个建树函数，考虑向它传入三个参数，其中 p 是该节点的编号（其实就是数组 t 的下标），l 和 r 是这个节点维护的区间范围。void build(long long p, long long l, long long r);我们把这个节点建好了之后就去建它的左右儿子两个节点，显然它们的编号是 p * 2 和 p * 2 + 1（还是数组 t 的下标），这两个子节点维护的区间范围自然就要减半了。我们假设 mid = (l + r) / 2，那么就让左儿子维护 l 到 mid，右儿子维护 mid + 1 到 r。当然，我们不可能一直建下去，当 l == r 的时候这个节点只维护一个元素，这个元素正正是 a[l]（或者 a[r]）。这时就可以开始求 sum 而无需再往下建树了。你会发现 t[p].sum = a[l];，p 依然是这个节点本身的编号。那么那些 l != r 的节点又怎样计算 sum 呢？就利用上面所说的思想，直接把两个子节点的 sum 加在一起就是自己的 sum 了。void build(long long p, long long l, long long r)
{
    t[p].l = l;
    t[p].r = r;
    if (l == r)
    {
        t[p].sum = a[l];
        return;
    }
    long long mid = (l + r) / 2;
    build(p * 2, l, mid);
    build(p * 2 + 1, mid + 1, r);
    t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;
}让我们在 main 函数中调用这个函数，我们让根节点的编号为 1，按照题意根节点维护的区间范围自然是 l 到 n：build(1, 1, n);好了我们现在再来考虑一下操作 1，操作 1 是否也可以应用类似的思想呢？我们很容易想到一种看起来很简单的方法。同样是将序列分成一个一个的小块，我们直接给整个小块打上一个标签，告诉大家「这个小块里面的元素都应该被加上 k」。而小块中的元素我就干脆不碰它了。于是懒标签也就有了。我们在结构体中添加一 lazy，用作这个「标签」。struct tree
{
    long long l, r;
    long long sum, lazy;
} t[4 * maxn + 2];假设我现在让 x 到 y 这个区间的所有元素全部加 z。根据分块思想，我可以拆分这个区间为几个小的区间，使这些小区间的 sum 我都在建树的时候提前算过。我假设其中一个小的区间，也就是刚才建好的树的其中一个节点（假设它的编号为 p）维护的区间范围为 t[p].r 到 t[p].l。我们准备一个函数来处理这件事：void change(long long p, long long x, long long y, long long z);我们直接对 sum 加上「元素个数」个 z，然后打上标签，声明 t[p].r 到 t[p].l 中所有数都应该被加上 z。t[p].sum += z * (t[p].r - t[p].l + 1);
t[p].lazy += z;但是问题也来了，如何正确地拆分给定区间为几个小的区间呢。显然我们要让这些小的区间的数量尽量少，一个简单粗暴的方法就是：既然我们有一棵树，树上每个节点都有标明它维护的区间范围，我们就从这棵树的根开始，从上往下枚举这些区间，只到找到合适的区间。何为合适？if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
{
    t[p].sum += z * (t[p].r - t[p].l + 1);
    t[p].lazy += z;
}如果条件满足，我们就成功地找到了一个小的区间。如果条件不满足，我们还需要继续寻找其它的小的区间直到这些小区间拼起来正好是给定的区间。显然一个节点的左儿子和右儿子如果都是上面所说的合适的小区间，那么小的区间的数量就不是最小了，因为这个节点本身也必然是合适的。于是我们直接考虑下一层的节点。long long mid = (t[p].l + t[p].r) / 2;
if (x &lt;= mid)
    change(p * 2, x, y, z);
if (y &gt; mid)
    change(p * 2 + 1, x, y, z);要注意的是，当子节点的 sum 被改变了，要及时地将变更传递回来。t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;按理来说这个 change 函数我们基本就实现出来了。但是有一个非常坑的地方，就是如果我连续进行多个操作 1，在第一个操作 1 时，我的 t[p].sum 恰好是一个合适的小区间，被修改了，但是 t[p * 2].sum 和 t[p * 2 + 1].sum 是没有变动的，因为变更都被拦截在 t[p].lazy 那里了。在第二个操作 1 时，t[p].sum 可能不是一个合适的小区间，但 t[p * 2].sum 是。t[p * 2].sum 被修改了，而且通过上面这一行代码传了回去。试想一下 t[p].sum 的值是不是会出现错误呢？于是在必要的时候，懒标记储存的更改还是得下放下去。那懒标记存在的意义到底在哪里？要知道的是我下放懒标记仅仅是因为 t[p].sum 不是一个合适的小区间。如果它是的话，这个懒标记还是可以节约时间的。懒标记的下放很简单，就是将左右儿子的 sum 和 lazy 给改过来，把自己的懒标记归零：void spread(long long p)
{
    if (t[p].lazy)
    {
        t[p * 2].sum += t[p].lazy * (t[p * 2].r - t[p * 2].l + 1);
        t[p * 2 + 1].sum += t[p].lazy * (t[p * 2 + 1].r - t[p * 2 + 1].l + 1);
        t[p * 2].lazy += t[p].lazy;
        t[p * 2 + 1].lazy += t[p].lazy;
        t[p].lazy = 0;
    }
}这样子我们的 change 函数也就完成了！void change(long long p, long long x, long long y, long long z)
{
    if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
    {
        t[p].sum += z * (t[p].r - t[p].l + 1);
        t[p].lazy += z;
        return;
    }
    spread(p);
    long long mid = (t[p].l + t[p].r) / 2;
    if (x &lt;= mid)
        change(p * 2, x, y, z);
    if (y &gt; mid)
        change(p * 2 + 1, x, y, z);
    t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;
}我们回到开头，我们希望让 x 到 y 这个区间的所有元素全部加 z，那么我们来调用这个函数。要让这些小的区间的数量尽量少，我们从树根开始查找：long long q, x, y, z;
scanf(&quot;%lld&quot;, &amp;q);
if (q == 1)
{
    scanf(&quot;%lld%lld%lld&quot;, &amp;x, &amp;y, &amp;z);
    change(1, x, y, z);
}那么如果我想求出给定区间的和，按照上面的思想，同样也是拆分给定区间为几个小的区间。我们开一个 ans 变量，当找到合适的小区间时就把它的 sum 给累加进去。其实和 change 函数的实现几乎一样。但要注意的是，如果发现有懒标记没有下放而这个区间又不是一个合适的小区间的时候，还是要下放。不然如果它的左右孩子有一个是合适的小区间，累加进去的 sum 就是错的。long long ask(long long p, long long x, long long y)
{
    if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
        return t[p].sum;
    spread(p);
    long long mid = (t[p].l + t[p].r) / 2;
    long long ans = 0;
    if (x &lt;= mid)
        ans += ask(p * 2, x, y);
    if (y &gt; mid)
        ans += ask(p * 2 + 1, x, y);
    return ans;
}在 main 函数里面调用的时候，还是要从树根开始选取合适的小区间。long long q, x, y;
scanf(&quot;%lld&quot;, &amp;q);
if (q == 2)
{
    scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
    printf(&quot;%lld\n&quot;, ask(1, x, y));
}AC 代码#include &lt;bits/stdc++.h&gt;
using namespace std;
const long long maxn = 100010;
long long a[maxn + 2];
struct tree
{
    long long l, r;
    long long sum, lazy;
} t[4 * maxn + 2];

void build(long long p, long long l, long long r)
{
    t[p].l = l;
    t[p].r = r;
    if (l == r)
    {
        t[p].sum = a[l];
        return;
    }
    long long mid = (l + r) / 2;
    build(p * 2, l, mid);
    build(p * 2 + 1, mid + 1, r);
    t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;
}

void spread(long long p)
{
    if (t[p].lazy)
    {
        t[p * 2].sum += t[p].lazy * (t[p * 2].r - t[p * 2].l + 1);
        t[p * 2 + 1].sum += t[p].lazy * (t[p * 2 + 1].r - t[p * 2 + 1].l + 1);
        t[p * 2].lazy += t[p].lazy;
        t[p * 2 + 1].lazy += t[p].lazy;
        t[p].lazy = 0;
    }
}

void change(long long p, long long x, long long y, long long z)
{
    if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
    {
        t[p].sum += z * (t[p].r - t[p].l + 1);
        t[p].lazy += z;
        return;
    }
    spread(p);
    long long mid = (t[p].l + t[p].r) / 2;
    if (x &lt;= mid)
        change(p * 2, x, y, z);
    if (y &gt; mid)
        change(p * 2 + 1, x, y, z);
    t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;
}

long long ask(long long p, long long x, long long y)
{
    if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
        return t[p].sum;
    spread(p);
    long long mid = (t[p].l + t[p].r) / 2;
    long long ans = 0;
    if (x &lt;= mid)
        ans += ask(p * 2, x, y);
    if (y &gt; mid)
        ans += ask(p * 2 + 1, x, y);
    return ans;
}

int main()
{
    long long n, m;
    scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);
    for (long long i = 1; i &lt;= n; i++)
        scanf(&quot;%lld&quot;, &amp;a[i]);
    build(1, 1, n);
    for (long long i = 1; i &lt;= m; i++)
    {
        long long q, x, y, z;
        scanf(&quot;%lld&quot;, &amp;q);
        if (q == 1)
        {
            scanf(&quot;%lld%lld%lld&quot;, &amp;x, &amp;y, &amp;z);
            change(1, x, y, z);
        }
        else
        {
            scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
            printf(&quot;%lld\n&quot;,ask(1, x, y));
        }
    }
    return 0;
}</description>
</item>
<item rdf:about="https://static.bobby285271.top/index.php/2019/11/17/dynamic-prgramming-01-backpack-problem.html">
<title>动态规划的 0/1 背包问题（洛谷 P1164、P1048、P1020）</title>
<link>https://static.bobby285271.top/index.php/2019/11/17/dynamic-prgramming-01-backpack-problem.html</link>
<dc:date>2019-11-17T15:29:00+00:00</dc:date>
<description>为啥突然想要看动态规划呢，是因为昨天做了去年蓝桥杯预选赛 16/17 的题，做到 B 题发现正解其实应该是动态规划的。虽然我交了一发贪心过了，但想到两个星期后就是热身赛还是得搞搞突击才行。引入周四香农先修班讲了一个斐波拉契数列的专题，有一个问题是这样的：假设有 n 级楼梯，我从底部往上爬，每次可以上 1 级，也可以上 2 级楼梯，问从底部到顶部一共有多少种爬楼梯的方法。我第一时间想到的是搜索和回溯，但是既然是斐波拉契数列的专题，也就有了 $f(n) = f(n-1) + f(n-2)$ 这个公式。我简单说一下这个式子是怎么来的吧。我们不妨假设我们走了 x 步之后上到了第 n 级，那我第 x-1 步在什么位置呢？只能是第 n-1 和 n-2 级。$f(n-1)$ 是走到 n-1 级楼梯时的方法数，$f(n-2)$ 同理。考虑一下边界情况，就是斐波拉契数列了呗。P1164 -（二维 DP）题目：https://www.luogu.org/problem/P1164不妨就来考虑一下「引入」小节的思路（模拟退火是啥我也不会），我们要求吃够 m 块钱，和爬 n 级楼梯其实是一回事。我上 1 级台阶还是 2 级台阶，其实和对于一道菜，我吃还是不吃是一回事。区别在哪呢，这里我们有很多不同的菜。然而我们也不用想太多，就让它们按顺序逐个上菜好了，然后我们逐个决定是吃还是不吃，顺便记下到底花了多少钱（注意上菜不代表我们就要吃嘛对吧，吃了才花钱）。我们定义 f[i][j] 为上了 i 道菜用光 j 元钱的办法总数。假设我们现在已经上了 i-1 道菜，接下来上第 i 道菜。我们就有两个选择：吃（花钱）。不吃（不花钱）。如果不吃，那我上 i 道菜用光 j 元钱的方法数，和上了 i-1 道菜用光 j 元钱的方法数一样。如果我吃，那我上 i 道菜用光 j 元钱的方法数，和上了 i-1 道菜用光（j-这道菜的价格）的方法数一样。将两种情况和在一起，于是有：f[i][j] = f[i - 1][j] + f[i - 1][j - 第i道菜的价格];通常来讲这就结束了，但是这道菜的价格我们却没有讨论清楚。首先，如果我没钱吃着道菜呢？那就只能不吃了呗。if(j &lt; 第i道菜的价格) f[i][j] = f[i - 1][j];
if(j &gt;= 第i道菜的价格) f[i][j] = f[i - 1][j] + f[i - 1][j - 第i道菜的价格];有些人想问 j == 第i道菜的价格 这种情况怎么搞，我们将这种情况代入到上面的代码，其实就是 f[i][j] = f[i - 1][j] + f[i - 1][0]，f[i - 1][0] 其实就是上了 i-1 个菜我全不吃，消费 0 元嘛，显然只有一种情况。但形如 f[i][0] 的数据又可以从哪推出呢？不如特判一下，当然直接给他们赋值也是可以的：if(j &lt; 第i道菜的价格) f[i][j] = f[i - 1][j];
if(j == 第i道菜的价格) f[i][j] = f[i - 1][j] + 1;
if(j &gt; 第i道菜的价格) f[i][j] = f[i - 1][j] + f[i - 1][j - 第i道菜的价格];既然有了递推式（状态转移方程），我们要的是上完 n 道菜后花掉 m 块钱的方案，那就遍历一下这个数组直到得出答案为止呗。上代码：#include &lt;bits/stdc++.h&gt;
using namespace std;
int a[101], f[101][10001];
int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; i++)
    {
        cin &gt;&gt; a[i];
    }
    for (int i = 1; i &lt;= n; i++)
    {
        for (int j = 1; j &lt;= m; j++)
        {
            if (j &gt; a[i])
                f[i][j] = f[i - 1][j] + f[i - 1][j - a[i]];
            if (j == a[i])
                f[i][j] = f[i - 1][j] + 1;
            if (j &lt; a[i])
                f[i][j] = f[i - 1][j];
        }
    }
    cout &lt;&lt; f[n][m] &lt;&lt; endl;
    return 0;
}P1048（一维 DP）题目：https://www.luogu.org/problem/P1048这道题按照上面的思路打大概是怎样的呢？显然，我们开一个二位数组 f[i][j] 来表示过目 i 件药材（过目意味着我在采摘和不采摘中二选一）耗去 j 时间后的最大价值就可以了。时间如果足够，就考虑一下要不要采摘这个药材。同样地，采摘第 i 件药材耗去 j 时间的这种情况下的最大价值是过目 i-1 件药材时耗去（j-药材采摘时间）时间的最大价值。不采摘第 i 件药材耗去 j 时间的这种情况下的最大价值是过目 i-1 件药材时耗去 j 时间的最大价值。对于两种情况我们取较大者即可。那我们为啥提出希望降维呢？我们看上面的代码：if (j &gt; a[i])
    f[i][j] = f[i - 1][j] + f[i - 1][j - a[i]];
if (j == a[i])
    f[i][j] = f[i - 1][j] + 1;
if (j &lt; a[i])
    f[i][j] = f[i - 1][j];再来看一下这一题的核心代码（a[i] 为采摘时间，v[i] 为药材价值）：if (j &gt;= a[i])
    f[i][j] = max(f[i - 1][j - a[i]] + v[i], f[i - 1][j]);
else
    f[i][j] = f[i - 1][j];第 i 件物品需要求的信息永远是从第 i-1 件物品那里得出来的。如果我们最后只需要第 i 件物品的答案而不需要 i-1、i-2... 件物品的答案，我们为何不用新的信息覆盖旧的信息呢？修改的方法很简单：if (j &gt;= a[i])
    f[j] = max(f[j - a[i]] + v[i], f[j]);
// 下面的没必要保留了吧。
// else
//     f[j] = f[j];虽然降维了，但遍历还是要以上面的方式来，于是我们就得到一个似乎很有道理的代码。for (int i = 1; i &lt;= m; i++)
{
    for (int j = a[i]; j &lt;= t; j++) // 既然上面只有一个分支结构，那我在循环条件那里保证就好了。
    {
        f[j] = max(f[j - a[i]] + v[i], f[j]);
    }
}
cout &lt;&lt; f[t] &lt;&lt; endl;这却是一个非常典型的错误，因为按照原本的意思，第 i 个物品的数据要从 i-1 个物品的数据推出来，但我在上面求第 i 个物品的 f[j] 的时候却使用到了已经更新过的，已经是第 i 个物品的数据 f[j - a[i]]。怎样避免呢：#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int t, m;
    cin &gt;&gt; t &gt;&gt; m;
    int a[m + 10], v[m + 10];
    for (int i = 1; i &lt;= m; i++)
    {
        cin &gt;&gt; a[i] &gt;&gt; v[i];
    }
    int f[t + 10];
    memset(f, 0, sizeof(f));
    for (int i = 1; i &lt;= m; i++)
    {
        for (int j = t; j &gt;= a[i]; j--)
        {
            f[j] = max(f[j], f[j - a[i]] + v[i]);
        }
    }
    cout &lt;&lt; f[t] &lt;&lt; endl;
    return 0;
}附：一位神犇提供的题解，感觉比较易懂P1020（最大上升子序列）题目：https://www.luogu.com.cn/problem/P1020第二问知道是求最大上升序列之后就很简单了，最大的问题在于为什么是求这个。试给出以下解释（严格证明需要组合数学的知识）：对于给出的序列（输入数据），必定存在至少一个的最大上升子序列。任取一个最大上升子序列，其中任两个元素（导弹）必定由两套不同系统进行拦截。意味着如果最大上升子序列长度为 n，我们最少需要的系统数目必定大于或等于 n。接下来可以用数学归纳法去解释为什么当最大上升子序列长度为 n 时最少只需要 n 套系统。当 n = 1 时，给出的序列（输入数据）是单调递减的，显然只需要一套系统，结论成立。假设 n = k 时结论成立。也就是只需要 k 套系统。当 n = k + 1 时，试将给出的序列一分为二分别求解，具体方法如下：枚举出所有的最大上升子序列，将每个最大上升子序列的尾元素分别取出。如果某个数是多个最大上升子序列的尾元素则只取出一次。将取出的数按照原本的先后顺序排列生成一个新的序列（假设叫序列 1）。未取出的数也按照原来的先后顺序排列形成另一个新的序列（假设叫序列 2）。此时序列 2 的最大上升子序列长度必定为 k，那么根据前面的假设，需要 k 套系统。而序列 1 是单调递减的（可用反证法证明），由已知需要 1 套系统。所以加起来就是 k + 1 套系统。因为 k + 1 套系统可以拦截所有导弹，而由已知，需要配备的系统数需要大于等于 k + 1，所以 n = k + 1 时结论也成立。100 分代码（n 方算法）#include &lt;bits/stdc++.h&gt;
using namespace std;

int a[100005], num = 1;
int ans[100005];
int main()
{
    while (cin &gt;&gt; a[num])
        num++;
    num--;
    a[0] = 50001;
    int maxans = 0;
    for (int i = 1; i &lt;= num; i++)
    {
        for (int j = 0; j &lt; i; j++)
        {
            if (a[i] &lt;= a[j])
            {
                // cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot; &lt;&lt; ans[j] + 1 &lt;&lt; endl;
                ans[i] = max(ans[i], ans[j] + 1);
            }
        }
        // cout &lt;&lt; ans[i] &lt;&lt; endl;
        if (ans[i] &gt; maxans)
            maxans = ans[i];
    }
    cout &lt;&lt; maxans &lt;&lt; endl;

    memset(ans,0,sizeof(ans));
    maxans = 0;
    a[0] = 0;
    for (int i = 1; i &lt;= num; i++)
    {
        for (int j = 0; j &lt; i; j++)
        {
            if (a[i] &gt; a[j])
            {
                // cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot; &lt;&lt; ans[j] + 1 &lt;&lt; endl;
                ans[i] = max(ans[i], ans[j] + 1);
            }
        }
        // cout &lt;&lt; ans[i] &lt;&lt; endl;
        if (ans[i] &gt; maxans)
            maxans = ans[i];
    }
    cout &lt;&lt; maxans &lt;&lt; endl;
    return 0;
}200 分代码（nlogn 算法）#include &lt;bits/stdc++.h&gt;
using namespace std;
int a[100010], b[100010];
int num = 0, p, ans;

bool cmp(int a, int b)
{
    return a &gt; b;
}

int main()
{
    while (cin &gt;&gt; a[num])
        num++;

    ans = 1;
    b[0] = a[0];
    for (int i = 1; i &lt; num; i++)
    {
        if (a[i] &lt;= b[ans - 1]){
            b[ans] = a[i];
            ans++;
        }
        else
        {
            p = upper_bound(b, b + ans, a[i], cmp) - b;
            b[p] = a[i];
        }
    }
    // for (int i = 0; i &lt; ans; i++)
    // {
    //     cout &lt;&lt; b[i] &lt;&lt; &quot; &quot;;
    // }
    // cout &lt;&lt; endl;
    cout &lt;&lt; ans &lt;&lt; endl;

    ans = 1;
    b[0] = a[0];
    for (int i = 1; i &lt; num; i++)
    {
        if (a[i] &gt; b[ans - 1]){
            b[ans] = a[i];
            ans++;
        }
        else
        {
            p = lower_bound(b, b + ans, a[i]) - b;
            b[p] = a[i];
        }
    }
    // for (int i = 0; i &lt; ans; i++)
    // {
    //     cout &lt;&lt; b[i] &lt;&lt; &quot; &quot;;
    // }
    // cout &lt;&lt; endl;
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}</description>
</item>
</rdf:RDF>