<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://static.bobby285271.top/index.php/feed/rss/tag/Guide/">
<title>Dasyatis - Guide</title>
<link>https://static.bobby285271.top/index.php/tag/Guide/</link>
<description></description>
<items>
<rdf:Seq>
<rdf:li resource="https://static.bobby285271.top/index.php/2020/07/15/WIP-Introduction-to-Django---Illustrated-by-the-Example-of-SCNUSE-SoCoding-1024-Website.html"/>
<rdf:li resource="https://static.bobby285271.top/index.php/2020/04/15/NixOS-Installation-and-Configuration-Guide.html"/>
<rdf:li resource="https://static.bobby285271.top/index.php/2020/02/03/How-to-Deploy-WordPress-on-a-Fedora-Server-en.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://static.bobby285271.top/index.php/2020/07/15/WIP-Introduction-to-Django---Illustrated-by-the-Example-of-SCNUSE-SoCoding-1024-Website.html">
<title>[WIP] Introduction to Django - Illustrated by the Example of SCNUSE SoCoding 1024 Website</title>
<link>https://static.bobby285271.top/index.php/2020/07/15/WIP-Introduction-to-Django---Illustrated-by-the-Example-of-SCNUSE-SoCoding-1024-Website.html</link>
<dc:date>2020-07-15T12:04:00+00:00</dc:date>
<description>本文尚未完成，正在更新注册页部分，最后更新时间 7 月 18 日中午。好久没有出文章了，放暑假有点时间，尝试再造一遍 2019 年 SCNUSE 软协 1024 程序员节活动网站（尽量还原，会有一些差别），算是 Django 框架的一个学习项目吧。博主本人的基本功也不怎么扎实，下文用到了非常多不严谨的表述，如果有任何错误欢迎指出。要实现什么去年也是参与到这个活动中来了，但是只是做了一个关卡，比较划水。这里就略过需求分析系统设计什么的了，简单来说整个网站做的就是注册登录和七个关卡。去年最后具体实现用到的是 Django 框架，使用 MySQL 数据库，但是这里将使用 SQLite 数据库。铺垫博主认为有一些技能在开始动手之前还是要先掌握的。首先是 Python，其实有了程序设计基础之后 Python 的语法其实很简单。完全不会 Python 的推荐看 Python 100 天教程 前 15 天部分的内容，然后找个 Online Judge 做几道水题，最多两个小时应该都能熟悉。然后是 Web 前端 HTML、CSS、Javascript 的一些最基本的应用，学校讲的足够用了，这里推荐 菜鸟教程，可以尝试自己写一些小的静态网站。最后 Django 本身还是要先做了解的。可以简单浏览 Python 100 天教程 第 14 天和第 41 天的内容，另外也推荐阅读官方推荐的一些 设计理念 。准备先来做一些准备工作，包括开发环境的配置、项目和应用的初始化。开发环境可以按照自己的喜好来配置，不一定要按照这里的来；项目和应用的初始化有对应的具体的命令，执行即可。开发环境要做的事情就是安装一个对 Python 支持良好的 IDE 或者为你的代码编辑器添加 Python 支持，然后安装 Django。假设你跟我一样已经是 Arch Linux + VS Code 用户。VS Code 下的 Python 支持是需要到 pip 的，pip 是 Python 的包管理器，直接使用 Linux 下的包管理器安装。# pacman -S python-pippip 既然是包管理器，能条件反射到的是肯定要换源，我们在家目录创建并编辑 .pip/pip.conf：$ cd 
$ mkdir .pip
$ nano .pip/pip.conf[global]
index-url = https://pypi.tuna.tsinghua.edu.cn/simple启动 VS Code，先装上 Python 扩展和 Visual Studio IntelliCode 扩展，然后打开任意 Python 文件，尝试格式化文档，VS Code 就会提示你安装格式化程序，安装就可。可以观察到实质就是调用 pip 安装 autopep8。接下来安装 Django，这里有两个方法，一个是继续使用 Linux 下的包管理器安装：# pacman -S python-django`或者是用上面刚刚讲到的 pip：$ pip install django要注意的是给 Arch Linux 软件包锁版本是不被提倡的，毕竟是滚动更新发行版。所以如果你使用 Pacman 安装 python-django 就得一直跟着系统走用最新版，要考虑其利弊。接下来尝试使用 django-admin 命令，测试一下是不是一切都准备妥当了：$ django-admin version理想情况是输出一个版本号。如果提示命令没有找到，那就是在普通用户下使用 pip 按照 Django 导致 django-admin 不在 PATH 里。解决方法很多，例如改用 root 安装，或是修改 PATH，可以参考 官方文档。创建项目我们首先使用 django-admin 命令为站点创建一个已经初始化的项目目录，不妨叫 mysite。如果你起的名字跟我的不一样，只要看到 mysite 改过来就行，另外不要用保留字命名，后面也是一样的道理。$ django-admin startproject mysite
$ cd mysite进入项目目录之后，应该能见到另一个 mysite/ 目录和一个 manage.py 文件：mysite/ 包含了 Django 项目实例需要的设置项集合，包括数据库配置、Django 配置和应用配置。manage.py 就是一个让你用各种方式管理 Django 项目的命令行工具。我们约定，后面涉及的所有文件和文件夹均以当前所在的项目目录为基准标注相对路径。创建应用在 Django 中，每一个应用都是一个 Python 包。应用通常是一个专门做某件事的网络应用程序，比如博客系统、投票程序。项目则是一个网站使用的配置和应用的集合。一个项目可以包含很多个应用，但这里我们只创建一个，就叫 myapp：$ python manage.py startapp myapp接下来往项目添加这个应用。编辑 mysite/settings.py，找到 INSTALLED_APPS：这里没有展示整个的完整的文件，只会展示需要改动的代码或是关键的代码，后面也是一样的道理。我们会在文末附上成品的代码，可以结合成品代码理解。INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'myapp',
]站点调试我们可以利用 manage.py 运行 Django 自带的用于开发的简易 Web 服务器对我们的网站进行预览和调试。不要将这个服务器用于和生产环境相关的任何地方，这个服务器只是为了开发而设计的。$ python manage.py runserver终端应该会输出类似这样的东西：Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.按照上面的输出，我们打开浏览器访问 http://127.0.0.1:8000/，在下文中我们假设你的服务器设置和我的一样为监听本机内部 IP 的 8000 端口。在一个网页都没有完成的情况下，你应该能看到 Django 自带的测试页面。当我们写好我们的网站之后则应该能看到自己的网站，测试页面就不会再出现了。现在我们尝试将测试页面改成中文的，其实是为 Django 设置语言。编辑 mysite/settings.py：LANGUAGE_CODE = 'zh-hans'
TIME_ZONE = 'Asia/Shanghai'不必重新启动服务器，直接刷新页面，现在测试页面显示的是中文，你的改动生效了。通常来说服务器会对每一次的访问请求重新载入一遍 Python 代码，但是例外还是有的（如添加新文件）。如果你发现你的改动没有生效，尝试重启服务器就好了。如果你想把服务器停掉，就按照终端的提示按下 Ctrl + C 组合键即可，和 Linux 杀死其它命令的方式是一样的。第一个页面几乎所有教程做第一个页面都是 Hello World，虽然这和 1024 站点没啥关联，我们也先实现一下，目标是访问站点首页后显示一行文字 Hello World。博主认为虽然是 Hello World，但可能还是会有点难度。其实不需要纠结太多，关键是记住具体的实现，知道哪些地方是套路，哪些地方要改动。我们在后面会制作更多的页面，自然就会熟悉了。响应与视图函数视图函数（简称视图）是一个简单的 Python 函数，它接受 Web 请求并且返回 Web 响应。响应可以是 HTML、重定向、404、XML、图片等等。无论视图函数本身包含什么逻辑，都要返回响应。我们通常将视图函数放置在 views.py 文件中。我们现在只需要在页面上显示上一行 Hello World，所以这个视图函数不需要做什么，直接返回响应就行。既然是首页，不妨将函数命名为 index，我们看看具体的实现。编辑 myapp/views.py：from django.shortcuts import render, redirect
from django.http import HttpResponse

def index(request):
    return HttpResponse(&quot;&lt;h1&gt;Hello, World&lt;/h1&gt;&quot;)视图函数就写好啦！这里我们用到了 HttpResponse 对象，你可以翻阅 官方文档 了解这个对象，并尝试将 &lt;h1&gt;Hello, World&lt;/h1&gt; 改成其它内容。URL 的映射接下来我们建立 URL（统一资源定位符）与视图函数 index 的映射。具体可以分成两步，第一步是在应用下面处理自己的映射关系，第二步是进行路由分发。博主认为这可以理解为一个相对路径的确定，当然这里的路径指的是我们访问的 URL，和项目文件的放置没有关联。第一步实际上就是将应用根目录的绝对路径作为基准，确定各个网页的相对路径。第二步就是将项目根目录的绝对路径作为基准，确定各个应用根目录的相对路径。现在我们想在首页显示 Hello World，我们来看看具体的实现。先来做第一步，在 myapp 下面新建一个 urls.py：from django.urls import path
from . import views

urlpatterns = [
    path('', views.index, name='index'),
]path('', views.index, name='index') 可以理解为这个网页就位于应用的根目录，响应的是 views.py 文件里的 index 函数。而最后的 name='index' 则是指定 name 属性，这里的 name 和 HTML 下的 id 属性是类似的，必须要唯一。我们会在后面用到它。再来做第二步，编辑 mysite/urls.py：from django.contrib import admin
from django.urls import include, path

urlpatterns = [
    path('', include('myapp.urls')),
    path('admin/', admin.site.urls),
]path('', include('myapp.urls')) 可以理解为 myapp 这个应用的根目录就位于项目的根目录，path('admin/', admin.site.urls) 为 Django 自带的管理页面，可以暂时不用理会，我们会在后面用到它。当然了这样的理解自然是不严谨的，还是建议大家深入了解 URL 和路由，详情可以查阅 官方文档。现在使用 python manage.py runserver 调试，访问 http://127.0.0.1:8000/，显示的是 Hello World 页了。我们来看看另一个例子，假设我们要在已有的项目 mysite 下创建一个应用 yourapp，这个应用下我想做很多个网页。我希望这些网页都在 http://127.0.0.1:8000/abcdefg/ 目录下访问到。现在希望你实现其中两个网页：一个是 Goodbye World 页面我希望在 http://127.0.0.1:8000/abcdefg/goodbyeworld/ 访问到它.一个是 Hello Django 页面我希望在 http://127.0.0.1:8000/abcdefg/hellodjango/ 访问到它。页面显示什么无所谓。[collapse status="false" title="点击这里查看具体实现"]创建应用 yourapp：$ python manage.py startapp yourapp往项目添加这个应用，编辑 mysite/settings.py，找到 INSTALLED_APPS：INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'myapp',
    'yourapp',
]首先是视图函数，函数名不妨用拼音命名法，既然页面显示什么无所谓，我们编辑 yourapp/views.py：def zaijianshijie(request):
    return HttpResponse(&quot;&lt;p&gt;什么无所谓&lt;/p&gt;&quot;)

def nihaodjango(request):
    return HttpResponse(&quot;&lt;p&gt;什么无所谓&lt;/p&gt;&quot;)接下来在应用下面处理自己的映射关系，这里不对 name 属性进行指定，我们新建并编辑 yourapp/urls.py：urlpatterns = [
    path('goodbyeworld/', views.zaijianshijie),
    path('hellodjango/', views.nihaodjango),
]第二步是进行路由分发，我们编辑 mysite/urls.py：urlpatterns = [
    path('abcdefg/', include('yourapp.urls')),
    path('', include('myapp.urls')),
    path('admin/', admin.site.urls),
]尝试访问这两个网页，看看是否能按照你的期望工作？好了这个小练习到此结束，我们删除 yourapp 这个应用，因为我们并不需要到它。首先删除 yourapp/ 目录，然后编辑 mysite/urls.py，删除 path('abcdefg/', include('yourapp.urls')) 这一行，接下俩编辑 mysite/settings.py，从 INSTALLED_APPS 删除 'yourapp'。[/collapse]注册页的实现准备首先我们再再再做一遍 Hello World，我们希望在访问 http://127.0.0.1:8000/register/ 能看到「注册页」三个字，路由分发我们在做 Hello World 页的时候已经做好了，我们只需要在 myapp 处理映射关系就行。[collapse status="false" title="点击这里查看具体实现"]首先是视图函数，我们编辑 myapp/views.py：def register(request):
    return HttpResponse(&quot;&lt;p&gt;注册页&lt;/p&gt;&quot;)接下来在应用下面处理自己的映射关系，我们编辑 myapp/urls.py：urlpatterns = [
    path('', views.index, name='index'),
    path('register/', views.register, name='register'),
][/collapse]现在访问注册页，显示的只有三个字「注册页」，但我们实际需要的是：前端一个表单供用户输入账户密码，后端处理用户输入与数据库交互。接下来，我们会根据实际的需求进一步改造这个注册页，使其达到我们所要的效果。模板首先是前端，刚刚学完 Web 前端，应该不是什么难点。现在的问题讲通俗点就是，怎样做到我访问这个地址就显示一个 HTML 文件呢？一个方法是，我把这个 HTML 文件压成一行，换掉 &lt;p&gt;注册页&lt;/p&gt; 。可以是可以，但是一个很最突出的问题是维护起来很难受。事实上这样子其实是将数据与视图混合在一起，我们说是不符合 Django 的 MVC 思想（Model View Controller，具体请百度）。于是我们有了另外一个东西叫做模板。我们可以在 官方文档 How-to 部分 找到相关的文档。目前而言，你可以简单地把模板跟 HTML 文件划上等号。模板是有专门地方存放的，在 myapp/ 下面建立一个 templates/ 文件夹。接下来往里面放你的 HTML 文件。例如我把注册页命名为 register.html，也就是说文件的相对路径为 myapp/templates/register.html。就和初学 Web 前端一样，先不要管样式，也不要管按钮链接能不能工作，这些在后面会提及。为了节省时间，这里就直接开抄了。以下的代码为去年的代码改动而来：[collapse status="false" title="点击这里查看具体实现"]&lt;!DOCTYPE html&gt;
&lt;html&gt;

&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;register&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div class=&quot;lg_content&quot;&gt;
        &lt;table cellspacing=&quot;30px&quot; align=&quot;center&quot;&gt;
            &lt;form method=&quot;post&quot; action=&quot;#&quot;&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;2&quot;&gt;
                        &lt;input type=&quot;text&quot; name=&quot;userid&quot; class=&quot;reg_ip&quot; placeholder=&quot;学号&quot;&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;2&quot;&gt;
                        &lt;input type=&quot;text&quot; name=&quot;username&quot; class=&quot;reg_ip&quot; placeholder=&quot;昵称&quot;&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;2&quot;&gt;
                        &lt;input type=&quot;password&quot; name=&quot;passwd&quot; class=&quot;reg_ip&quot; placeholder=&quot;密码&quot;&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;2&quot;&gt;
                        &lt;input type=&quot;password&quot; name=&quot;repasswd&quot; class=&quot;reg_ip&quot; placeholder=&quot;确认密码&quot;&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;

                &lt;tr&gt;
                    &lt;td align=&quot;left&quot;&gt;

                        &lt;input type=&quot;submit&quot; value=&quot;注册&quot; style=&quot;position:relative;left:40px;&quot; class=&quot;button&quot;&gt;

                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/form&gt;
            &lt;td align=&quot;center&quot; style=&quot;position:relative;left:-50px&quot;&gt;
                &lt;span class=&quot;font1&quot;&gt;已经注册？&lt;/span&gt;
                &lt;input type=&quot;submit&quot; class=&quot;button&quot; style=&quot;height:25px;width:80px;font-size:12px&quot; value=&quot;直接登录&quot;
                    onclick=&quot;location.href='#'&quot;&gt;
            &lt;/td&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;[/collapse]接下来我们把「注册页」三个字换掉，这里我们使用的是 render 方法，它可接收三个参数，一是 request 参数，二是待渲染的 HTML 模板文件，三是保存具体数据的字典参数。它的作用就是将数据填充进模板文件，最后把结果返回给浏览器。编辑 myapp/views.py：def register(request):
    return render(request, 'register.html')我们再访问 http://127.0.0.1:8000/register/，发现已经有一个注册页面的样子了。静态资源现在我们来做注册页的样式吧！你们可能尝试过在 templates/ 直接放一个 CSS 文件，然后在 register.html 直接加 &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;，你会发现是行不通的，它实际请求的是 http://127.0.0.1:8000/register/style.css，直接 404。注意到 mysite/settings.py 有这么一行：# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/3.0/howto/static-files/

STATIC_URL = '/static/'事实上，关于静态资源的存放，官方文档 How-to 部分 依然给出了具体的说明。和模板类似，我们要单独建立 static/ 目录来存放这些静态资源。通常我们把这个目录放在应用目录下，我们 myapp/ 下新建 static/ 目录，里面再建一个 css/ 目录。接下来，我们尝试往 css/ 目录里面添加我们的样式。这个样式我们会在后面多次使用，编辑 myapp/static/css/style.css，这里我们继续偷懒开抄：[collapse status="false" title="点击这里查看具体实现"]body {
    /* background: url(&quot;../img/bg_img.jpg&quot;); */
    /* background-size: cover; */
    margin: 0px;
    padding: 0px;
    text-align: center;
}

.containerDiv {
    margin-top: 0;
    margin-bottom: 0;
    background-size: 100% 100%;
    width: 100%;
    text-align: center;
}

.lg_content {
    margin-top: 100px;
}

.titleDiv {
    width: 100%;
    height: 150px;
}

.problemDiv {
    width: 80%;
    height: 360px;
    margin-left: 10%;
    margin-right: 10%;
    position: relative;
}

.leftDiv {
    width: 50%;
    height: 360px;
    text-align: center;
    float: left;
}

.rightDiv {
    width: 40%;
    margin-left: 10%;
    height: 360px;
    text-align: center;
    float: left;
}

.answerDiv {
    width: 100%;
    height: 60px;
    position: relative;
}

.background {
    background-size: 100% 100%;
    width: 100%;
    height: 100%;
}

.button {
    width: 68px;
    height: 34px;
    font-size: 18px;
    color: rgb(255, 255, 255);
    background-color: rgb(76, 129, 179);
    box-shadow: none;
    border: none;
    border-style: inline;
}

.input {
    height: 40px;
    width: 250px;
    font-size: 14px;
    color: rgba(155, 152, 151, 0.774);
    border: none;
    box-shadow: none;
    border-style: none;
    border-width: 0px;
}

.font1 {
    font-family: &quot;Microsoft YaHei&quot;;
    font-size: 12px;
    font-weight: bold;
    color: azure;
}

.font2 {
    font-family: &quot;Microsoft YaHei&quot;;
    font-size: 22px;
    width: 400px;
    color: rgb(88, 99, 192);
}

#game_div,
p {
    width: 400px;
    margin: auto;
    margin-top: 0px;
}[/collapse]根据 STATIC_URL = '/static/' 这一线索，我们尝试访问 http://127.0.0.1:8000/static/css/style.css，发现确实是有这个文件的。事实上，只要将 &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt; 改成 &lt;link href=&quot;/static/css/style.css&quot; rel=&quot;stylesheet&quot;&gt; 就可以往页面加载样式了。但是，这样后续维护是很困难的。一个问题是如果我们后面突然又需要创建应用，需要的是不同的样式呢？想象一下，你有两个应用 myapp 和 yourapp，然后你在 myapp/static/css/style.css 和 yourapp/static/css/style.css 放了不同的样式文件，你访问 http://127.0.0.1:8000/static/css/style.css 得到的是什么呢？对这个问题，官方的解决方案是，在 myapp/static/ 下面再建立一个目录 myapp（就是应用本身的名称），然后把静态资源放里面，我们尝试将 myapp/static/css 目录移动到 myapp/static/myapp/css。现在我们在 http://127.0.0.1:8000/static/myapp/css/style.css 可以看到我们的样式文件了。另一个问题是如果我突然想更换一下映射到静态资源的 URL 呢？也就是说我把 STATIC_URL = '/static/' 改成别的，是不是所有的 HTML 文件我要逐个修改呢？所以我们是不建议按照前面的方式去写的，我们有一个船新的方法。编辑 myapp/templates/register.html：&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;register&lt;/title&gt;
    {% load static %}
    &lt;link href=&quot;{%static 'myapp/css/style.css'%}&quot; rel=&quot;stylesheet&quot;&gt;
&lt;/head&gt;要注意的是 {% load static %} 和 {%static 'myapp/css/style.css'%} 的 static 和 STATIC_URL = '/static/' 中的路径 static 是没有任何联系的，就是静态资源的意思。你可以尝试将 STATIC_URL 改成别的再来试试。现在访问 http://127.0.0.1:8000/register/，F12 看一下，会发现上面 {% %} 标签的内容都已经被替换掉了。接下来是背景图片。同样地，我们将 bg_img.jpg 放置在 myapp/static/myapp/img/ 目录中。这回没那么复杂，在 CSS 文件里引用时直接写相对路径即可，因为无论怎么修改 STATIC_URL 都不会对其产生影响：body {
    background: url(&quot;../img/bg_img.jpg&quot;);
    background-size: cover;
    margin: 0px;
    padding: 0px;
    text-align: center;
}好了，现在注册页看上去跟去年是一个样子了。数据库与模型来到后端部分了！后端部分是离不开数据库的，我们首先把数据库配置好。这里我们使用的是 SQLite 数据库，为什么在这个项目使用 SQLite 呢？轻量，无客户端和服务器端之分，跨平台，单文件。我们现在做的网站也只是供我们自娱自乐的而已，没有高并发。Python 内置 SQLite，所以你无需安装额外东西来使用它。不需要事先创建数据库，数据库会在需要的时候自动创建。Django 默认的数据库就是 SQLite，我们查看 mysite/settings.py：DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}让我们开始吧！首先我们对设定的数据库进行初始化：$ python manage.py migrate所谓的初始化实际上是迁移操作，为在 mysite/settings.py 涉及到的 INSTALLED_APPS 创建一些数据表。这里先不需要去纠结具体是做什么的，有兴趣的可以查看 官方文档。我们在后面还会使用到这个命令，到时再做说明。接下来我们进行数据表字段的规划。在 Django，我们称数据库结构设计为模型。你可以把模型类比为数据库里的数据表，在这里我们只需要为学生这个对象创建一个模型，不妨将它命名为 STUDB。下面我们就来实现这个模型，博主认为整个流程和 Git 提交代码的流程非常类似。在 Git 我们并不会在版本库直接改动代码，而是：第一步，你在工作区对文件作出改动，你的改动并不会影响到版本库。第二步，git add：你的改动从工作区被转移到了暂存区。第三步，git commit：你的改动从暂存区被转移到了版本库。在这个项目，我们的第一步就是编辑 myapp/models.py 文件，在文件记录我们需要的模型。作为我们需要建立的唯一一个模型，我们要为其添加的字段有：实际的字段规划应该在需求分析和系统设计阶段完成。字段名数据类型作用备注userid文本 TextField学号最大长度为 11 max_length=11username文本 TextField昵称最大长度为 10 max_length=10passwd文本 TextField密码最大长度为 20 max_length=20firstflag时间 DateTimeField普通关卡开始时间默认是当前时间lastflag时间 DateTimeField普通关卡通关时间默认是当前时间superflag时间 DateTimeField最后一关通关时间默认是当前时间specialflag时间 DateTimeField彩蛋通关时间默认是当前时间rank整数 IntegerFieldRank 记录默认是 1timesubtract整数 IntegerField普通关卡时间差默认是 0timesubtract_last整数 IntegerField最后一关时间差默认是 0timesubtract_suprise整数 IntegerField彩蛋时间差默认是 0我们可以在 官方文档 找到可能需要用到的数据类型。接下来我们将表格转为代码。在 myapp/models.py 在这个文件中，每个模型被表示为一个类。每个模型有许多类变量，它们都表示模型里的一个数据库字段。我们可以在 官方文档 找到很多代码实现的例子。[collapse status="false" title="点击这里查看具体实现"]from django.db import models
import django.utils.timezone as timezone

class STUDB(models.Model):
    userid = models.TextField(max_length=11)
    username = models.TextField(max_length=10)
    passwd = models.TextField(max_length=20)
    firstflag = models.DateTimeField(default=timezone.now)
    lastflag = models.DateTimeField(default=timezone.now)
    superflag = models.DateTimeField(default=timezone.now)
    specialflag = models.DateTimeField(default=timezone.now)
    rank = models.IntegerField(default=1)
    timesubtract = models.IntegerField(default=0)
    timesubtract_last = models.IntegerField(default=0)
    timesubtract_suprise = models.IntegerField(default=0)[/collapse]接下来是第二步，我们让 Django 检测你对模型文件的修改，并且把修改的部分储存为一次迁移。$ python manage.py makemigrations最后是第三步，在数据库里创建新定义的模型的数据表。$ python manage.py migrate表单处理与数据库交互既然数据库已经配置完毕，接下来我们要做的是读取用户的输入并写入数据库。怎样获取和处理用户的输入呢？Web 前端曾经讲过怎样用 Javascript 处理 GET 请求和 POST 请求，这里也是类似的，甚至还简单一些。首先还是要回到前端，我们已经写了一个 form 表单，目前我们的 form 标签是这样的：&lt;form method=&quot;post&quot; action=&quot;#&quot;&gt;&lt;/form&gt;我们需要将 action 属性补充完整。为此我们需要另外制作一个「页面」用来接收表单的信息，这个页面不一定要给用户看到些什么。我们在这个页面处理完用户的信息后就会跳转到相应的页面。我们把这个页面命名为 register_to_db。我们来写一下视图函数，这回我们需要进行一些逻辑上的处理了，所以这个函数注定要写的又臭又长，我们拆分一下我们要实现的逻辑。首先，我们要接收表单发过来的 POST 请求。在 Web 前端课程上，我们已经知道前端表单的 name 属性会被用于对提交到服务器后的表单数据进行标识。所以我们现在要接收的，就是 userid、username、passwd 和 repasswd。userid = request.POST.get('userid', None)
username = request.POST.get('username', None)
passwd = request.POST.get('passwd', None)
repasswd = request.POST.get('repasswd', None)接下来，我们看看学号是否已经被注册，如果被注册了，我们就跳转回注册页。从这里开始，我们就要用到数据库的增删改查操作了，然而我们并不需要写 SQL 语句，因为 Django 模型使用自带的对象关系映射（ORM）连接业务逻辑层和数据库层。简单来说，ORM 会将 Python 代码转成为 SQL 语句。菜鸟教程 提供了数据库增删改查实现的不少例子，可供参考。我们也来照葫芦画瓢，首先导入我们的模板，接下来我们使用 filter 方法查询学号信息，返回一个列表：from .models import STUDB
users = STUDB.objects.filter(userid=userid)如果这个列表不为空，意味着这个学号已经被注册，我们就跳转回注册页。怎样实现跳转呢，可以想到的第一个方法是直接使用之前讲过的 render 方法：if len(users) == 1:
    return render(request, 'register.html')会发现确实是重新「显示」注册页了，但是我们看 URL 并没有变，依然是 http://127.0.0.1:8000/register_to_db/。我们不要忘了 register.html 只是一个模板而已。但是我们希望的是跳转到 http://127.0.0.1:8000/register/。这里我们就要介绍到我们的 redirect 方法了，它专为重定向而生，我们看看它最基本的使用方法：if len(users) == 1:
    return redirect(&quot;http://127.0.0.1:8000/register/&quot;)和我们学 Web 前端接触的 a 标签的 href 属性几乎一样，填上 URL 就行。当然，上面这样填写绝对路径是不利于后续维护的。哪怕改成相对路径 redirect(&quot;../register/&quot;)，由于我们可以随时修改 myapp/urls.py 中的映射关系，事实上也不是什么好方法。还记得我们刚开始编辑 myapp/urls.py 时提到的 name 吗？[collapse status="false" title="点击这里查看具体实现"]path('register/', views.register, name='register')[/collapse]现在是将它派上用场的好机会。我们使用 reverse 方法，填上注册页的 name 参数：from django.shortcuts import render, reverse, redirect
if len(users) == 1:
    return redirect(reverse('register'))接下来我们再进一步，我们希望跳转过去之后弹出一条提示。我们知道 GET 的参数就是在 URL 后面跟一个 ?，然后是参数列表。不妨就利用 GET 请求通知注册页弹窗，具体的弹窗实现我们稍后再提及：from django.shortcuts import render, reverse, redirect
if len(users) == 1:
    return redirect(reverse('register')+&quot;?code=-1&quot;)我们尝试实现另外的几个逻辑，首先是判断输入是否齐全，然后是判断学号是否为 11 位且开头为 201，然后是判断密码是否是 6-18 位且必须是英文字母或数字，最后判断两次输入的密码是否一致。这里需要使用到正则表达式。[collapse status="false" title="点击这里查看具体实现"]import re

# 判断是否为空
if not userid or not passwd or not username or not repasswd:
    return redirect(reverse('register')+&quot;?code=-5&quot;)

# 判断学号格式
if not re.match(r'^(201).*\d{8}$', userid):
    return redirect(reverse('register')+&quot;?code=-4&quot;)

# 判断密码是否为 6-18 位且为字母或数字
if not re.match(r'^[A-Za-z0-9]{6,18}$', passwd):
    return redirect(reverse('register')+&quot;?code=-3&quot;)

# 判断两次密码是否一致
if passwd != repasswd:
    return redirect(reverse('register')+&quot;?code=-2&quot;)[/collapse]如果没啥问题，我们就可以写入数据库了，然后跳转到登录页。现在我们用到的是 save 函数。这里博主再次给出 菜鸟教程 的链接。然而我们还没有登录页。我们再再再再做一遍 Hello World，先摆上「登录页」三个大字（代码实现见下一节），别忘了在写 URL 映射的时候要把 name 参数设定好，假设是 login。STUDBdent = STUDB.objects.create(
    userid=userid, username=username, passwd=passwd)
STUDBdent.save()
return redirect(reverse('login')+&quot;?code=1&quot;)视图函数就写好了，我们再来检查一下我们刚才写的东西：[collapse status="false" title="点击这里查看具体实现"]from django.shortcuts import render, reverse, redirect
from django.http import HttpResponse
import re
from .models import STUDB

def register_to_db(request):
    userid = request.POST.get('userid', None)
    username = request.POST.get('username', None)
    passwd = request.POST.get('passwd', None)
    repasswd = request.POST.get('repasswd', None)
    if not userid or not passwd or not username or not repasswd:
        return redirect(reverse('register')+&quot;?code=-5&quot;)
    if not re.match(r'^(201).*\d{8}$', userid):
        return redirect(reverse('register')+&quot;?code=-4&quot;)
    if not re.match(r'^[A-Za-z0-9]{6,18}$', passwd):
        return redirect(reverse('register')+&quot;?code=-3&quot;)
    if passwd != repasswd:
        return redirect(reverse('register')+&quot;?code=-2&quot;)
    users = STUDB.objects.filter(userid=userid)
    if len(users) == 1:
        return redirect(reverse('register')+&quot;?code=-1&quot;)
    STUDBdent = STUDB.objects.create(
        userid=userid, username=username, passwd=passwd)
    STUDBdent.save()
    return redirect(reverse('login')+&quot;?code=1&quot;)[/collapse]接下来别忘了把映射关系写好：[collapse status="false" title="点击这里查看具体实现"]编辑 myapp/urls.py：urlpatterns = [
    path('', views.index, name='index'),
    path('register/', views.register, name='register'),
    path('login/', views.login, name='login'),
    path('register_to_db/', views.register_to_db, name='register_to_db'),
][/collapse]接下来，我们回到前端的表单，我们把这个 form 标签给鸽了很久了。&lt;form method=&quot;post&quot; action=&quot;#&quot;&gt;&lt;/form&gt;首先是 action 属性。在后端，我们使用的是 reverse 方法，回忆一下？[collapse status="false" title="点击这里查看具体实现"]return redirect(reverse('login')+&quot;?code=1&quot;)[/collapse]在模板这里，我们可以使用 {% url %} 标签。我们曾经讲过 {% static %} 标签，回忆一下？[collapse status="false" title="点击这里查看具体实现"]{% load static %}
&lt;link href=&quot;{%static 'myapp/css/style.css'%}&quot; rel=&quot;stylesheet&quot;&gt;[/collapse]下面我们就来看看 {% url %} 最简单的用法，就是带上页面的 name 参数：&lt;form method=&quot;post&quot; action=&quot;{% url 'register_to_db' %}&quot;&gt;&lt;/form&gt;我们看看另一个例子，知道注册页底部有一个按钮是链接到登录页的：&lt;input type=&quot;submit&quot; class=&quot;button&quot; style=&quot;height:25px;width:80px;font-size:12px&quot; value=&quot;直接登录&quot; onclick=&quot;location.href='#'&quot;&gt;我们来实现一下它的跳转功能吧，使用 {% url %} 标签：[collapse status="false" title="点击这里查看具体实现"]&lt;input type=&quot;submit&quot; class=&quot;button&quot; style=&quot;height:25px;width:80px;font-size:12px&quot; value=&quot;直接登录&quot; onclick=&quot;location.href='{% url 'login' %}'&quot;&gt;[/collapse]由于我们创建一个 POST 表单（它具有修改数据的作用），所以我们需要小心跨站点请求伪造。Django 自带了一个非常有用的防御系统。所有针对内部 URL 的 POST 表单都应该使用 {% csrf_token %} 模板标签，这里就没有什么用法了，在 form 标签内添加一行 {% csrf_token %} 即可。我们来看看现在的 myapp/templates/register.html 是什么样子的：[collapse status="false" title="点击这里查看具体实现"]&lt;!DOCTYPE html&gt;
&lt;html&gt;

&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;register&lt;/title&gt;
    {% load static %}
    &lt;link href=&quot;{% static 'myapp/css/style.css' %}&quot; rel=&quot;stylesheet&quot;&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div class=&quot;lg_content&quot;&gt;
        &lt;table cellspacing=&quot;30px&quot; align=&quot;center&quot;&gt;
            &lt;form method=&quot;post&quot; action=&quot;{% url 'register_to_db' %}&quot;&gt;
                {% csrf_token %}
                &lt;tr&gt;
                    &lt;td colspan=&quot;2&quot;&gt;
                        &lt;input type=&quot;text&quot; name=&quot;userid&quot; class=&quot;reg_ip&quot; placeholder=&quot;学号&quot;&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;2&quot;&gt;
                        &lt;input type=&quot;text&quot; name=&quot;username&quot; class=&quot;reg_ip&quot; placeholder=&quot;昵称&quot;&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;2&quot;&gt;
                        &lt;input type=&quot;password&quot; name=&quot;passwd&quot; class=&quot;reg_ip&quot; placeholder=&quot;密码&quot;&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;2&quot;&gt;
                        &lt;input type=&quot;password&quot; name=&quot;repasswd&quot; class=&quot;reg_ip&quot; placeholder=&quot;确认密码&quot;&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;

                &lt;tr&gt;
                    &lt;td align=&quot;left&quot;&gt;

                        &lt;input type=&quot;submit&quot; value=&quot;注册&quot; style=&quot;position:relative;left:40px;&quot; class=&quot;button&quot;&gt;

                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/form&gt;
            &lt;td align=&quot;center&quot; style=&quot;position:relative;left:-50px&quot;&gt;
                &lt;span class=&quot;font1&quot;&gt;已经注册？&lt;/span&gt;
                &lt;input type=&quot;submit&quot; class=&quot;button&quot; style=&quot;height:25px;width:80px;font-size:12px&quot; value=&quot;直接登录&quot;
                    onclick=&quot;location.href='{% url 'login' %}'&quot;&gt;
            &lt;/td&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
[/collapse]弹窗的实现施工中。Admin 管理工具让我们来看看刚才写的这么多东西到底起作用了没有。简单来说，就是模拟一下注册流程，看看是不是真的有东西写进数据表里面。我们就需要一个可视化的数据库管理工具。MySQL 下有死掉了的 PHPMyAdmin 和它的继任者 Adminer，那么 SQLite 呢？没错我们终于解锁了讲解「URL 的映射」提到过的神秘的管理工具 http://127.0.0.1:8000/admin/。然而直接访问这个页面需要账户密码。我们就创建一个超级用户：$ python manage.py createsuperuser输入你希望设定的账户、邮箱和密码。然后用这个帐号登录这个管理工具。似乎并没有显示我们的模型 STUDB。我们把将这个模型添加进管理工具里面，编辑 myapp/admin.py：from myapp.models import STUDB
admin.site.register(STUDB),现在管理页面应该能看到我们的模型，让我们愉快地开始注册吧（大雾）！以下部分正在施工。施工区域</description>
</item>
<item rdf:about="https://static.bobby285271.top/index.php/2020/04/15/NixOS-Installation-and-Configuration-Guide.html">
<title>NixOS Installation and Configuration Guide</title>
<link>https://static.bobby285271.top/index.php/2020/04/15/NixOS-Installation-and-Configuration-Guide.html</link>
<dc:date>2020-04-14T16:00:00+00:00</dc:date>
<description>本文基于 NixOS 20.03 Beta 和 NixOS Manual 20.03 撰写。本文的写作缘由是 NixOS Manual 的编排设计很容易导致习惯了其它发行版安装和配置流程的新人入坑失败。本篇指南给出的解决方案基本能满足大一软工专业课程学习和日常使用的需要。本文将假定你已经独立安装和配置过 Arch Linux、Gentoo 或任一官方不提供 GUI 安装程序的 Linux 发行版并掌握安装过程中涉及的大部分命令。了解 NixOS可以先从 DistroWatch 开始了解 NixOS 这个发行版，接下来建议阅读 NixOS 官方的介绍。有一个不太恰当的比喻，NixOS 相对于其它发行版有点像使用 Git + Markdown + Hexo 相对于无版本管理 + 手撸 HTML 文件，NixOS Wiki 也给出了 NixOS 和其它发行版的最大区别所在。而这一切实现的基础是 Nix，事实上 NixOS 中所有软件包（Nixpkgs）和系统配置都由 Nix 管理。要想了解 Nix，建议阅读 dram 大佬在知乎相关问题下的回答。dram 是 TUNA 镜像站镜像 NixOS / Nix / Nixpkgs 的主要推动者之一。至于 NixOS 是否适合你，可以阅读这篇文章自行判断。准备工作准备好安装 NixOS 了？让我们开始吧。前期的准备工作包括：数据备份、下载镜像、将镜像写入 U 盘、引导安装介质、连接到网络、建立分区、格式化分区、挂载分区，这一部分和其它（不带 GUI 安装程序的）Linux 发行版的安装几乎是一样的，这里不会细讲。2020 年 3 月后清华镜像站就有 Nix / NixOS / Nixpkgs 的镜像了，NixOS 的安装介质可在这里下载，建议选带桌面环境的镜像（可以通过文件名判断）。将写入 U 盘可以使用 dd 命令，具体用法（path-to-image 是 NixOS 安装介质的路径，/dev/sdX 则是写入目标）：sudo dd if=path-to-image of=/dev/sdX
引导安装介质后，按照 /etc/issue 的提示操作即可进入桌面环境（启动登录管理器），注意默认搭载的账户 nixos 和 root 都没有密码：sudo systemctl start display-manager
因为在线安装，联网是必须的。通常情况使用 NetworkManager 联网即可，当然这里还有其它的联网方式。可选的分区工具除了熟悉的 GDisk 和 GNU Parted 这些 CLI 的分区工具之外，还有 GUI 的分区工具 GParted。NixOS Manual 对在命令行下分区做了详细的介绍，还配有不少的例子，可以配合 ArchWiki 的相关文章进行阅读。因为 Nix 并不会自动删除历史的软件包安装，根目录尽可能分大一些，否则随着时间推移 /nix 可能会占用较大空间。除了 Home 和 EFI 分区之外不建议（也没必要）设置独立分区。另外 NixOS 的回滚功能是由 Nix 实现的，和 Btrfs 无关，如果你选择 Btrfs 仅仅是因为它的快照特性，那么没有必要给根分区使用 Btrfs。格式化分区之后就可以挂载分区了。分区应该挂载到 /mnt 下，例如根分区就挂载到 /mnt，Home 分区则 /mnt/home。特别留意 NixOS 下 EFI 分区应该挂载到 /mnt/boot。Swap 分区使用 swapon 启用即可。初始化 NixOS 配置文件接下来就是后期的准备工作了。事实上，如果你点开了前面的几个链接，你会发现 /etc/nixos/configuration.nix 是整个系统的灵魂所在。你的系统全局搭载的软件包和系统配置都取决于这个文件。因此我们说这个发行版是「先配置后安装」的。所以接下来的主要任务，就是配置 configuration.nix，这个文件会一直伴随着你的系统。一旦配置完成，你会使用到 nixos-install 脚本，这个脚本会读取这个文件，并调用 Nix 让其根据这个文件「造出对应的系统来」。而在安装好 NixOS 之后，你可以随时改动 configuration.nix 这个文件，然后使用 nixos-rebuild 脚本，这个脚本同样也是调用 Nix，让 Nix 处理所有的变化，以「造出对应的系统来」。「造出来的系统」会和当前系统的状态无关 。这两个脚本笔者在后面会介绍其用法。当然了，如果在 Live 环境里面直接编辑 /etc/nixos/configuration.nix，打开的是 Live 环境的配置文件。而现在我们需要为新的系统创建一个默认的 NixOS 的配置文件，在进入新系统之前，应该通过 /mnt 访问其文件（本文后续的命令，除非特别注明，否则一律需要在 root 账户下执行，可以使用 su 命令从普通用户切换到 root 账户）：nixos-generate-config --root /mnt
运行这个命令之后，/mnt/etc/nixos/ 目录会被创建，里面会放置自动生成的两个文件：configuration.nix 和 hardware-configuration.nix 。我们待会再看 hardware-configuration.nix，先看看前面已经提到无数次的 configuration.nix，这个文件在 NixOS 20.03 下默认长这样。当然了，在你安装系统之后，可以使用 nixos-generate-config --force 重新生成一个 configuration.nix。初识 NixOS 模块让我们来打开 configuration.nix 这个文件：nano /mnt/etc/nixos/configuration.nix
以 # 开头的都是注释，我们先不要管注释，看看没有注释的内容。实际上，这是一个简化的 NixOS 模块（NixOS Module）。我们尝试分析一下它的结构：{ config, pkgs, ... }:

{
    imports = [
        ./hardware-configuration.nix
    ];
    boot.loader.systemd-boot.enable = true;
    boot.loader.efi.canTouchEfiVariables = true;
    networking.useDHCP = false;
    networking.interfaces.docker0.useDHCP = true;
    networking.interfaces.wlo1.useDHCP = true;
    system.stateVersion = &quot;20.03&quot;;
}
第一行的 { config, pkgs, ... }: 表示这是一个至少接受两个参数 config 和 pkgs 的函数。config 主要用于在多个 NixOS 模块的情形下引用其它模块定义的配置值，这里有相关的例子，可以说是引入了完整的系统配置。pkgs 主要用于引用 Nixpkgs 中的软件包，例如 pkgs.fcitx。当然我们现在简单地认为第一行就是要这样写的好了，即使在本文中不会使用到 config。说实话在第一次接触 C++ 时对着 using namespace std; 自闭了半天，其实到后面需要到名称空间的时候自然就懂了。imports 导入了其它的 NixOS 模块，这里它导入了 ./hardware-configuration.nix。另外 modules/module-list.nix 里面定义了一系列的模块，这些模块会被自动导入。modules/module-list.nix 的绝对路径是啥呢，可以看回 NixOS 官方的介绍，阅读 How does NixOS work?，你会发现 /nix/store/ 下的目录都带上了 Hash 值，这是为了避免新的安装覆盖旧的安装（便于需要的时候回滚啊！事实上这也是开始时我说根目录尽可能分大一些的原因，后面会提供旧安装清理的方法）。所以要想找到这个 modules/module-list.nix，不妨用点小技巧：find / | grep &quot;modules/module-list.nix&quot;
cat 查看相应的文件就可以看到这个列表了，事实上还真导入了不少的 NixOS 模块。当然我们现在先打开 hardware-configuration.nix 看看（要注意上面的 ./hardware-configuration.nix 是相对于 /mnt/etc/nixos/configuration.nix 的路径）：cat /mnt/etc/nixos/hardware-configuration.nix
你会发现上面记录了你的分区信息，如果不是那就是你分区过程中出了差错，可以调整分区后按照上面的步骤重新 nixos-generate-config。这个文件将用于生成 Fstab 等文件。这个文件被单独分出来原因也是为了避免错误地编辑了这个文件。事实上 NixOS 官方只建议使用 nixos-generate-config 更新这个文件。接下来我们来看 configuration.nix 剩余的部分。这些行的格式都是 name = value，我们称这是定义（define）操作。我们称 configuration.nix 为简化的 NixOS 模块，原因是它只有定义操作。事实上还有声明（declare）操作，这一个一个的 name 其实在其它文件声明过，这样才可以被定义。笔者接下来会详细介绍定义操作和声明操作，如果想要深入了解 NixOS 模块，可以查看这里。定义操作我们来继续来研究上面 configuration.nix 涉及到的 Nix 表达式：boot.loader.systemd-boot.enable = true;
boot.loader.efi.canTouchEfiVariables = true;
我们已经知道它们格式都是 name = value，进一步分析它的结构，这两个表达式中我们把 boot、loader、systemd-boot 还有 efi 称之为集合（_set_），把 enable 和 canTouchEfiVariables 称为选项（_option_），把 true 称为值（value）。一个集合里面可能有子集合，也有可能有选项，我们给选项定义值。集合与子集合、集合与选项之间可以像上面一样，使用 . 连接。同时也可以使用下面的使用花括号嵌套的方式（注意分号出现的位置）：boot = {
    loader = {
        systemd-boot = {
            enable = true;
        };
        efi = {
            canTouchEfiVariables = true;
        };
    };
};
当然了可以两种方式混合使用：boot = {
    loader.systemd-boot = {
        enable = true;
    };
    loader = {
        efi.canTouchEfiVariables = true;
    };
};
如果是还有疑问的，NixOS Manual 给出了更多的相关例子。至于是使用花括号还是半角句号，我认为不重要。但在我看来，如果有两个选项它们属于同一个集合，它们应该尽量在一起被定义，而不是一个在文件开头定义，一个在文件末尾定义。同一集合的两个选项会有一定的关联性，放在一起可以更好地维护。当然了，当配置文件足够复杂之后，还可以像 hardware-configuration.nix 一样将一部分拆分出来，在 imports 部分导入相关文件，这里就不细讲了。至于 value，上面的给出的 configuration.nix 中涉及到的值有 true、false、&quot;20.03&quot;。和其它编程语言的数据类型类似，我们称 true 和 false 是布尔值，称 ”20.03&quot; 是字符串（注意两个引号），每一个 name 都有对应的可接受的类型。是事实上，对于其它的选项，可以接受的值的类型也有可能是列表、浮点数、软件包等等。这里详细地介绍了 value 的各种类型，并给出了相关的例子。这里问题就来了，怎样知道在一个 NixOS 系统中我有哪些 name 可以用呢？这些 name 又接受那些 value 呢？让我们继续来了解「声明操作」。声明操作和其它编程语言类似，声明就是要告诉人家我叫啥、我接受什么样的 value。怎样查看一个 name 的声明呢？第一个方法是使用命令 nixos-option，例如我要查看 system.stateVersion 的声明：nixos-option system.stateVersion
这个是在我系统上的输出，当然了在 Live 环境下输出不一定相同：Value:
&quot;20.03&quot;

Default:
&quot;20.03&quot;

Type:
&quot;string&quot;

Description:
''
    Every once in a while, a new NixOS release may change
    configuration defaults in a way incompatible with stateful
    data...（后面的省略）
''

Declared by:
[ &quot;/nix/var/nix/profiles/per-user/root/channels/nixos/nixos/modules/misc/version.nix&quot; ]

Defined by:
[ &quot;/etc/nixos/configuration.nix&quot; ]

我们会看到 system.stateVersion 在 /nix/var/nix/profiles/per-user/root/channels/nixos/nixos/modules/misc/version.nix 声明过，而笔者刚开始的时候说过 configuration.nix 会自动导入 modules/module-list.nix 里包含的所有文件，里面就有 version.nix，因此我们才可以在 /etc/nixos/configuration.nix 定义它。另外我们也能得到其它有用的信息，例如它接受一个字符串作为它的值，system.stateVersion 默认定义的值是 &quot;20.03&quot;，事实上这些信息就是在声明它的时候提供的。我们打开这个 version.nix，这就是一个声明的真面目了：options.system = {
    stateVersion = mkOption {
        type = types.str;
        default = cfg.release;
        description = ''
            Every once in a while, a new NixOS release may change
            configuration defaults in a way incompatible with stateful
            data...（后面的省略）
        '';
    };
};
当然笔者在本文中并不会要求用户创建一个声明。但我们还是会继续探究这个文件，我们发现 version.nix 给多个选项提供了声明，例如 system.nixos.release、system.nixos.codeName 等等。我们接着再往下翻一点：config = {
    system.nixos = {
        version = mkDefault (cfg.release + cfg.versionSuffix);
    };

    # Generate /etc/os-release.
    environment.etc.os-release.text = ''
        NAME=NixOS
        ID=nixos
        VERSION=&quot;${cfg.version} (${cfg.codeName})&quot;
        VERSION_CODENAME=${toLower cfg.codeName}
        VERSION_ID=&quot;${cfg.version}&quot;
        PRETTY_NAME=&quot;NixOS ${cfg.release} (${cfg.codeName})&quot;
        LOGO=&quot;nix-snowflake&quot;
        HOME_URL=&quot;https://nixos.org/&quot;
        DOCUMENTATION_URL=&quot;https://nixos.org/nixos/manual/index.html&quot;
        SUPPORT_URL=&quot;https://nixos.org/nixos/support.html&quot;
        BUG_REPORT_URL=&quot;https://github.com/NixOS/nixpkgs/issues&quot;
    '';
};
你会在里面找到 ${cfg.version} 和 ${cfg.codeName}。cfg 是什么呢，我们回到文件开头：{ config, lib, pkgs, ... }:

with lib;

let
    cfg = config.system.nixos;
in
{
    ...
}
还记得 config 是啥吗？我们说它引入了完整的系统配置。现在，即使我没有告诉你 environment.etc.os-release.text 是个啥，相信你也能猜出来，Nix 使用了 system.nixos.release、system.nixos.codeName 创建了 /etc/os-release 这个文件。至于前面提到的 system.stateVersion 呢，则被用于其它的地方了（毕竟有了 config，我们在任何地方都可以引用它）。事实上，就是这样声明和定义一个又一个的选项，组成了最终的系统。关于怎样查看一个 name 的声明，第二个方法是使用 NixOS Options 网页。输入 name 同样可以查看到使用 nixos-options 能看到的内容。关键是它还非常适合给我们模糊搜素用。另外点击 Declared in 旁边的超链接，会跳转到 GitHub 的 NixOS/nixpkgs 仓库。例如说我们查找 system.stateVersion，我们会被带到这里。同样也可以查看 version.nix 文件，还可以切换 Git 分支查看不同 NixOS 版本下这个文件的历史状态。我们在后面会经常使用到 NixOS Options 网页和 nixos-option 命令。开始编辑 configuration.nix讲了这么多，让我们尝试把刚刚学到的东西应用到实际当中吧！接下来我们要写很多很多的 name = value 表达式。我们已经知道，当我们有一个需求，我们可以尝试去 NixOS Options 进行模糊搜索，看看有没有对应的选项。此外，我们多次提到的 NixOS Manual 提供了很多的常见需求对应的解决方案。这里还会另外推荐一些寻找解决方案的地方：NixOS Manual - NixOS 官方文档值得阅读值得信赖。NixOS Options - 列出了所有可用的选项、其声明、可以接受的值。NixOS Discourse Forum - 用户论坛，有官方开发者答疑。NixOS Packages - 列出了所有可用的 Nixpkgs 软件包。NixOS Wiki - 社区维护的维基。GitHub - 查看其它用户的配置，或查看官方的 NixOS/nixpkgs 仓库。Stack Overflow - 查看打有 nixos 标签的问题和回答。各大搜索引擎 - 这个也不用我多说吧……当然了，如果实在找不到，可以去 NixOS Discourse Forum 提问，因为官方开发者在这个论坛非常活跃，很多问题都能在短时间内得到答案。要注意的是，因为 configuration.nix 会一直伴随着你的 NixOS 安装，所以这个章节既适用于安装时进行初始化配置，也适用于安装后的日常维护进行配置。下面结合两个自认为比较实际的需求来展开介绍，我会着重说明我是如何找到解决方案的，希望能给到大家一些帮助。桌面环境会发现 NixOS Manual 有多个对应的章节，有讲 X11 的，有专门讲 Pantheon 桌面环境的，有专门讲 XFCE 桌面环境的。个人非常喜欢 Pantheon，我们也知道 X11 是一切桌面环境的基础（假设我们把 Wayland 忽略掉）。我们来看看 X11。首先看到的是这样一句：The X Window System (X11) provides the basis of NixOS’ graphical user interface. It can be enabled as follows:services.xserver.enable = true;
看上去是不是很熟悉？事实上默认的 configuration.nix 里面已经有了这样的一行，只是被注释掉了。上面还配有注释 Enable the X11 windowing system. 让我们取消注释 services.xserver.enable = true;。搞定！就这么简单。先继续看看 Pantheon 桌面对应的章节。根据 NixOS Manual，要想使用 Pantheon 桌面，需要在 configuration.nix 加入：services.xserver.desktopManager.pantheon.enable = true;
这也很简单，复制粘贴过去就完成了，搞定！在 configuration.nix 加入这个 Nix 是怎样处理的呢？还记得前面提到的 system.nixos.release、system.nixos.codeName和 /etc/os-release 吗？可以按照当时我所给的思路一探究竟，我们在后面揭晓。软件包会发现 NixOS Manual 有对应的章节。它的要求是定义 environment.systemPackages 这个选项。它给出的例子是这样的：environment.systemPackages = [ pkgs.thunderbird ];
感觉有点迷？那不妨前往 NixOS Options 查找 environment.systemPackages，这时就应该知道它要求你提供 list of packages。我们回到 NixOS Manual，查看 Package 小节。这时就可以大致推断出这个 name 怎么填了。接下来我们去 GitHub 参考一下别人的配置文件，注意语言要选择 Nix，关键字将 Option 填入即可。查看搜索结果的时候只看定义操作相关的代码（而不是声明操作），这时你会发现另一个用法：environment.systemPackages = with pkgs; [
    vscode
    freemind
];
事实上这样写，在后面就不用每个软件包前面加上 pkgs. 了，pkgs.vscode 可以直接写成 vscode。胜利在望！接下来去 NixOS Packages，查找自己需要的软件包填入。你会发现有 Package name 和 Attribute name，填哪个呢？不妨回到 GitHub 继续翻配置文件，当你发现所有配置填的都是 Attribute name，我们就可以开始了，下面的就是我的配置：environment.systemPackages = with pkgs; 
[
    dos2unix chromium fcitx fcitx-configtool firefox gcc git gptfdisk libreoffice-fresh neofetch pciutils python transmission vim wget vscode-with-extensions
];
你会发现这里面没有 X11 和 Pantheon 相关的包，事实上， services.xserver.desktopManager.pantheon.enable = true; 这一行已经为你安装了相应的包。可以查看一下包含这个选项声明的文件，我们定位到 config = 往下的内容。虽然有些选项我们没有讨论过，例如 fonts.fontconfig.defaultFonts 等等，但是你可以通过搜索 NixOS Options 或者直接按照它的字面意思知道这些选项是干什么的。有安装软件包的、设置系统服务的、设置字体的等等。有了这么一行，我们也就没有必要在我们自己的 configuration.nix 中设置它了。所以说 NixOS Options 的优先级是会高于 NixOS Packages 的，笔者才会用很大的篇幅介绍前者。当你需要一个软件或功能，首先考虑的应该是有没有对应的 NixOS Option，而不是直接安装一个 Nixpkg。*下面是另外两个比较玄学的案例，都是我安装完成之后才开始折腾的问题，当然了安装的时候也没有必要纠结这些问题，因为安装完后还可以随时编辑 configuration.nix，后面还会再介绍。同样，我会着重说明我是如何找到解决方案的，希望能给到大家一些帮助。介绍这些案例，不是为了劝退，而是为了说明，只要合理利用我在本章介绍的各类资源，善用搜索，必要时勇敢提问、开 Issue，甚至发 PR（这里有笔者本人的例子），大部分的问题都能很快地得到解决。禁用 N 卡单纯出于想要省电的原因，打算禁用 N 卡。网上给出的禁用 N 卡的方案是都是使用 BBSwitch，四处搜索之。最后在 Discourse Forum 里面找到了一个有一定关联的。提到的选项包括 extraModprobeConfig、blacklistedKernelModules、extraModulePackages。我们知道在其它发行版下要使用 BBSwitch 禁用 N 卡是这样操作的：options bbswitch load_state=0 unload_state=1
和帖子中 extraModprobeConfig 的值高度类似。而 extraModulePackages 在帖子里的值是 config.boot.kernelPackages.nvidia_x11，我们搜索到 BBSwitch 的 Attribute name 是 linuxPackages.bbswitch，相信也有一定关联。接下来我们去 NixOS Options 继续搜索，发现上面几个选项都在 boot 集合下，查找 boot module 关键词，又发现了一个 boot.kernelModules，我认为这个选项和我的需求也是高度关联的。于是我写下了以下的配置：boot = {
    extraModprobeConfig = ''
        options bbswitch load_state=0 unload_state=1
    '';
    extraModulePackages = [ pkgs.linuxPackages.bbswitch ];
    kernelModules = [ &quot;bbswitch&quot; ];
    blacklistedKernelModules = [
        &quot;nouveau&quot;
        &quot;rivafb&quot;
        &quot;nvidiafb&quot;
        &quot;rivatv&quot;
        &quot;nv&quot;
        &quot;uvcvideo&quot;
    ];
};
确实是可行的，因为我后面运行 lspci 的时候显示已经是 rev ff 了：01:00.0 3D controller: NVIDIA Corporation GP107M [GeForce GTX 1050 3 GB Max-Q] (rev ff)
Visual Studio Code 插件你可能会问这也要提及？情况是这样的，安装了 VS Code（pkgs.vscode-with-extensions）之后我安装了几个插件，发现 C++ 插件不工作。我对这个插件提供的补全功能有较大的依赖，第一时间我想到的是这是 NixOS 目录结构和其它发行版不一致的问题。于是去搜索 Discourse Forum，找到了这个帖子。下面有官方开发者给出了一个 Dirty Hack，尝试之。结果发现 fetchTarball https://github.com/nixos/nixpkgs-channels/archive/nixpkgs-unstable.tar.gz 会消耗不少时间。一个解决方案是将整个 GitHub 仓库同步到其它 Git 托管平台，但我们还是希望有更高效的解决方案。留意到了楼主的解决方案，虽然它会覆盖原有的自己在 Marketplace 安装的 VS Code 插件，但是按照楼主的描述它确实是可行的：self: super:
{
    mycode = super.vscode-with-extensions.override {
        # When the extension is already available in the default extensions set.
        vscodeExtensions = with super.vscode-extensions; [
            ms-vscode.cpptools
        ];
    };
}
但是你并不知道第一行是啥，也不知道如何添加这个方案，于是去 GitHub 搜索相关的内容。结果搜出来的结果比上面这个还要再复杂一点，而且这样写的不只一个：self: super: {
    vscode-with-extensions = super.vscode-with-extensions.override {
        vscodeExtensions = with super.vscode-extensions;
        [ 
            bbenoist.Nix
            ms-vscode.cpptools
        ]
        ++ super.vscode-utils.extensionsFromVscodeMarketplace [ {
                name = &quot;vim&quot;;
                publisher = &quot;vscodevim&quot;;
                version = &quot;1.0.8&quot;;
                sha256 = &quot;0yqfn8b2jfrijzf731sggyvik2immlx9hfgmsgp1mx01hpyisd9r&quot;;
            } {
                name = &quot;doxdocgen&quot;;
                publisher = &quot;cschlosser&quot;;
                version = &quot;0.4.1&quot;;
                sha256 = &quot;06f4nxjd5ph66bhlyjim87haams286sjhrw7vmiv2rckzinygh1h&quot;;
            } {
                ...
            }
        ];
    };
}
这时可以猜出来官方应该有相应的文档，于是就去搜索 NixOS Manual、NixOS Options 还有 NixOS Packages，发现都找不到。终于，笔者开始查找 GitHub 的 NixOS/nixpkgs 仓库。找到了这样一个文件。你会发现第一行没了，后面的内容还是类似的。现在我们可以把关注点放在这个 override 上了。我们重新发起一次搜索，在 NixOS Manual 找到了有关 override 的说明。太妙了！但是接下来又有一个问题，这里的 name、publisher、version 和 sha256 又该怎么填呢？为什么 ms-vscode.cpptools 不需要填 version 和 sha256 呢？阅读还是刚才的文件，阅读上面的注释：This expression should fetch:the nix vscode extension from whatever source defined in the default nixpkgs extensions set vscodeExtensions.the code-runner vscode extension from the marketplace using the following url: (link).The original code executable will be wrapped so that it uses the set of pre-installed / unpacked extensions as its --extensions-dir.然而我们却找不到 vscodeExtensions，但是我们可以搜索 ms-vscode.cpptools 啊！终于笔者找到了这个文件。事实上在这个文件中涉及到的所有插件都无需我们再配置 publisher、version 和 sha256 了。这和我们使用了 services.xserver.desktopManager.pantheon.enable = true; 就不需要在 environment.systemPackages 添加相关的包是一个道理。至于这个文件里没有的插件呢？例如说 ms-vscode.cpptools 的 name 就是 cpptools，publisher 就是 ms-vscode。我们可以去 Marketplace 下载这个插件（找到 Download Extension 按钮即可），用 sha256sum 命令计算下载下来的文件的 sha256，而版本号在文件名有。好了，你已经准备好了！让我们来继续完善 environment.systemPackages：environment.systemPackages = with pkgs; 
[
    dos2unix chromium fcitx fcitx-configtool firefox gcc git gptfdisk libreoffice-fresh neofetch pciutils python transmission vim wget
    ( vscode-with-extensions.override {
        vscodeExtensions = with vscode-extensions; [
            bbenoist.Nix
            ms-vscode.cpptools
            ms-azuretools.vscode-docker
        ]
        ++ vscode-utils.extensionsFromVscodeMarketplace [ {
                name = &quot;bracket-pair-colorizer-2&quot;;
                publisher = &quot;CoenraadS&quot;;
                version = &quot;0.0.29&quot;;
                sha256 = &quot;cadb50a21944e6e0293e3872d2fe23b5d2fd2b603ed2bf4a0675fd29bcfb130c&quot;;
            } {
                name = &quot;python&quot;;
                publisher = &quot;ms-python&quot;;
                version = &quot;2020.3.71113&quot;;
                sha256 = &quot;1d8a98a1eed7588dd3b57e4bbe518fcc88f883e066f1b3342453e9bc1a283fdb&quot;;
            } {
                name = &quot;php-intellisense&quot;;
                publisher = &quot;felixfbecker&quot;;
                version = &quot;2.3.14&quot;;
                sha256 = &quot;3798a5de1172b5803877357d0057e3e129d8d82b8fbe0b53ae28c777a0075ca6&quot;;
            } {
                name = &quot;vscode-language-pack-zh-hans&quot;;
                publisher = &quot;MS-CEINTL&quot;;
                version = &quot;1.44.2&quot;;
                sha256 = &quot;4f6ee18ada0e71dd1545ef49f8810f52fe872d2074612faa908d8bf2687400a0&quot;;
            }
        ];
    } )
];
*相信对于其它的需求大家也能举一反三。这里是我的 configuration.nix，供大家参考。执行安装前面已经提及过 nixos-install 这个命令了，让我们使用它执行安装，不需要带上任何参数：nixos-install
如果 configuration.nix 存在任何错误，安装会在一开始的时候就中断，修改好后重新运行上面的命令即可。网络出现问题同理。接下来安装程序会提示你设置一个密码，这个密码是给管理员用的（密码当然是不能在 configuration.nix 上设置的），盲打两次即可。重启并进入新系统：reboot
当然，重启后别忘了为你的普通用户设置密码（如 passwd bobby285271）。系统维护笔者之前讲过 configuration.nix 是可以随时修改的。当然了现在你应该处于你的新系统中了，所以你不应该编辑 /mnt/etc/nixos/configuration.nix 了，而是应该编辑 /etc/nixos/configuration.nix。nano /etc/nixos/configuration.nix
要使这个配置生效，应该使用 nixos-rebuild switch 命令，如果你希望在构建这个配置的时候顺便升级自己的系统（当然如果你不改动 configuration.nix 单纯想升级系统，同样可以执行这个命令） ：nixos-rebuild switch --upgrade
关于这个，可以查看 NixOS Manual 了解详情。</description>
</item>
<item rdf:about="https://static.bobby285271.top/index.php/2020/02/03/How-to-Deploy-WordPress-on-a-Fedora-Server-en.html">
<title>How to Deploy WordPress on a Fedora Server (en)</title>
<link>https://static.bobby285271.top/index.php/2020/02/03/How-to-Deploy-WordPress-on-a-Fedora-Server-en.html</link>
<dc:date>2020-02-02T16:00:00+00:00</dc:date>
<description>First things firstYou should get a IP address after buying VPS, such as 123.123.123.123. Open your favourite terminal and enter:Replace 123.123.123.123 with your actual IP address.ssh root@123.123.123Enter your password to login. Perform a full upgrade on your system:dnf upgrade
Package InstallationInstall Apache, PHP and MariaDB using the DNF package manager. There is NO need to install the wordpress package.dnf install @&quot;Web Server&quot; php-mysqlnd mariadb-server
Enable the web and database services to start at boot time, then start them immediately:systemctl enable httpd.service mariadb.service
systemctl start httpd.service mariadb.serviceMariaDB ConfigurationFirstly, initialize MariaDB. If this is your first use of MariaDB, you should create a password for your root user here. Don’t use the system’s own root (administrator) password. It is suggested to answer y to all yes-no questions afterwards:mysql_secure_installationNext, create a database. You can host more than one WordPress site on a machine. Therefore, you may want to choose a distinctive name for yours. For instance, this example uses mywpsite. The -p switch prompts you for a password.Replace mywpsite with a database name you preferred.mysqladmin create mywpsite -u root -pNext, set up a special privileged user and password for the database. The web app uses these credentials to run. Use the standard mysql client program for this step. The -D option attaches to the built-in MySQL database where privileges are stored.Replace sqluser and password with a user name you preferred and a strong password.mysql -D mysql -u root -pGRANT ALL PRIVILEGES ON mywpsite.* TO 'sqluser'@'localhost' IDENTIFIED BY 'password';
FLUSH PRIVILEGES;
QUIT;Set up the Web ServerNext, tune the SELinux parameters so the web server can perform necessary functions.setsebool -P httpd_can_network_connect_db=1
setsebool -P httpd_can_sendmail=1Next, configure your firewall so it allows traffic on port 80 (HTTP):firewall-cmd --add-service=http --permanent
firewall-cmd --reloadDownload WordPressThese latest version of WordPress are always available on https://wordpress.org/latest.tar.gz.cd /var/www/html
wget https://wordpress.org/latest.tar.gzExtract the downloaded archive to the document root of your domain and update permissions on files.tar xzf latest.tar.gz
chown -R apache.apache wordpress
chmod -R 755 wordpressAll DoneVisit 123.123.123.123/wordpress, and finish the installation.</description>
</item>
</rdf:RDF>