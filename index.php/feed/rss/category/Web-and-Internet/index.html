<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://static.bobby285271.top/index.php/feed/rss/category/Web-and-Internet/">
<title>Dasyatis - Web and Internet</title>
<link>https://static.bobby285271.top/index.php/category/Web-and-Internet/</link>
<description></description>
<items>
<rdf:Seq>
<rdf:li resource="https://static.bobby285271.top/index.php/2020/07/15/WIP-Introduction-to-Django---Illustrated-by-the-Example-of-SCNUSE-SoCoding-1024-Website.html"/>
<rdf:li resource="https://static.bobby285271.top/index.php/2020/02/03/How-to-Deploy-WordPress-on-a-Fedora-Server-en.html"/>
<rdf:li resource="https://static.bobby285271.top/index.php/2017/10/21/How-to-Generate-a-Hexo-Blog-and-Deploy-it-on-GitHub.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://static.bobby285271.top/index.php/2020/07/15/WIP-Introduction-to-Django---Illustrated-by-the-Example-of-SCNUSE-SoCoding-1024-Website.html">
<title>[WIP] Introduction to Django - Illustrated by the Example of SCNUSE SoCoding 1024 Website</title>
<link>https://static.bobby285271.top/index.php/2020/07/15/WIP-Introduction-to-Django---Illustrated-by-the-Example-of-SCNUSE-SoCoding-1024-Website.html</link>
<dc:date>2020-07-15T12:04:00+00:00</dc:date>
<description>本文尚未完成。注册页部分已经更新完成，即将开始更新登录页部分。最后更新时间 7 月 19 日上午。好久没有出文章了，放暑假有点时间，尝试再造一遍 2019 年 SCNUSE 软协 1024 程序员节活动网站（尽量还原，会有一些差别），算是 Django 框架的一个学习项目吧。博主本人的基本功也不怎么扎实，下文用到了非常多不严谨的表述，如果有任何错误欢迎指出。要实现什么去年也是参与到这个活动中来了，但是只是做了一个关卡，比较划水。这里就略过需求分析系统设计什么的了，简单来说整个网站做的就是注册登录和七个关卡。去年最后具体实现用到的是 Django 框架，使用 MySQL 数据库，但是这里将使用 SQLite 数据库。铺垫博主认为有一些技能在开始动手之前还是要先掌握的。首先是 Python，其实有了程序设计基础之后 Python 的语法其实很简单。完全不会 Python 的推荐看 Python 100 天教程 前 15 天部分的内容，然后找个 Online Judge 做几道水题，最多两个小时应该都能熟悉。然后是 Web 前端 HTML、CSS、Javascript 的一些最基本的应用，学校讲的足够用了，这里推荐 菜鸟教程，可以尝试自己写一些小的静态网站。最后 Django 本身还是要先做了解的。可以简单浏览 Python 100 天教程 第 14 天和第 41 天的内容，另外也推荐阅读官方推荐的一些 设计理念 。准备先来做一些准备工作，包括开发环境的配置、项目和应用的初始化。开发环境可以按照自己的喜好来配置，不一定要按照这里的来；项目和应用的初始化有对应的具体的命令，执行即可。开发环境要做的事情就是安装一个对 Python 支持良好的 IDE 或者为你的代码编辑器添加 Python 支持，然后安装 Django。假设你跟我一样已经是 Arch Linux + VS Code 用户。VS Code 下的 Python 支持是需要到 pip 的，pip 是 Python 的包管理器，直接使用 Linux 下的包管理器安装。# pacman -S python-pippip 既然是包管理器，能条件反射到的是肯定要换源，我们在家目录创建并编辑 .pip/pip.conf：$ cd 
$ mkdir .pip
$ nano .pip/pip.conf[global]
index-url = https://pypi.tuna.tsinghua.edu.cn/simple启动 VS Code，先装上 Python 扩展和 Visual Studio IntelliCode 扩展，然后打开任意 Python 文件，尝试格式化文档，VS Code 就会提示你安装格式化程序，安装就可。可以观察到实质就是调用 pip 安装 autopep8。接下来安装 Django，这里有两个方法，一个是继续使用 Linux 下的包管理器安装：# pacman -S python-django`或者是用上面刚刚讲到的 pip：$ pip install django要注意的是给 Arch Linux 软件包锁版本是不被提倡的，毕竟是滚动更新发行版。所以如果你使用 Pacman 安装 python-django 就得一直跟着系统走用最新版，要考虑其利弊。接下来尝试使用 django-admin 命令，测试一下是不是一切都准备妥当了：$ django-admin version理想情况是输出一个版本号。如果提示命令没有找到，那就是在普通用户下使用 pip 按照 Django 导致 django-admin 不在 PATH 里。解决方法很多，例如改用 root 安装，或是修改 PATH，可以参考 官方文档。创建项目我们首先使用 django-admin 命令为站点创建一个已经初始化的项目目录，不妨叫 mysite。如果你起的名字跟我的不一样，只要看到 mysite 改过来就行，另外不要用保留字命名，后面也是一样的道理。$ django-admin startproject mysite
$ cd mysite进入项目目录之后，应该能见到另一个 mysite/ 目录和一个 manage.py 文件：mysite/ 包含了 Django 项目实例需要的设置项集合，包括数据库配置、Django 配置和应用配置。manage.py 就是一个让你用各种方式管理 Django 项目的命令行工具。我们约定，后面涉及的所有文件和文件夹均以当前所在的项目目录为基准标注相对路径。创建应用在 Django 中，每一个应用都是一个 Python 包。应用通常是一个专门做某件事的网络应用程序，比如博客系统、投票程序。项目则是一个网站使用的配置和应用的集合。一个项目可以包含很多个应用，但这里我们只创建一个，就叫 myapp：$ python manage.py startapp myapp接下来往项目添加这个应用。编辑 mysite/settings.py，找到 INSTALLED_APPS：这里没有展示整个的完整的文件，只会展示需要改动的代码或是关键的代码，后面也是一样的道理。我们会在文末附上成品的代码，可以结合成品代码理解。INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'myapp',
]站点调试我们可以利用 manage.py 运行 Django 自带的用于开发的简易 Web 服务器对我们的网站进行预览和调试。不要将这个服务器用于和生产环境相关的任何地方，这个服务器只是为了开发而设计的。$ python manage.py runserver终端应该会输出类似这样的东西：Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.按照上面的输出，我们打开浏览器访问 http://127.0.0.1:8000/，在下文中我们假设你的服务器设置和我的一样为监听本机内部 IP 的 8000 端口。在一个网页都没有完成的情况下，你应该能看到 Django 自带的测试页面。当我们写好我们的网站之后则应该能看到自己的网站，测试页面就不会再出现了。现在我们尝试将测试页面改成中文的，其实是为 Django 设置语言。编辑 mysite/settings.py：LANGUAGE_CODE = 'zh-hans'
TIME_ZONE = 'Asia/Shanghai'不必重新启动服务器，直接刷新页面，现在测试页面显示的是中文，你的改动生效了。通常来说服务器会对每一次的访问请求重新载入一遍 Python 代码，但是例外还是有的（如添加新文件）。如果你发现你的改动没有生效，尝试重启服务器就好了。如果你想把服务器停掉，就按照终端的提示按下 Ctrl + C 组合键即可，和 Linux 杀死其它命令的方式是一样的。第一个页面几乎所有教程做第一个页面都是 Hello World，虽然这和 1024 站点没啥关联，我们也先实现一下，目标是访问站点首页后显示一行文字 Hello World。博主认为虽然是 Hello World，但可能还是会有点难度。其实不需要纠结太多，关键是记住具体的实现，知道哪些地方是套路，哪些地方要改动。我们在后面会制作更多的页面，自然就会熟悉了。响应与视图函数视图函数（简称视图）是一个简单的 Python 函数，它接受 Web 请求并且返回 Web 响应。响应可以是 HTML、重定向、404、XML、图片等等。无论视图函数本身包含什么逻辑，都要返回响应。我们通常将视图函数放置在 views.py 文件中。我们现在只需要在页面上显示上一行 Hello World，所以这个视图函数不需要做什么，直接返回响应就行。既然是首页，不妨将函数命名为 index，我们看看具体的实现。编辑 myapp/views.py：from django.shortcuts import render, redirect
from django.http import HttpResponse

def index(request):
    return HttpResponse(&quot;&lt;h1&gt;Hello, World&lt;/h1&gt;&quot;)视图函数就写好啦！这里我们用到了 HttpResponse 对象，你可以翻阅 官方文档 了解这个对象，并尝试将 &lt;h1&gt;Hello, World&lt;/h1&gt; 改成其它内容。URL 的映射接下来我们建立 URL（统一资源定位符）与视图函数 index 的映射。具体可以分成两步，第一步是在应用下面处理自己的映射关系，第二步是进行路由分发。博主认为这可以理解为一个相对路径的确定，当然这里的路径指的是我们访问的 URL，和项目文件的放置没有关联。第一步实际上就是将应用根目录的绝对路径作为基准，确定各个网页的相对路径。第二步就是将项目根目录的绝对路径作为基准，确定各个应用根目录的相对路径。现在我们想在首页显示 Hello World，我们来看看具体的实现。先来做第一步，在 myapp 下面新建一个 urls.py：from django.urls import path
from . import views

urlpatterns = [
    path('', views.index, name='index'),
]path('', views.index, name='index') 可以理解为这个网页就位于应用的根目录，响应的是 views.py 文件里的 index 函数。而最后的 name='index' 则是指定 name 属性，这里的 name 和 HTML 下的 id 属性是类似的，必须要唯一。我们会在后面用到它。再来做第二步，编辑 mysite/urls.py：from django.contrib import admin
from django.urls import include, path

urlpatterns = [
    path('', include('myapp.urls')),
    path('admin/', admin.site.urls),
]path('', include('myapp.urls')) 可以理解为 myapp 这个应用的根目录就位于项目的根目录，path('admin/', admin.site.urls) 为 Django 自带的管理页面，可以暂时不用理会，我们会在后面用到它。当然了这样的理解自然是不严谨的，还是建议大家深入了解 URL 和路由，详情可以查阅 官方文档。现在使用 python manage.py runserver 调试，访问 http://127.0.0.1:8000/，显示的是 Hello World 页了。我们来看看另一个例子，假设我们要在已有的项目 mysite 下创建一个应用 yourapp，这个应用下我想做很多个网页。我希望这些网页都在 http://127.0.0.1:8000/abcdefg/ 目录下访问到。现在希望你实现其中两个网页：一个是 Goodbye World 页面我希望在 http://127.0.0.1:8000/abcdefg/goodbyeworld/ 访问到它.一个是 Hello Django 页面我希望在 http://127.0.0.1:8000/abcdefg/hellodjango/ 访问到它。页面显示什么无所谓。[collapse status="false" title="点击这里查看具体实现"]创建应用 yourapp：$ python manage.py startapp yourapp往项目添加这个应用，编辑 mysite/settings.py，找到 INSTALLED_APPS：INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'myapp',
    'yourapp',
]首先是视图函数，函数名不妨用拼音命名法，既然页面显示什么无所谓，我们编辑 yourapp/views.py：def zaijianshijie(request):
    return HttpResponse(&quot;&lt;p&gt;什么无所谓&lt;/p&gt;&quot;)

def nihaodjango(request):
    return HttpResponse(&quot;&lt;p&gt;什么无所谓&lt;/p&gt;&quot;)接下来在应用下面处理自己的映射关系，这里不对 name 属性进行指定，我们新建并编辑 yourapp/urls.py：urlpatterns = [
    path('goodbyeworld/', views.zaijianshijie),
    path('hellodjango/', views.nihaodjango),
]第二步是进行路由分发，我们编辑 mysite/urls.py：urlpatterns = [
    path('abcdefg/', include('yourapp.urls')),
    path('', include('myapp.urls')),
    path('admin/', admin.site.urls),
]尝试访问这两个网页，看看是否能按照你的期望工作？好了这个小练习到此结束，我们删除 yourapp 这个应用，因为我们并不需要到它。首先删除 yourapp/ 目录，然后编辑 mysite/urls.py，删除 path('abcdefg/', include('yourapp.urls')) 这一行，接下俩编辑 mysite/settings.py，从 INSTALLED_APPS 删除 'yourapp'。[/collapse]注册页的实现这个页面做起来是最痛苦的。虽然博主并不会在做到后面的时候，把前面做了什么统统忘掉，但如果你担心这个的话，可以一边跟着做注册页，一边尝试做登录页。准备首先我们再再再做一遍 Hello World，我们希望在访问 http://127.0.0.1:8000/register/ 能看到「注册页」三个字，路由分发我们在做 Hello World 页的时候已经做好了，我们只需要在 myapp 处理映射关系就行。[collapse status="false" title="点击这里查看具体实现"]首先是视图函数，我们编辑 myapp/views.py：def register(request):
    return HttpResponse(&quot;&lt;p&gt;注册页&lt;/p&gt;&quot;)接下来在应用下面处理自己的映射关系，我们编辑 myapp/urls.py：urlpatterns = [
    path('', views.index, name='index'),
    path('register/', views.register, name='register'),
][/collapse]现在访问注册页，显示的只有三个字「注册页」，但我们实际需要的是：前端一个表单供用户输入账户密码，后端处理用户输入与数据库交互。接下来，我们会根据实际的需求进一步改造这个注册页，使其达到我们所要的效果。模板首先是前端，刚刚学完 Web 前端，应该不是什么难点。现在的问题讲通俗点就是，怎样做到我访问这个地址就显示一个 HTML 文件呢？一个方法是，我把这个 HTML 文件压成一行，换掉 &lt;p&gt;注册页&lt;/p&gt; 。可以是可以，但是一个很最突出的问题是维护起来很难受。事实上这样子其实是将数据与视图混合在一起，我们说是不符合 Django 的 MVC 思想（Model View Controller，具体请百度）。于是我们有了另外一个东西叫做模板。我们可以在 官方文档 How-to 部分 找到相关的文档。目前而言，你可以简单地把模板跟 HTML 文件划上等号。模板是有专门地方存放的，在 myapp/ 下面建立一个 templates/ 文件夹。接下来往里面放你的 HTML 文件。例如我把注册页命名为 register.html，也就是说文件的相对路径为 myapp/templates/register.html。就和初学 Web 前端一样，先不要管样式，也不要管按钮链接能不能工作，这些在后面会提及。为了节省时间，这里就直接开抄了。以下的代码为去年的代码改动而来：[collapse status="false" title="点击这里查看具体实现"]&lt;!DOCTYPE html&gt;
&lt;html&gt;

&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;register&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div class=&quot;lg_content&quot;&gt;
        &lt;table cellspacing=&quot;30px&quot; align=&quot;center&quot;&gt;
            &lt;form method=&quot;post&quot; action=&quot;#&quot;&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;2&quot;&gt;
                        &lt;input type=&quot;text&quot; name=&quot;userid&quot; class=&quot;reg_ip&quot; placeholder=&quot;学号&quot;&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;2&quot;&gt;
                        &lt;input type=&quot;text&quot; name=&quot;username&quot; class=&quot;reg_ip&quot; placeholder=&quot;昵称&quot;&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;2&quot;&gt;
                        &lt;input type=&quot;password&quot; name=&quot;passwd&quot; class=&quot;reg_ip&quot; placeholder=&quot;密码&quot;&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;2&quot;&gt;
                        &lt;input type=&quot;password&quot; name=&quot;repasswd&quot; class=&quot;reg_ip&quot; placeholder=&quot;确认密码&quot;&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;

                &lt;tr&gt;
                    &lt;td align=&quot;left&quot;&gt;

                        &lt;input type=&quot;submit&quot; value=&quot;注册&quot; style=&quot;position:relative;left:40px;&quot; class=&quot;button&quot;&gt;

                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/form&gt;
            &lt;td align=&quot;center&quot; style=&quot;position:relative;left:-50px&quot;&gt;
                &lt;span class=&quot;font1&quot;&gt;已经注册？&lt;/span&gt;
                &lt;input type=&quot;submit&quot; class=&quot;button&quot; style=&quot;height:25px;width:80px;font-size:12px&quot; value=&quot;直接登录&quot;
                    onclick=&quot;location.href='#'&quot;&gt;
            &lt;/td&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;[/collapse]接下来我们把「注册页」三个字换掉，这里我们使用的是 render 方法，它可接收三个参数，一是 request 参数，二是待渲染的 HTML 模板文件，三是保存具体数据的字典参数。它的作用就是将数据填充进模板文件，最后把结果返回给浏览器。编辑 myapp/views.py：def register(request):
    return render(request, 'register.html')我们再访问 http://127.0.0.1:8000/register/，发现已经有一个注册页面的样子了。静态资源现在我们来做注册页的样式吧！你们可能尝试过在 templates/ 直接放一个 CSS 文件，然后在 register.html 直接加 &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;，你会发现是行不通的，它实际请求的是 http://127.0.0.1:8000/register/style.css，直接 404。注意到 mysite/settings.py 有这么一行：# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/3.0/howto/static-files/

STATIC_URL = '/static/'事实上，关于静态资源的存放，官方文档 How-to 部分 依然给出了具体的说明。和模板类似，我们要单独建立 static/ 目录来存放这些静态资源。通常我们把这个目录放在应用目录下，我们 myapp/ 下新建 static/ 目录，里面再建一个 css/ 目录。接下来，我们尝试往 css/ 目录里面添加我们的样式。这个样式我们会在后面多次使用，编辑 myapp/static/css/style.css，这里我们继续偷懒开抄：[collapse status="false" title="点击这里查看具体实现"]body {
    /* background: url(&quot;../img/bg_img.jpg&quot;); */
    /* background-size: cover; */
    margin: 0px;
    padding: 0px;
    text-align: center;
}

.containerDiv {
    margin-top: 0;
    margin-bottom: 0;
    background-size: 100% 100%;
    width: 100%;
    text-align: center;
}

.lg_content {
    margin-top: 100px;
}

.titleDiv {
    width: 100%;
    height: 150px;
}

.problemDiv {
    width: 80%;
    height: 360px;
    margin-left: 10%;
    margin-right: 10%;
    position: relative;
}

.leftDiv {
    width: 50%;
    height: 360px;
    text-align: center;
    float: left;
}

.rightDiv {
    width: 40%;
    margin-left: 10%;
    height: 360px;
    text-align: center;
    float: left;
}

.answerDiv {
    width: 100%;
    height: 60px;
    position: relative;
}

.background {
    background-size: 100% 100%;
    width: 100%;
    height: 100%;
}

.button {
    width: 68px;
    height: 34px;
    font-size: 18px;
    color: rgb(255, 255, 255);
    background-color: rgb(76, 129, 179);
    box-shadow: none;
    border: none;
    border-style: inline;
}

.input {
    height: 40px;
    width: 250px;
    font-size: 14px;
    color: rgba(155, 152, 151, 0.774);
    border: none;
    box-shadow: none;
    border-style: none;
    border-width: 0px;
}

.font1 {
    font-family: &quot;Microsoft YaHei&quot;;
    font-size: 12px;
    font-weight: bold;
    color: azure;
}

.font2 {
    font-family: &quot;Microsoft YaHei&quot;;
    font-size: 22px;
    width: 400px;
    color: rgb(88, 99, 192);
}

#game_div,
p {
    width: 400px;
    margin: auto;
    margin-top: 0px;
}[/collapse]根据 STATIC_URL = '/static/' 这一线索，我们尝试访问 http://127.0.0.1:8000/static/css/style.css，发现确实是有这个文件的。事实上，只要将 &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt; 改成 &lt;link href=&quot;/static/css/style.css&quot; rel=&quot;stylesheet&quot;&gt; 就可以往页面加载样式了。但是，这样后续维护是很困难的。一个问题是如果我们后面突然又需要创建应用，需要的是不同的样式呢？想象一下，你有两个应用 myapp 和 yourapp，然后你在 myapp/static/css/style.css 和 yourapp/static/css/style.css 放了不同的样式文件，你访问 http://127.0.0.1:8000/static/css/style.css 得到的是什么呢？对这个问题，官方的解决方案是，在 myapp/static/ 下面再建立一个目录 myapp（就是应用本身的名称），然后把静态资源放里面，我们尝试将 myapp/static/css 目录移动到 myapp/static/myapp/css。现在我们在 http://127.0.0.1:8000/static/myapp/css/style.css 可以看到我们的样式文件了。另一个问题是如果我突然想更换一下映射到静态资源的 URL 呢？也就是说我把 STATIC_URL = '/static/' 改成别的，是不是所有的 HTML 文件我要逐个修改呢？所以我们是不建议按照前面的方式去写的，我们有一个船新的方法。编辑 myapp/templates/register.html：&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;register&lt;/title&gt;
    {% load static %}
    &lt;link href=&quot;{%static 'myapp/css/style.css'%}&quot; rel=&quot;stylesheet&quot;&gt;
&lt;/head&gt;要注意的是 {% load static %} 和 {%static 'myapp/css/style.css'%} 的 static 和 STATIC_URL = '/static/' 中的路径 static 是没有任何联系的，就是静态资源的意思。你可以尝试将 STATIC_URL 改成别的再来试试。现在访问 http://127.0.0.1:8000/register/，F12 看一下，会发现上面 {% %} 标签的内容都已经被替换掉了。接下来是背景图片。同样地，我们将 bg_img.jpg 放置在 myapp/static/myapp/img/ 目录中。这回没那么复杂，在 CSS 文件里引用时直接写相对路径即可，因为无论怎么修改 STATIC_URL 都不会对其产生影响：body {
    background: url(&quot;../img/bg_img.jpg&quot;);
    background-size: cover;
    margin: 0px;
    padding: 0px;
    text-align: center;
}好了，现在注册页看上去跟去年是一个样子了。数据库与模型来到后端部分了！后端部分是离不开数据库的，我们首先把数据库配置好。这里我们使用的是 SQLite 数据库，为什么在这个项目使用 SQLite 呢？轻量，无客户端和服务器端之分，跨平台，单文件。我们现在做的网站也只是供我们自娱自乐的而已，没有高并发。Python 内置 SQLite，所以你无需安装额外东西来使用它。不需要事先创建数据库，数据库会在需要的时候自动创建。Django 默认的数据库就是 SQLite，我们查看 mysite/settings.py：DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}让我们开始吧！首先我们对设定的数据库进行初始化：$ python manage.py migrate所谓的初始化实际上是迁移操作，为在 mysite/settings.py 涉及到的 INSTALLED_APPS 创建一些数据表。这里先不需要去纠结具体是做什么的，有兴趣的可以查看 官方文档。我们在后面还会使用到这个命令，到时再做说明。接下来我们进行数据表字段的规划。在 Django，我们称数据库结构设计为模型。你可以把模型类比为数据库里的数据表，在这里我们只需要为学生这个对象创建一个模型，不妨将它命名为 STUDB。下面我们就来实现这个模型，博主认为整个流程和 Git 提交代码的流程非常类似。在 Git 我们并不会在版本库直接改动代码，而是：第一步，你在工作区对文件作出改动，你的改动并不会影响到版本库。第二步，git add：你的改动从工作区被转移到了暂存区。第三步，git commit：你的改动从暂存区被转移到了版本库。在这个项目，我们的第一步就是编辑 myapp/models.py 文件，在文件记录我们需要的模型。作为我们需要建立的唯一一个模型，我们要为其添加的字段有：实际的字段规划应该在需求分析和系统设计阶段完成。字段名数据类型作用备注userid文本 TextField学号最大长度为 11 max_length=11username文本 TextField昵称最大长度为 10 max_length=10passwd文本 TextField密码最大长度为 20 max_length=20firstflag时间 DateTimeField普通关卡开始时间默认是当前时间lastflag时间 DateTimeField普通关卡通关时间默认是当前时间superflag时间 DateTimeField最后一关通关时间默认是当前时间specialflag时间 DateTimeField彩蛋通关时间默认是当前时间rank整数 IntegerFieldRank 记录默认是 1timesubtract整数 IntegerField普通关卡时间差默认是 0timesubtract_last整数 IntegerField最后一关时间差默认是 0timesubtract_suprise整数 IntegerField彩蛋时间差默认是 0我们可以在 官方文档 找到可能需要用到的数据类型。接下来我们将表格转为代码。在 myapp/models.py 在这个文件中，每个模型被表示为一个类。每个模型有许多类变量，它们都表示模型里的一个数据库字段。我们可以在 官方文档 找到很多代码实现的例子。[collapse status="false" title="点击这里查看具体实现"]from django.db import models
import django.utils.timezone as timezone

class STUDB(models.Model):
    userid = models.TextField(max_length=11)
    username = models.TextField(max_length=10)
    passwd = models.TextField(max_length=20)
    firstflag = models.DateTimeField(default=timezone.now)
    lastflag = models.DateTimeField(default=timezone.now)
    superflag = models.DateTimeField(default=timezone.now)
    specialflag = models.DateTimeField(default=timezone.now)
    rank = models.IntegerField(default=1)
    timesubtract = models.IntegerField(default=0)
    timesubtract_last = models.IntegerField(default=0)
    timesubtract_suprise = models.IntegerField(default=0)[/collapse]接下来是第二步，我们让 Django 检测你对模型文件的修改，并且把修改的部分储存为一次迁移。$ python manage.py makemigrations最后是第三步，在数据库里创建新定义的模型的数据表。$ python manage.py migrate表单处理与数据库交互既然数据库已经配置完毕，接下来我们要做的是读取用户的输入并写入数据库。怎样获取和处理用户的输入呢？Web 前端曾经讲过怎样用 Javascript 处理 GET 请求和 POST 请求，这里也是类似的，甚至还简单一些。首先还是要回到前端，我们已经写了一个 form 表单，目前我们的 form 标签是这样的：&lt;form method=&quot;post&quot; action=&quot;#&quot;&gt;&lt;/form&gt;我们需要将 action 属性补充完整。为此我们需要另外制作一个「页面」用来接收表单的信息，这个页面不一定要给用户看到些什么。我们在这个页面处理完用户的信息后就会跳转到相应的页面。我们把这个页面命名为 register_to_db。我们来写一下视图函数，这回我们需要进行一些逻辑上的处理了，所以这个函数注定要写的又臭又长，我们拆分一下我们要实现的逻辑。首先，我们要接收表单发过来的 POST 请求。在 Web 前端课程上，我们已经知道前端表单的 name 属性会被用于对提交到服务器后的表单数据进行标识。所以我们现在要接收的，就是 userid、username、passwd 和 repasswd。userid = request.POST.get('userid', None)
username = request.POST.get('username', None)
passwd = request.POST.get('passwd', None)
repasswd = request.POST.get('repasswd', None)接下来，我们看看学号是否已经被注册，如果被注册了，我们就跳转回注册页。从这里开始，我们就要用到数据库的增删改查操作了，然而我们并不需要写 SQL 语句，因为 Django 模型使用自带的对象关系映射（ORM）连接业务逻辑层和数据库层。简单来说，ORM 会将 Python 代码转成为 SQL 语句。菜鸟教程 提供了数据库增删改查实现的不少例子，可供参考。我们也来照葫芦画瓢，首先导入我们的模板，接下来我们使用 filter 方法查询学号信息，返回一个列表：from .models import STUDB
users = STUDB.objects.filter(userid=userid)如果这个列表不为空，意味着这个学号已经被注册，我们就跳转回注册页。怎样实现跳转呢，可以想到的第一个方法是直接使用之前讲过的 render 方法：if len(users) == 1:
    return render(request, 'register.html')会发现确实是重新「显示」注册页了，但是我们看 URL 并没有变，依然是 http://127.0.0.1:8000/register_to_db/。我们不要忘了 register.html 只是一个模板而已。但是我们希望的是跳转到 http://127.0.0.1:8000/register/。这里我们就要介绍到我们的 redirect 方法了，它专为重定向而生，我们看看它最基本的使用方法：if len(users) == 1:
    return redirect(&quot;http://127.0.0.1:8000/register/&quot;)和我们学 Web 前端接触的 a 标签的 href 属性几乎一样，填上 URL 就行。当然，上面这样填写绝对路径是不利于后续维护的。哪怕改成相对路径 redirect(&quot;../register/&quot;)，由于我们可以随时修改 myapp/urls.py 中的映射关系，事实上也不是什么好方法。还记得我们刚开始编辑 myapp/urls.py 时提到的 name 吗？[collapse status="false" title="点击这里查看具体实现"]path('register/', views.register, name='register')[/collapse]现在是将它派上用场的好机会。我们使用 reverse 方法，填上注册页的 name 参数：from django.shortcuts import render, reverse, redirect
if len(users) == 1:
    return redirect(reverse('register'))接下来我们再进一步，我们希望跳转过去之后弹出一条提示。我们知道 GET 的参数就是在 URL 后面跟一个 ?，然后是参数列表。不妨就利用 GET 请求通知注册页弹窗，我们这里就用一个参数 code，当然参数名可以自定。具体的弹窗实现我们稍后再提及：from django.shortcuts import render, reverse, redirect
if len(users) == 1:
    return redirect(reverse('register')+&quot;?code=-1&quot;)我们尝试实现另外的几个逻辑，首先是判断输入是否齐全，然后是判断学号是否为 11 位且开头为 201，然后是判断密码是否是 6-18 位且必须是英文字母或数字，最后判断两次输入的密码是否一致。这里需要使用到正则表达式。[collapse status="false" title="点击这里查看具体实现"]import re

# 判断是否为空
if not userid or not passwd or not username or not repasswd:
    return redirect(reverse('register')+&quot;?code=-5&quot;)

# 判断学号格式
if not re.match(r'^(201).*\d{8}$', userid):
    return redirect(reverse('register')+&quot;?code=-4&quot;)

# 判断密码是否为 6-18 位且为字母或数字
if not re.match(r'^[A-Za-z0-9]{6,18}$', passwd):
    return redirect(reverse('register')+&quot;?code=-3&quot;)

# 判断两次密码是否一致
if passwd != repasswd:
    return redirect(reverse('register')+&quot;?code=-2&quot;)[/collapse]如果没啥问题，我们就可以写入数据库了，然后跳转到登录页。现在我们用到的是 save 函数。这里博主再次给出 菜鸟教程 的链接。然而我们还没有登录页。不妨顺带实现一下，大家可以尝试尽可能多地实现它的功能（代码实现见下一节），别忘了在写 URL 映射的时候要把 name 参数设定好，假设是 login。STUDBdent = STUDB.objects.create(
    userid=userid, username=username, passwd=passwd)
STUDBdent.save()
return redirect(reverse('login')+&quot;?code=1&quot;)视图函数就写好了，我们再来检查一下我们刚才写的东西：[collapse status="false" title="点击这里查看具体实现"]from django.shortcuts import render, reverse, redirect
from django.http import HttpResponse
import re
from .models import STUDB

def register_to_db(request):
    userid = request.POST.get('userid', None)
    username = request.POST.get('username', None)
    passwd = request.POST.get('passwd', None)
    repasswd = request.POST.get('repasswd', None)
    if not userid or not passwd or not username or not repasswd:
        return redirect(reverse('register')+&quot;?code=-5&quot;)
    if not re.match(r'^(201).*\d{8}$', userid):
        return redirect(reverse('register')+&quot;?code=-4&quot;)
    if not re.match(r'^[A-Za-z0-9]{6,18}$', passwd):
        return redirect(reverse('register')+&quot;?code=-3&quot;)
    if passwd != repasswd:
        return redirect(reverse('register')+&quot;?code=-2&quot;)
    users = STUDB.objects.filter(userid=userid)
    if len(users) == 1:
        return redirect(reverse('register')+&quot;?code=-1&quot;)
    STUDBdent = STUDB.objects.create(
        userid=userid, username=username, passwd=passwd)
    STUDBdent.save()
    return redirect(reverse('login')+&quot;?code=1&quot;)[/collapse]接下来别忘了把映射关系写好：[collapse status="false" title="点击这里查看具体实现"]编辑 myapp/urls.py：urlpatterns = [
    path('', views.index, name='index'),
    path('register/', views.register, name='register'),
    path('login/', views.login, name='login'),
    path('register_to_db/', views.register_to_db, name='register_to_db'),
][/collapse]接下来，我们回到前端的表单，我们把这个 form 标签给鸽了很久了。&lt;form method=&quot;post&quot; action=&quot;#&quot;&gt;&lt;/form&gt;首先是 action 属性。在后端，我们使用的是 reverse 方法，回忆一下？[collapse status="false" title="点击这里查看具体实现"]return redirect(reverse('login')+&quot;?code=1&quot;)[/collapse]在模板这里，我们可以使用 {% url %} 标签。我们曾经讲过 {% static %} 标签，回忆一下？[collapse status="false" title="点击这里查看具体实现"]{% load static %}
&lt;link href=&quot;{%static 'myapp/css/style.css'%}&quot; rel=&quot;stylesheet&quot;&gt;[/collapse]下面我们就来看看 {% url %} 最简单的用法，就是带上页面的 name 参数：&lt;form method=&quot;post&quot; action=&quot;{% url 'register_to_db' %}&quot;&gt;&lt;/form&gt;我们看看另一个例子，知道注册页底部有一个按钮是链接到登录页的：&lt;input type=&quot;submit&quot; class=&quot;button&quot; style=&quot;height:25px;width:80px;font-size:12px&quot; value=&quot;直接登录&quot; onclick=&quot;location.href='#'&quot;&gt;我们来实现一下它的跳转功能吧，使用 {% url %} 标签：[collapse status="false" title="点击这里查看具体实现"]&lt;input type=&quot;submit&quot; class=&quot;button&quot; style=&quot;height:25px;width:80px;font-size:12px&quot; value=&quot;直接登录&quot; onclick=&quot;location.href='{% url 'login' %}'&quot;&gt;[/collapse]由于我们创建一个 POST 表单（它具有修改数据的作用），所以我们需要小心跨站点请求伪造。Django 自带了一个非常有用的防御系统。所有针对内部 URL 的 POST 表单都应该使用 {% csrf_token %} 模板标签，这里就没有什么用法了，在 form 标签内添加一行 {% csrf_token %} 即可。我们来看看现在的 myapp/templates/register.html 是什么样子的：[collapse status="false" title="点击这里查看具体实现"]&lt;!DOCTYPE html&gt;
&lt;html&gt;

&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;register&lt;/title&gt;
    {% load static %}
    &lt;link href=&quot;{% static 'myapp/css/style.css' %}&quot; rel=&quot;stylesheet&quot;&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div class=&quot;lg_content&quot;&gt;
        &lt;table cellspacing=&quot;30px&quot; align=&quot;center&quot;&gt;
            &lt;form method=&quot;post&quot; action=&quot;{% url 'register_to_db' %}&quot;&gt;
                {% csrf_token %}
                &lt;tr&gt;
                    &lt;td colspan=&quot;2&quot;&gt;
                        &lt;input type=&quot;text&quot; name=&quot;userid&quot; class=&quot;reg_ip&quot; placeholder=&quot;学号&quot;&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;2&quot;&gt;
                        &lt;input type=&quot;text&quot; name=&quot;username&quot; class=&quot;reg_ip&quot; placeholder=&quot;昵称&quot;&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;2&quot;&gt;
                        &lt;input type=&quot;password&quot; name=&quot;passwd&quot; class=&quot;reg_ip&quot; placeholder=&quot;密码&quot;&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;2&quot;&gt;
                        &lt;input type=&quot;password&quot; name=&quot;repasswd&quot; class=&quot;reg_ip&quot; placeholder=&quot;确认密码&quot;&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;

                &lt;tr&gt;
                    &lt;td align=&quot;left&quot;&gt;

                        &lt;input type=&quot;submit&quot; value=&quot;注册&quot; style=&quot;position:relative;left:40px;&quot; class=&quot;button&quot;&gt;

                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/form&gt;
            &lt;td align=&quot;center&quot; style=&quot;position:relative;left:-50px&quot;&gt;
                &lt;span class=&quot;font1&quot;&gt;已经注册？&lt;/span&gt;
                &lt;input type=&quot;submit&quot; class=&quot;button&quot; style=&quot;height:25px;width:80px;font-size:12px&quot; value=&quot;直接登录&quot;
                    onclick=&quot;location.href='{% url 'login' %}'&quot;&gt;
            &lt;/td&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
[/collapse]消息框架现在我们来实现注册页的最后一部分内容，也就是弹窗提示。由于是根据 GET 请求中的 code 参数的值弹出响应的内容，我们在 Web 前端已经学过怎样用 Javascript 来做这件事了。但是 Django 提供了另外一个实现的思路，也就是消息框架。具体实现分为两步，一步是添加消息，另一步是显示消息。首先是添加信息，我们使用到的是 add_message 方法，例如我们要添加一条 Hello World 信息：from django.contrib import messages
messages.add_message(request, messages.INFO, 'Hello World')但是我们通常不按照上面的方式写，因为有另外的更简单的写法：from django.contrib import messages
messages.info(request, 'Hello World')在这里 Hello World 就是通知的内容了，info 指的是通知的级别。你可以将它换成 success、warning、error、debug 中的一种。至于通知级别的用途，简单来说就是用于添加 HTML 标签的类，官方文档 有相关的例子，当然我们这里还不需要到。回到项目，我们看看怎样根据 code 参数添加响应的信息，编辑 myapp/views.py，我们开始修改我们的 register 视图函数。首先是获取 code 参数，回忆一下我们是怎样获取用户的表单信息的，注意这里使用的是 GET 请求。[collapse status="false" title="点击这里查看具体实现"]code = request.GET.get('code', None)[/collapse]接下来我们来添加信息，如果不记得 code 值对应的含义的话，可以回看一下 register_to_db 视图函数。[collapse status="false" title="点击这里查看具体实现"]if code == '-5':
    messages.error(request, &quot;不要没填完就注册啊喂！&quot;)
elif code == '-4':
    messages.error(request, &quot;学 号 格 式 有 误&quot;)
elif code == '-3':
    messages.error(request, &quot;密码需要 6-18 位且必须是英文字母或数字&quot;)
elif code == '-2':
    messages.error(request, &quot;两次密码输入不一致的说&quot;)
elif code == '-1':
    messages.error(request, &quot;这个学号已被注册！请不要试图顶替别人(｡•ˇ‸ˇ•｡)&quot;)[/collapse]现在我们的 register 函数也被改得又臭又长了，看看你的函数现在是个什么样子？[collapse status="false" title="点击这里查看具体实现"]别忘了导入 messages。from django.contrib import messages

def register(request):
    code = request.GET.get('code', None)
    if code == '-5':
        messages.error(request, &quot;不要没填完就注册啊喂！&quot;)
    elif code == '-4':
        messages.error(request, &quot;学 号 格 式 有 误&quot;)
    elif code == '-3':
        messages.error(request, &quot;密码需要 6-18 位且必须是英文字母或数字&quot;)
    elif code == '-2':
        messages.error(request, &quot;两次密码输入不一致的说&quot;)
    elif code == '-1':
        messages.error(request, &quot;这个学号已被注册！请不要试图顶替别人(｡•ˇ‸ˇ•｡)&quot;)
    return render(request, 'register.html')[/collapse]接下来是第二步，就是显示消息。之前讲过 {% url %} 和 {% static %}，我们接下来要使用更多的 Django 标签，包括 {% if %}、{% endif %} 和 {% for %}、{% endfor %} 标签。我们可以很快地猜出它们的作用，前两个用于判断，后两个用于循环。我们考虑我们现在要实现的逻辑，就是如果有消息 messages（不能改为别的名称），我们就遍历这些消息，对于每一个消息 msg（可以改为别的名称），我们执行 alert() 方法。我们来看一下代码实现，编辑 myapp/templates/register.html。{% if messages %}
&lt;script&gt;
    {% for msg in messages %}
    alert('{{msg.message}}')
    {% endfor %}
&lt;/script&gt;
{% endif %}其实是很套路化的，在其它需要到消息的场合代码几乎是一样的，无非是把 script 标签换掉，把 alert 方法换掉。到这里注册页的实现已经全部完成啦！Admin 管理工具让我们来看看刚才写的这么多东西到底起作用了没有。简单来说，就是模拟一下注册流程，看看是不是真的有东西写进数据表里面。我们就需要一个可视化的数据库管理工具。MySQL 下有死掉了的 PHPMyAdmin 和它的继任者 Adminer，那么 SQLite 呢？没错我们终于解锁了讲解「URL 的映射」提到过的神秘的管理工具 http://127.0.0.1:8000/admin/。然而直接访问这个页面需要账户密码。我们就创建一个超级用户：$ python manage.py createsuperuser输入你希望设定的账户、邮箱和密码。然后用这个帐号登录这个管理工具。似乎并没有显示我们的模型 STUDB。我们把将这个模型添加进管理工具里面，编辑 myapp/admin.py：from myapp.models import STUDB
admin.site.register(STUDB),现在管理页面应该能看到我们的模型，让我们愉快地开始注册吧（大雾）！登录页的实现可以说接下来我们要做的就是另一个注册页，几乎是一样的。由于基本的套路都在刚才涉及到了，这一部分我们节奏会稍微加快一些，整个流程和注册页也会有所不同。以下部分正在施工，敬请期待。前端部分前端部分</description>
</item>
<item rdf:about="https://static.bobby285271.top/index.php/2020/02/03/How-to-Deploy-WordPress-on-a-Fedora-Server-en.html">
<title>How to Deploy WordPress on a Fedora Server (en)</title>
<link>https://static.bobby285271.top/index.php/2020/02/03/How-to-Deploy-WordPress-on-a-Fedora-Server-en.html</link>
<dc:date>2020-02-02T16:00:00+00:00</dc:date>
<description>First things firstYou should get a IP address after buying VPS, such as 123.123.123.123. Open your favourite terminal and enter:Replace 123.123.123.123 with your actual IP address.ssh root@123.123.123Enter your password to login. Perform a full upgrade on your system:dnf upgrade
Package InstallationInstall Apache, PHP and MariaDB using the DNF package manager. There is NO need to install the wordpress package.dnf install @&quot;Web Server&quot; php-mysqlnd mariadb-server
Enable the web and database services to start at boot time, then start them immediately:systemctl enable httpd.service mariadb.service
systemctl start httpd.service mariadb.serviceMariaDB ConfigurationFirstly, initialize MariaDB. If this is your first use of MariaDB, you should create a password for your root user here. Don’t use the system’s own root (administrator) password. It is suggested to answer y to all yes-no questions afterwards:mysql_secure_installationNext, create a database. You can host more than one WordPress site on a machine. Therefore, you may want to choose a distinctive name for yours. For instance, this example uses mywpsite. The -p switch prompts you for a password.Replace mywpsite with a database name you preferred.mysqladmin create mywpsite -u root -pNext, set up a special privileged user and password for the database. The web app uses these credentials to run. Use the standard mysql client program for this step. The -D option attaches to the built-in MySQL database where privileges are stored.Replace sqluser and password with a user name you preferred and a strong password.mysql -D mysql -u root -pGRANT ALL PRIVILEGES ON mywpsite.* TO 'sqluser'@'localhost' IDENTIFIED BY 'password';
FLUSH PRIVILEGES;
QUIT;Set up the Web ServerNext, tune the SELinux parameters so the web server can perform necessary functions.setsebool -P httpd_can_network_connect_db=1
setsebool -P httpd_can_sendmail=1Next, configure your firewall so it allows traffic on port 80 (HTTP):firewall-cmd --add-service=http --permanent
firewall-cmd --reloadDownload WordPressThese latest version of WordPress are always available on https://wordpress.org/latest.tar.gz.cd /var/www/html
wget https://wordpress.org/latest.tar.gzExtract the downloaded archive to the document root of your domain and update permissions on files.tar xzf latest.tar.gz
chown -R apache.apache wordpress
chmod -R 755 wordpressAll DoneVisit 123.123.123.123/wordpress, and finish the installation.</description>
</item>
<item rdf:about="https://static.bobby285271.top/index.php/2017/10/21/How-to-Generate-a-Hexo-Blog-and-Deploy-it-on-GitHub.html">
<title>How to Generate a Hexo Blog and Deploy it on GitHub</title>
<link>https://static.bobby285271.top/index.php/2017/10/21/How-to-Generate-a-Hexo-Blog-and-Deploy-it-on-GitHub.html</link>
<dc:date>2017-10-20T16:00:00+00:00</dc:date>
<description>相信我，这是最最最适合懒人的 Hexo 教程！全文内容保证和百度搜到的完全不一样！只需一个浏览器，像玩转 Jekyll Now 那样玩转 Hexo 是完全有可能的！没错，我们将要用到的“黑科技”就是 Travis CI！ 毕竟这么高级的玩具（误）如果不拿来好好利用就浪费了。以下为正文部分，请注意：为了降低阅读门槛，我们提供了大量的代码供参考。在实际操作中，请不要一味地复制粘贴，所有代码中带有全角标点“【】”的地方请务必作相应的替换，不要保留中括号。扫盲HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。GitGit 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件，可以有效、高速的处理从很小到非常大的项目版本管理。GitHubGitHub 是最大的 Git 版本库托管商，是成千上万的开发者和项目能够合作进行的中心。 大部分 Git 版本库都托管在 GitHub，很多开源项目使用 GitHub 实现 Git 托管、问题追踪、代码审查以及其它事情。Travis CITravis CI 是目前新兴的开源持续集成构建项目，它采用 YAML 格式，简洁清新独树一帜。目前不少 GitHub 项目都已经移入到 Travis CI 的构建队列中。铺垫GitHub & Git 上手注册 GitHub 账户并验证邮箱前往 这里 注册邮箱，详情请阅读 官方文档（英文） 和 百度经验上的教程；前往这里 验证邮箱，详情请阅读 官方文档（英文）。GitHub 基本图形化操作请阅读 官方文档（英文），这里 提供了中文翻译。这个指南将帮助你了解创建和使用仓库、创建和管理分支、改变一个文件并将它提交到 GitHub 上和发起以及合并请求的方法。最最最基本的几个 Git 命令别被百度出来的什么命令大全吓到了，其实无非就几个命令：git init：在当前目录新建一个 Git 代码库;git clone 【项目 URL】：下载一个项目和它的整个代码历史；git add -A：添加当前目录的所有文件到暂存区；git commit -m 【提交信息】：提交暂存区到仓库区；git push 【远程仓库别称】 【分支】：上传本地指定分支到远程仓库；git pull 【远程仓库别称】 【分支】：取回远程仓库的变化，并与本地分支合并；git branch 【分支】：新建一个分支，但依然停留在当前分支；git checkout 【分支】 ：切换到指定分支，并更新工作区。若想深入学习可阅读 常用 Git 命令清单 和 官方文档，实际上等你真的用到这些功能时再百度慢慢学也不迟。当然，如果你连这些基本命令都看不懂，没关系，我们会在后面具体地介绍它们。Markdown 语法上手这是写博客必备的一种语法，而且学起来比你想象中简单很多，这里提供一个 说明文档 和一个 交互式入门向导（英文）。开始迈出第一步进入 GitHub 网站，登录你的账户，新建一个名为 【你的 GitHub 用户名】.github.io 的仓库，具体操作不再细讲。接下来应该看到的是类似这样的东西：Quick setup — if you’ve done this kind of thing before
or https://github.com/xxx/xxx.github.io.git

We recommend every repository include a README, LICENSE, and .gitignore.
…or create a new repository on the command line

echo &quot;# xxx.github.io&quot; &gt;&gt; README.md
git init
git add README.md
git commit -m &quot;first commit&quot;
git remote add origin https://github.com/xxx/xxx.github.io.git
git push -u origin master

…or push an existing repository from the command line

git remote add origin https://github.com/xxx/xxx.github.io.git
git push -u origin master

…or import code from another repository

You can initialize this repository with code from a Subversion, Mercurial, or TFS project.然而README、LICENSE 和 .gitignore，我一个都不想建，我们要开始建立用于初始化 Hexo 的 Travis CI 配置文件，“Create new file”的按钮我又找不到？很简单，文件都是可以改名的嘛，点击“README”这个链接，把人家帮你填的东西全部删掉，就可以开始你的骚操作啦。初始化 Hexo 的 Travis CI 配置文件将新建的文件命名为 .travis.yml（请勿改名），然后填写以下内容：language: node_js
node_js: stable

install:
  - npm install hexo-cli -g

script:
  - hexo init blog
  - cd blog/

after_script:
  - git init
  - git config user.name &quot;【你的大名，如 Bobby Rong】&quot;
  - git config user.email &quot;【你的邮箱】&quot;
  - git add -A
  - git commit -m &quot;【提交信息，如 Update files】&quot;
  - git push --force --quiet &quot;https://${githubblog}@${GH_REF}&quot; master

branches:
  only:
  - master
    
env:
 global:
  - GH_REF: github.com/【你的 GitHub 用户名】/【你的 GitHub 用户名】.github.io.git作相应替换后点击“Commit new file”即可。下面我来解释一下这是在干什么：这是初始化 Hexo 的 Travis CI 配置文件，待会把这个仓库加入构建队列，Travis 就会依次执行 install、script 和 after_script 这三个部分里面的命令，这些命令前面要加一个 - 千万别漏掉了。npm install hexo-cli -g：安装 Hexo-cli；hexo init blog：初始化博客；git init：初始化 Git 目录；git config user.name &quot;【你的大名，如 Bobby Rong】&quot;：配置 Git，填写提交者姓名（昵称也行）；git config user.email &quot;【你的邮箱】&quot;：配置 Git，填写提交者邮箱；git add -A：添加当前目录的所有文件到暂存区；git commit -m &quot;【提交信息，如 Update files】：提交暂存区到仓库区，提交信息可以随便填写；git push --force --quiet &quot;https://${githubblog}@${GH_REF}&quot; master：上传本地指定分支到远程仓库的 master 分支，${GH_REF} 为变量，Travis CI 会赋什么值扫一眼下面就知道了：github.com/【你的 GitHub 用户名】/【你的 GitHub 用户名】.github.io.git，${githubblog} 在后续配置后，会被 Travis CI 换成你 GitHub 的 Access Token，至于两个变量名为啥画风完全不同，嗯是故意的，就是为了烧死强迫症嘛。不过为了避免改完后到后面复制粘贴太爽有不知道改哪里，忍了吧。配置 Travis CI新建 Access Token毕竟 Travis CI 是不可能在提交代码时向你询问 GitHub 账户密码的，所以就有了这个东西的产生。首先我们来到 GitHub 的设置界面（没错就是点 GitHub 右上角的头像再点“Settings”），点击“Personal access tokens”，点击右上角的“Generate new token”按钮生成一个，点击后它会叫你输入密码，然后来到如下界面：New personal access token

Personal access tokens function like ordinary OAuth access tokens. They can be used instead of a password for Git over HTTPS, or can be used to authenticate to the API over Basic Authentication.

Token description
____________________
What's this token for?

Select scopes
Scopes define the access for personal tokens. Read more about OAuth scopes.

（下面就是一堆东西让你去勾选的）在 Token description 随便填个标题，下面是勾选一些权限，每一项旁边都有解释的，有强迫症的可以想想部署一个 Hexo 它应该需要一些什么权限，然后按需勾选；没有强迫症的就全部勾选了吧，反正 Travis CI 也只是乖乖地跑你的代码而已，真的出了事也只能怪你。生成完后，把那一串东西拷贝下来找个地方妥善保存，注意这和密码是一回事，不要偷懒把它放到 GitHub 上或别人能看到的地方。注意只有这时候它才显示出来，为了安全它以后就再也不会显示了，如果忘了只能重新生成一个了。添加环境变量与设定构建条件这时候就要前往 Travis CI 了。使用你的 GitHub 账户登录，随后前往 Accounts 页面（点击右上角的头像，选择“Accounts”）,找到"【你的 GitHub 用户名】/【你的 GitHub 用户名】.github.io"这一行，点击旁边的小齿轮进入该仓库的设置页面。几个地方需要设定：Gerenal 中启用“Build only if .travis.yml is present”和“Build branch updates”，不启用剩余两个；Environment Variables 中新建一个环境变量，在“Name”填写 githubblog（如果你手贱真的把前面的变量名改了记得把这里的也给改掉），“Value”填写你复制的那一串 Access Token，旁边的“Display value in build log”千万别启用，前面说过原因了。其它的如果你知道这是在干什么可以自己设定，不知道的都不用碰了。你的第一次构建在当前页面，点击“Current”，然后激活这个仓库。理论上你应该能看到 Build #1 正在运行，Job log 应该有东西在滚动输出。如果没有，只需点击“More options”，选择“Trigger build”，什么都不用设定，只需点击“Trigger custom build”就可以开始了，最终的构建日志看起来大概是这样的：Worker information
Build system information

W: http://dl.hhvm.com/ubuntu/dists/trusty/InRelease: Signature by key 36AEF64D0207E7EEE352D4875A16E7281BE7A449 uses weak digest algorithm (SHA1)
W: http://ppa.launchpad.net/couchdb/stable/ubuntu/dists/trusty/Release.gpg: Signature by key 15866BAFD9BCC4F3C1E0DFC7D69548E1C17EAB57 uses weak digest algorithm (SHA1)
$ git clone --depth=50 --branch=test https://github.com/xxx/xxx.github.io.git

Setting environment variables from repository settings
$ export githubblog=[secure]

Setting environment variables from .travis.yml
$ export GH_REF=github.com/bobby285271/blog-test.git

$ export PATH=./node_modules/.bin:$PATH
Updating nvm
$ nvm install stable
$ node --version
v8.6.0
$ npm --version
5.3.0
$ nvm --version
0.33.4
$ npm install hexo-cli -g
$ hexo init blog
INFO  Cloning hexo-starter to ~/build/bobby285271/blog-test/blog
Cloning into '/home/travis/build/bobby285271/blog-test/blog'...
Submodule 'themes/landscape' (https://github.com/hexojs/hexo-theme-landscape.git) registered for path 'themes/landscape'
Cloning into '/home/travis/build/bobby285271/blog-test/blog/themes/landscape'...
Submodule path 'themes/landscape': checked out 'decdc2d9956776cbe95420ae94bac87e22468d38'
INFO  Install dependencies
yarn install v0.27.5
info No lockfile found.
[1/4] Resolving packages...
warning hexo &gt; swig@1.4.2: This package is no longer maintained
[2/4] Fetching packages...
warning fsevents@1.1.2: The platform &quot;linux&quot; is incompatible with this module.
info &quot;fsevents@1.1.2&quot; is an optional dependency and failed compatibility check. Excluding it from installation.
[3/4] Linking dependencies...
[4/4] Building fresh packages...
success Saved lockfile.
Done in 10.64s.
INFO  Start blogging with Hexo!


The command &quot;hexo init blog&quot; exited with 0.
$ cd blog/


The command &quot;cd blog/&quot; exited with 0.
$ git init
$ git config user.name &quot;xxx&quot;
$ git config user.email &quot;xxx@xxx.com&quot;
$ git add -A
$ git commit -m &quot;xxx&quot;
$ git push --force --quiet &quot;https://${githubblog}@${GH_REF}&quot; master

Done. Your build exited with 0.站点配置回去 GitHub，重新进入 【你的 GitHub 用户名】.github.io 仓库，是否发现多了很多玩意？有这几个文件：scaffolds/、source/、.gitignore、_config.yml、package.json、yarn.lock，暂时不用管发生了什么，先把站点配置好。新建分支由于 GitHub 要求最终生成的网页必须在 master 分支，而我们却把源文件放在了这个分支，非常尴尬，把内容迁移走吧。很简单，只需新建一个分支，这里假设叫“blog-source”，同理，如果你不知道后面哪个地方要做相应调整就用这个名字吧。然后把这个新分支设定为默认分支（除非你知道后面要怎么相应作调整否则一定要设），点击那个“2 branches”，点击“Change default branch”，在“Default branch”这一栏有一个下拉框，选择新建的分支再选择“Update”。有些时候会让你输密码，完事。挑选一个主题终于不用面对一堆代码了，下面是考验你审美能力的时间。百度 Hexo 主题，选择一个你喜欢的又有 GitHub 仓库链接的主题。知乎 上有不少好的推荐。由于我对 Material Design 非常感兴趣，我选择的是 hexo-theme-material，注意有个 同名 的主题，要区分开来。如果你也选择了 hexo-theme-material（指 Viosey 创作的主题，下同），我还在本文后面附上配置这个主题的一些注意事项。选择完了之后，进入其 GitHub 的仓库，点击右上角的“Fork”以拷贝该项目的代码到自己这里。站点配置文件 config.yml接下来编辑 config.yml，这是整个博客站点的编辑文件，要修改的地方其实也不多，数数有多少个中括号就知道了。强调：所有的半角冒号后面都有一个空格别弄丢了。# Hexo Configuration
## Docs: https://hexo.io/docs/configuration.html
## Source: https://github.com/hexojs/hexo/

# Site
title: 【站点的标题】
subtitle: 【站点的副标题】
description: 【站点的描述】
author: 【作者名字】
language: 【这里填写 zh-CN】
timezone: 【这里填写 Asia/Shanghai】

# URL
## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'
url: 【这里填写 https://【你的 GitHub 用户名】.github.io，打算在后面绑定自己的域名的填写相应的完整 URL】
root: 【这里填写 /】
permalink: :year/:month/:day/:title/
permalink_defaults:

# Directory
source_dir: source
public_dir: public
tag_dir: tags
archive_dir: archives
category_dir: categories
code_dir: downloads/code
i18n_dir: :lang
skip_render:

# Writing
new_post_name: :title.md # File name of new posts
default_layout: post
titlecase: false # Transform title into titlecase
external_link: true # Open external links in new tab
filename_case: 0
render_drafts: false
post_asset_folder: false
relative_link: false
future: true
highlight:
  enable: true
  line_number: true
  auto_detect: false
  tab_replace:
  
# Search
search:
  path: search.xml
  field: all
  
# Home page setting
# path: Root path for your blogs index page. (default = '')
# per_page: Posts displayed per page. (0 = disable pagination)
# order_by: Posts order. (Order by date descending by default)
index_generator:
  path: ''
  per_page: 10
  order_by: -date
  
# Category &amp; Tag
default_category: uncategorized
category_map:
tag_map:

# Date / Time format
## Hexo uses Moment.js to parse and display date
## You can customize the date format as defined in
## http://momentjs.com/docs/#/displaying/format/
date_format: YYYY-MM-DD
time_format: HH:mm:ss

# Pagination
## Set per_page to 0 to disable pagination
per_page: 10
pagination_dir: page

# Extensions
## Plugins: https://hexo.io/plugins/
## Themes: https://hexo.io/themes/
theme: 【这里填写主题名称，允许起别名，后面我会提醒你在哪里作修改。例如 material】

# Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
type:保存退出即可。绑定个人域名（可选）如果你有一个个人域名需要绑定，进入 source/ 文件夹（默认情况下只有一个 source/_posts 的入口，很简单，先点进去，再返回上一级目录），新建一个 CNAME 的文件，在里面输入：【你打算绑定的域名，如 www.bobby285271.top】保存退出，然后参考 这篇教程 完成后续设置。写一篇博客进入 source/_posts 文件夹，新建一个文档，命名为 【文档名称，尽量统一只使用英文、数字和“-”】.md，内容大概是这样的：title: 【文章标题】
date: 【四位年份】-【两位月份】-【两位日期】
layout: post
tags: 
 - 【标签1】
 - 【标签2】
 - 【...】
categories:
 - 【分类父目录】
 - 【分类子目录】
 - 【...】
---

【从这里开始用 Markdown 写作】如果您有过使用 WordPress 的经验，就很容易误解 Hexo 的分类方式。WordPress 支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是 Hexo 不支持指定多个同级分类。下面的指定方法：categories:
- Diary
- Life会使分类“Life”成为“Diary”的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。建立一个独立页面和写博客差不多，进入 source/ 文件夹，新建一个文档，命名为 【填一个关键词，如 about】/index.md，这个网页就会在 【你的 GitHub 用户名】.github.io/【你填的关键词】 处显示，内容大概是这样的：title: 【页面标题】
date: 【可以空着，也可以仿照前面的填写】
layout: 【一般是 page，部分主题还提供其它的 layout，请以主题的文档为准】
---

【从这里开始用 Markdown 写作】主题配置主题太多，请参考主题提供的文档配置在前面 Fork 好的仓库，注意站点配置文件和主题配置文件都叫 _config.yml，但两个所在的仓库不同，功能也完全不同。如果你也选择了 hexo-theme-material，可以阅读 官方文档，注意：如果你想建立友情链接页、图库页、标签云页、时间轴页，请不要按照前面一章的内容做，而是按照 官方文档 的指示做，这样子做出来的页面好看很多。但注意，填写内容时第一行的 --- 请删掉，否则可能会出现各种问题；用个人惨痛的经历提醒各位：编辑站点配置文件时不要画蛇添足，如在不应该敲空格的地方敲空格（半角冒号后面一定要加一个空格），另外尽量避免负责粘贴！胜利的曙光构建博客的 Travis CI 配置文件这回又是配置 Travis CI，注意上次配置的文件是一次性的，你应该找不到它才对。返回【你的 GitHub 用户名】.github.io 仓库，检查你所在的分支是否为 blog-source，若不是按照前面所讲修改默认分支，新建文件，命名为 .travis.yml（请勿改名），然后填写以下内容：language: node_js
node_js: stable

install:
  - npm install

script:
  - git submodule add https://github.com/bobby285271/【主题在 GitHub 仓库的仓库名，如 hexo-theme-material】.git themes/【改成你在站点配置文件中填写的主题别称，如 material】
  - hexo g

after_script:
  - cd ./public
  - git init
  - git config user.name &quot;【你的大名，如 Bobby Rong】&quot;
  - git config user.email &quot;【你的邮箱】&quot;
  - git add -A
  - git commit -m &quot;【提交信息，如 Update files】&quot;
  - git push --force --quiet &quot;https://${githubblog}@${GH_REF}&quot; master

branches:
  only:
    - blog-source
    
env:
 global:
  - GH_REF: github.com/【你的 GitHub 用户名】/【你的 GitHub 用户名】.github.io.git作相应替换后点击“Commit new file”即可。和之前的配置文件看起来差不多的，解释一下：git submodule add https://github.com/【你的 GitHub 用户名】/【主题在 GitHub 仓库的仓库名，如 hexo-theme-material】.git themes/【改成你在站点配置文件中填写的主题别称，如 material】：将你所 Fork 的主题仓库添加到站点仓库中；hexo g：生成网页；cd ./public：生成的网页都在这里面，我们只要里面的文件。成功回到 Travis CI，按照前面所讲查看自己的构建进度，只需仓库名旁边的图标变成了 Build passing（底色还是原谅绿），你就可以前往 https://【你的 GitHub 用户名】.github.io 或你绑定的域名查看你的网页了。至于后续修改，只需前往【你的 GitHub 用户名】.github.io 仓库，确认所在分支后编辑相应的文件就行了，详情请参考 Hexo 的 官方文档，一旦仓库有变动，Travis 就会自动构建新的网页。教程到此结束。</description>
</item>
</rdf:RDF>