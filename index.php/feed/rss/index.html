<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://static.bobby285271.top/index.php/feed/rss/">
<title>Dasyatis</title>
<link>https://static.bobby285271.top/</link>
<description>Life, Love, Linux</description>
<items>
<rdf:Seq>
<rdf:li resource="https://static.bobby285271.top/index.php/2020/07/15/WIP-Introduction-to-Django---Illustrated-by-the-Example-of-SCNUSE-SoCoding-1024-Website.html"/>
<rdf:li resource="https://static.bobby285271.top/index.php/2020/04/15/NixOS-Installation-and-Configuration-Guide.html"/>
<rdf:li resource="https://static.bobby285271.top/index.php/2020/02/18/How-to-Port-Calamares-to-Arch-Linux-en.html"/>
<rdf:li resource="https://static.bobby285271.top/index.php/2020/02/09/2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html"/>
<rdf:li resource="https://static.bobby285271.top/index.php/2020/02/03/How-to-Deploy-WordPress-on-a-Fedora-Server-en.html"/>
<rdf:li resource="https://static.bobby285271.top/index.php/2019/12/26/Dynamic-Programming-on-Tree-Structures-Luogu-P2014.html"/>
<rdf:li resource="https://static.bobby285271.top/index.php/2019/12/18/Introduction-to-Segment-Tree-Luogu-P3372.html"/>
<rdf:li resource="https://static.bobby285271.top/index.php/2019/12/13/SCNUCS-N-2019-Tour.html"/>
<rdf:li resource="https://static.bobby285271.top/index.php/2019/11/17/Dynamic-Prgramming---0-1-Backpack-Problem-Luogu-P1164-P1048-P1020.html"/>
<rdf:li resource="https://static.bobby285271.top/index.php/2019/10/05/How-to-Launch-a-Desktop-Environment-on-WSL-2.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://static.bobby285271.top/index.php/2020/07/15/WIP-Introduction-to-Django---Illustrated-by-the-Example-of-SCNUSE-SoCoding-1024-Website.html">
<title>[WIP] Introduction to Django - Illustrated by the Example of SCNUSE SoCoding 1024 Website</title>
<link>https://static.bobby285271.top/index.php/2020/07/15/WIP-Introduction-to-Django---Illustrated-by-the-Example-of-SCNUSE-SoCoding-1024-Website.html</link>
<dc:date>2020-07-15T12:04:00+00:00</dc:date>
<description>本文尚未完成，正在更新注册页部分，最后更新时间 7 月 18 日中午。好久没有出文章了，放暑假有点时间，尝试再造一遍 2019 年 SCNUSE 软协 1024 程序员节活动网站（尽量还原，会有一些差别），算是 Django 框架的一个学习项目吧。博主本人的基本功也不怎么扎实，下文用到了非常多不严谨的表述，如果有任何错误欢迎指出。要实现什么去年也是参与到这个活动中来了，但是只是做了一个关卡，比较划水。这里就略过需求分析系统设计什么的了，简单来说整个网站做的就是注册登录和七个关卡。去年最后具体实现用到的是 Django 框架，使用 MySQL 数据库，但是这里将使用 SQLite 数据库。铺垫博主认为有一些技能在开始动手之前还是要先掌握的。首先是 Python，其实有了程序设计基础之后 Python 的语法其实很简单。完全不会 Python 的推荐看 Python 100 天教程 前 15 天部分的内容，然后找个 Online Judge 做几道水题，最多两个小时应该都能熟悉。然后是 Web 前端 HTML、CSS、Javascript 的一些最基本的应用，学校讲的足够用了，这里推荐 菜鸟教程，可以尝试自己写一些小的静态网站。最后 Django 本身还是要先做了解的。可以简单浏览 Python 100 天教程 第 14 天和第 41 天的内容，另外也推荐阅读官方推荐的一些 设计理念 。准备先来做一些准备工作，包括开发环境的配置、项目和应用的初始化。开发环境可以按照自己的喜好来配置，不一定要按照这里的来；项目和应用的初始化有对应的具体的命令，执行即可。开发环境要做的事情就是安装一个对 Python 支持良好的 IDE 或者为你的代码编辑器添加 Python 支持，然后安装 Django。假设你跟我一样已经是 Arch Linux + VS Code 用户。VS Code 下的 Python 支持是需要到 pip 的，pip 是 Python 的包管理器，直接使用 Linux 下的包管理器安装。# pacman -S python-pippip 既然是包管理器，能条件反射到的是肯定要换源，我们在家目录创建并编辑 .pip/pip.conf：$ cd 
$ mkdir .pip
$ nano .pip/pip.conf[global]
index-url = https://pypi.tuna.tsinghua.edu.cn/simple启动 VS Code，先装上 Python 扩展和 Visual Studio IntelliCode 扩展，然后打开任意 Python 文件，尝试格式化文档，VS Code 就会提示你安装格式化程序，安装就可。可以观察到实质就是调用 pip 安装 autopep8。接下来安装 Django，这里有两个方法，一个是继续使用 Linux 下的包管理器安装：# pacman -S python-django`或者是用上面刚刚讲到的 pip：$ pip install django要注意的是给 Arch Linux 软件包锁版本是不被提倡的，毕竟是滚动更新发行版。所以如果你使用 Pacman 安装 python-django 就得一直跟着系统走用最新版，要考虑其利弊。接下来尝试使用 django-admin 命令，测试一下是不是一切都准备妥当了：$ django-admin version理想情况是输出一个版本号。如果提示命令没有找到，那就是在普通用户下使用 pip 按照 Django 导致 django-admin 不在 PATH 里。解决方法很多，例如改用 root 安装，或是修改 PATH，可以参考 官方文档。创建项目我们首先使用 django-admin 命令为站点创建一个已经初始化的项目目录，不妨叫 mysite。如果你起的名字跟我的不一样，只要看到 mysite 改过来就行，另外不要用保留字命名，后面也是一样的道理。$ django-admin startproject mysite
$ cd mysite进入项目目录之后，应该能见到另一个 mysite/ 目录和一个 manage.py 文件：mysite/ 包含了 Django 项目实例需要的设置项集合，包括数据库配置、Django 配置和应用配置。manage.py 就是一个让你用各种方式管理 Django 项目的命令行工具。我们约定，后面涉及的所有文件和文件夹均以当前所在的项目目录为基准标注相对路径。创建应用在 Django 中，每一个应用都是一个 Python 包。应用通常是一个专门做某件事的网络应用程序，比如博客系统、投票程序。项目则是一个网站使用的配置和应用的集合。一个项目可以包含很多个应用，但这里我们只创建一个，就叫 myapp：$ python manage.py startapp myapp接下来往项目添加这个应用。编辑 mysite/settings.py，找到 INSTALLED_APPS：这里没有展示整个的完整的文件，只会展示需要改动的代码或是关键的代码，后面也是一样的道理。我们会在文末附上成品的代码，可以结合成品代码理解。INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'myapp',
]站点调试我们可以利用 manage.py 运行 Django 自带的用于开发的简易 Web 服务器对我们的网站进行预览和调试。不要将这个服务器用于和生产环境相关的任何地方，这个服务器只是为了开发而设计的。$ python manage.py runserver终端应该会输出类似这样的东西：Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.按照上面的输出，我们打开浏览器访问 http://127.0.0.1:8000/，在下文中我们假设你的服务器设置和我的一样为监听本机内部 IP 的 8000 端口。在一个网页都没有完成的情况下，你应该能看到 Django 自带的测试页面。当我们写好我们的网站之后则应该能看到自己的网站，测试页面就不会再出现了。现在我们尝试将测试页面改成中文的，其实是为 Django 设置语言。编辑 mysite/settings.py：LANGUAGE_CODE = 'zh-hans'
TIME_ZONE = 'Asia/Shanghai'不必重新启动服务器，直接刷新页面，现在测试页面显示的是中文，你的改动生效了。通常来说服务器会对每一次的访问请求重新载入一遍 Python 代码，但是例外还是有的（如添加新文件）。如果你发现你的改动没有生效，尝试重启服务器就好了。如果你想把服务器停掉，就按照终端的提示按下 Ctrl + C 组合键即可，和 Linux 杀死其它命令的方式是一样的。第一个页面几乎所有教程做第一个页面都是 Hello World，虽然这和 1024 站点没啥关联，我们也先实现一下，目标是访问站点首页后显示一行文字 Hello World。博主认为虽然是 Hello World，但可能还是会有点难度。其实不需要纠结太多，关键是记住具体的实现，知道哪些地方是套路，哪些地方要改动。我们在后面会制作更多的页面，自然就会熟悉了。响应与视图函数视图函数（简称视图）是一个简单的 Python 函数，它接受 Web 请求并且返回 Web 响应。响应可以是 HTML、重定向、404、XML、图片等等。无论视图函数本身包含什么逻辑，都要返回响应。我们通常将视图函数放置在 views.py 文件中。我们现在只需要在页面上显示上一行 Hello World，所以这个视图函数不需要做什么，直接返回响应就行。既然是首页，不妨将函数命名为 index，我们看看具体的实现。编辑 myapp/views.py：from django.shortcuts import render, redirect
from django.http import HttpResponse

def index(request):
    return HttpResponse(&quot;&lt;h1&gt;Hello, World&lt;/h1&gt;&quot;)视图函数就写好啦！这里我们用到了 HttpResponse 对象，你可以翻阅 官方文档 了解这个对象，并尝试将 &lt;h1&gt;Hello, World&lt;/h1&gt; 改成其它内容。URL 的映射接下来我们建立 URL（统一资源定位符）与视图函数 index 的映射。具体可以分成两步，第一步是在应用下面处理自己的映射关系，第二步是进行路由分发。博主认为这可以理解为一个相对路径的确定，当然这里的路径指的是我们访问的 URL，和项目文件的放置没有关联。第一步实际上就是将应用根目录的绝对路径作为基准，确定各个网页的相对路径。第二步就是将项目根目录的绝对路径作为基准，确定各个应用根目录的相对路径。现在我们想在首页显示 Hello World，我们来看看具体的实现。先来做第一步，在 myapp 下面新建一个 urls.py：from django.urls import path
from . import views

urlpatterns = [
    path('', views.index, name='index'),
]path('', views.index, name='index') 可以理解为这个网页就位于应用的根目录，响应的是 views.py 文件里的 index 函数。而最后的 name='index' 则是指定 name 属性，这里的 name 和 HTML 下的 id 属性是类似的，必须要唯一。我们会在后面用到它。再来做第二步，编辑 mysite/urls.py：from django.contrib import admin
from django.urls import include, path

urlpatterns = [
    path('', include('myapp.urls')),
    path('admin/', admin.site.urls),
]path('', include('myapp.urls')) 可以理解为 myapp 这个应用的根目录就位于项目的根目录，path('admin/', admin.site.urls) 为 Django 自带的管理页面，可以暂时不用理会，我们会在后面用到它。当然了这样的理解自然是不严谨的，还是建议大家深入了解 URL 和路由，详情可以查阅 官方文档。现在使用 python manage.py runserver 调试，访问 http://127.0.0.1:8000/，显示的是 Hello World 页了。我们来看看另一个例子，假设我们要在已有的项目 mysite 下创建一个应用 yourapp，这个应用下我想做很多个网页。我希望这些网页都在 http://127.0.0.1:8000/abcdefg/ 目录下访问到。现在希望你实现其中两个网页：一个是 Goodbye World 页面我希望在 http://127.0.0.1:8000/abcdefg/goodbyeworld/ 访问到它.一个是 Hello Django 页面我希望在 http://127.0.0.1:8000/abcdefg/hellodjango/ 访问到它。页面显示什么无所谓。[collapse status="false" title="点击这里查看具体实现"]创建应用 yourapp：$ python manage.py startapp yourapp往项目添加这个应用，编辑 mysite/settings.py，找到 INSTALLED_APPS：INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'myapp',
    'yourapp',
]首先是视图函数，函数名不妨用拼音命名法，既然页面显示什么无所谓，我们编辑 yourapp/views.py：def zaijianshijie(request):
    return HttpResponse(&quot;&lt;p&gt;什么无所谓&lt;/p&gt;&quot;)

def nihaodjango(request):
    return HttpResponse(&quot;&lt;p&gt;什么无所谓&lt;/p&gt;&quot;)接下来在应用下面处理自己的映射关系，这里不对 name 属性进行指定，我们新建并编辑 yourapp/urls.py：urlpatterns = [
    path('goodbyeworld/', views.zaijianshijie),
    path('hellodjango/', views.nihaodjango),
]第二步是进行路由分发，我们编辑 mysite/urls.py：urlpatterns = [
    path('abcdefg/', include('yourapp.urls')),
    path('', include('myapp.urls')),
    path('admin/', admin.site.urls),
]尝试访问这两个网页，看看是否能按照你的期望工作？好了这个小练习到此结束，我们删除 yourapp 这个应用，因为我们并不需要到它。首先删除 yourapp/ 目录，然后编辑 mysite/urls.py，删除 path('abcdefg/', include('yourapp.urls')) 这一行，接下俩编辑 mysite/settings.py，从 INSTALLED_APPS 删除 'yourapp'。[/collapse]注册页的实现准备首先我们再再再做一遍 Hello World，我们希望在访问 http://127.0.0.1:8000/register/ 能看到「注册页」三个字，路由分发我们在做 Hello World 页的时候已经做好了，我们只需要在 myapp 处理映射关系就行。[collapse status="false" title="点击这里查看具体实现"]首先是视图函数，我们编辑 myapp/views.py：def register(request):
    return HttpResponse(&quot;&lt;p&gt;注册页&lt;/p&gt;&quot;)接下来在应用下面处理自己的映射关系，我们编辑 myapp/urls.py：urlpatterns = [
    path('', views.index, name='index'),
    path('register/', views.register, name='register'),
][/collapse]现在访问注册页，显示的只有三个字「注册页」，但我们实际需要的是：前端一个表单供用户输入账户密码，后端处理用户输入与数据库交互。接下来，我们会根据实际的需求进一步改造这个注册页，使其达到我们所要的效果。模板首先是前端，刚刚学完 Web 前端，应该不是什么难点。现在的问题讲通俗点就是，怎样做到我访问这个地址就显示一个 HTML 文件呢？一个方法是，我把这个 HTML 文件压成一行，换掉 &lt;p&gt;注册页&lt;/p&gt; 。可以是可以，但是一个很最突出的问题是维护起来很难受。事实上这样子其实是将数据与视图混合在一起，我们说是不符合 Django 的 MVC 思想（Model View Controller，具体请百度）。于是我们有了另外一个东西叫做模板。我们可以在 官方文档 How-to 部分 找到相关的文档。目前而言，你可以简单地把模板跟 HTML 文件划上等号。模板是有专门地方存放的，在 myapp/ 下面建立一个 templates/ 文件夹。接下来往里面放你的 HTML 文件。例如我把注册页命名为 register.html，也就是说文件的相对路径为 myapp/templates/register.html。就和初学 Web 前端一样，先不要管样式，也不要管按钮链接能不能工作，这些在后面会提及。为了节省时间，这里就直接开抄了。以下的代码为去年的代码改动而来：[collapse status="false" title="点击这里查看具体实现"]&lt;!DOCTYPE html&gt;
&lt;html&gt;

&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;register&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div class=&quot;lg_content&quot;&gt;
        &lt;table cellspacing=&quot;30px&quot; align=&quot;center&quot;&gt;
            &lt;form method=&quot;post&quot; action=&quot;#&quot;&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;2&quot;&gt;
                        &lt;input type=&quot;text&quot; name=&quot;userid&quot; class=&quot;reg_ip&quot; placeholder=&quot;学号&quot;&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;2&quot;&gt;
                        &lt;input type=&quot;text&quot; name=&quot;username&quot; class=&quot;reg_ip&quot; placeholder=&quot;昵称&quot;&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;2&quot;&gt;
                        &lt;input type=&quot;password&quot; name=&quot;passwd&quot; class=&quot;reg_ip&quot; placeholder=&quot;密码&quot;&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;2&quot;&gt;
                        &lt;input type=&quot;password&quot; name=&quot;repasswd&quot; class=&quot;reg_ip&quot; placeholder=&quot;确认密码&quot;&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;

                &lt;tr&gt;
                    &lt;td align=&quot;left&quot;&gt;

                        &lt;input type=&quot;submit&quot; value=&quot;注册&quot; style=&quot;position:relative;left:40px;&quot; class=&quot;button&quot;&gt;

                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/form&gt;
            &lt;td align=&quot;center&quot; style=&quot;position:relative;left:-50px&quot;&gt;
                &lt;span class=&quot;font1&quot;&gt;已经注册？&lt;/span&gt;
                &lt;input type=&quot;submit&quot; class=&quot;button&quot; style=&quot;height:25px;width:80px;font-size:12px&quot; value=&quot;直接登录&quot;
                    onclick=&quot;location.href='#'&quot;&gt;
            &lt;/td&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;[/collapse]接下来我们把「注册页」三个字换掉，这里我们使用的是 render 方法，它可接收三个参数，一是 request 参数，二是待渲染的 HTML 模板文件，三是保存具体数据的字典参数。它的作用就是将数据填充进模板文件，最后把结果返回给浏览器。编辑 myapp/views.py：def register(request):
    return render(request, 'register.html')我们再访问 http://127.0.0.1:8000/register/，发现已经有一个注册页面的样子了。静态资源现在我们来做注册页的样式吧！你们可能尝试过在 templates/ 直接放一个 CSS 文件，然后在 register.html 直接加 &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;，你会发现是行不通的，它实际请求的是 http://127.0.0.1:8000/register/style.css，直接 404。注意到 mysite/settings.py 有这么一行：# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/3.0/howto/static-files/

STATIC_URL = '/static/'事实上，关于静态资源的存放，官方文档 How-to 部分 依然给出了具体的说明。和模板类似，我们要单独建立 static/ 目录来存放这些静态资源。通常我们把这个目录放在应用目录下，我们 myapp/ 下新建 static/ 目录，里面再建一个 css/ 目录。接下来，我们尝试往 css/ 目录里面添加我们的样式。这个样式我们会在后面多次使用，编辑 myapp/static/css/style.css，这里我们继续偷懒开抄：[collapse status="false" title="点击这里查看具体实现"]body {
    /* background: url(&quot;../img/bg_img.jpg&quot;); */
    /* background-size: cover; */
    margin: 0px;
    padding: 0px;
    text-align: center;
}

.containerDiv {
    margin-top: 0;
    margin-bottom: 0;
    background-size: 100% 100%;
    width: 100%;
    text-align: center;
}

.lg_content {
    margin-top: 100px;
}

.titleDiv {
    width: 100%;
    height: 150px;
}

.problemDiv {
    width: 80%;
    height: 360px;
    margin-left: 10%;
    margin-right: 10%;
    position: relative;
}

.leftDiv {
    width: 50%;
    height: 360px;
    text-align: center;
    float: left;
}

.rightDiv {
    width: 40%;
    margin-left: 10%;
    height: 360px;
    text-align: center;
    float: left;
}

.answerDiv {
    width: 100%;
    height: 60px;
    position: relative;
}

.background {
    background-size: 100% 100%;
    width: 100%;
    height: 100%;
}

.button {
    width: 68px;
    height: 34px;
    font-size: 18px;
    color: rgb(255, 255, 255);
    background-color: rgb(76, 129, 179);
    box-shadow: none;
    border: none;
    border-style: inline;
}

.input {
    height: 40px;
    width: 250px;
    font-size: 14px;
    color: rgba(155, 152, 151, 0.774);
    border: none;
    box-shadow: none;
    border-style: none;
    border-width: 0px;
}

.font1 {
    font-family: &quot;Microsoft YaHei&quot;;
    font-size: 12px;
    font-weight: bold;
    color: azure;
}

.font2 {
    font-family: &quot;Microsoft YaHei&quot;;
    font-size: 22px;
    width: 400px;
    color: rgb(88, 99, 192);
}

#game_div,
p {
    width: 400px;
    margin: auto;
    margin-top: 0px;
}[/collapse]根据 STATIC_URL = '/static/' 这一线索，我们尝试访问 http://127.0.0.1:8000/static/css/style.css，发现确实是有这个文件的。事实上，只要将 &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt; 改成 &lt;link href=&quot;/static/css/style.css&quot; rel=&quot;stylesheet&quot;&gt; 就可以往页面加载样式了。但是，这样后续维护是很困难的。一个问题是如果我们后面突然又需要创建应用，需要的是不同的样式呢？想象一下，你有两个应用 myapp 和 yourapp，然后你在 myapp/static/css/style.css 和 yourapp/static/css/style.css 放了不同的样式文件，你访问 http://127.0.0.1:8000/static/css/style.css 得到的是什么呢？对这个问题，官方的解决方案是，在 myapp/static/ 下面再建立一个目录 myapp（就是应用本身的名称），然后把静态资源放里面，我们尝试将 myapp/static/css 目录移动到 myapp/static/myapp/css。现在我们在 http://127.0.0.1:8000/static/myapp/css/style.css 可以看到我们的样式文件了。另一个问题是如果我突然想更换一下映射到静态资源的 URL 呢？也就是说我把 STATIC_URL = '/static/' 改成别的，是不是所有的 HTML 文件我要逐个修改呢？所以我们是不建议按照前面的方式去写的，我们有一个船新的方法。编辑 myapp/templates/register.html：&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;register&lt;/title&gt;
    {% load static %}
    &lt;link href=&quot;{%static 'myapp/css/style.css'%}&quot; rel=&quot;stylesheet&quot;&gt;
&lt;/head&gt;要注意的是 {% load static %} 和 {%static 'myapp/css/style.css'%} 的 static 和 STATIC_URL = '/static/' 中的路径 static 是没有任何联系的，就是静态资源的意思。你可以尝试将 STATIC_URL 改成别的再来试试。现在访问 http://127.0.0.1:8000/register/，F12 看一下，会发现上面 {% %} 标签的内容都已经被替换掉了。接下来是背景图片。同样地，我们将 bg_img.jpg 放置在 myapp/static/myapp/img/ 目录中。这回没那么复杂，在 CSS 文件里引用时直接写相对路径即可，因为无论怎么修改 STATIC_URL 都不会对其产生影响：body {
    background: url(&quot;../img/bg_img.jpg&quot;);
    background-size: cover;
    margin: 0px;
    padding: 0px;
    text-align: center;
}好了，现在注册页看上去跟去年是一个样子了。数据库与模型来到后端部分了！后端部分是离不开数据库的，我们首先把数据库配置好。这里我们使用的是 SQLite 数据库，为什么在这个项目使用 SQLite 呢？轻量，无客户端和服务器端之分，跨平台，单文件。我们现在做的网站也只是供我们自娱自乐的而已，没有高并发。Python 内置 SQLite，所以你无需安装额外东西来使用它。不需要事先创建数据库，数据库会在需要的时候自动创建。Django 默认的数据库就是 SQLite，我们查看 mysite/settings.py：DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}让我们开始吧！首先我们对设定的数据库进行初始化：$ python manage.py migrate所谓的初始化实际上是迁移操作，为在 mysite/settings.py 涉及到的 INSTALLED_APPS 创建一些数据表。这里先不需要去纠结具体是做什么的，有兴趣的可以查看 官方文档。我们在后面还会使用到这个命令，到时再做说明。接下来我们进行数据表字段的规划。在 Django，我们称数据库结构设计为模型。你可以把模型类比为数据库里的数据表，在这里我们只需要为学生这个对象创建一个模型，不妨将它命名为 STUDB。下面我们就来实现这个模型，博主认为整个流程和 Git 提交代码的流程非常类似。在 Git 我们并不会在版本库直接改动代码，而是：第一步，你在工作区对文件作出改动，你的改动并不会影响到版本库。第二步，git add：你的改动从工作区被转移到了暂存区。第三步，git commit：你的改动从暂存区被转移到了版本库。在这个项目，我们的第一步就是编辑 myapp/models.py 文件，在文件记录我们需要的模型。作为我们需要建立的唯一一个模型，我们要为其添加的字段有：实际的字段规划应该在需求分析和系统设计阶段完成。字段名数据类型作用备注userid文本 TextField学号最大长度为 11 max_length=11username文本 TextField昵称最大长度为 10 max_length=10passwd文本 TextField密码最大长度为 20 max_length=20firstflag时间 DateTimeField普通关卡开始时间默认是当前时间lastflag时间 DateTimeField普通关卡通关时间默认是当前时间superflag时间 DateTimeField最后一关通关时间默认是当前时间specialflag时间 DateTimeField彩蛋通关时间默认是当前时间rank整数 IntegerFieldRank 记录默认是 1timesubtract整数 IntegerField普通关卡时间差默认是 0timesubtract_last整数 IntegerField最后一关时间差默认是 0timesubtract_suprise整数 IntegerField彩蛋时间差默认是 0我们可以在 官方文档 找到可能需要用到的数据类型。接下来我们将表格转为代码。在 myapp/models.py 在这个文件中，每个模型被表示为一个类。每个模型有许多类变量，它们都表示模型里的一个数据库字段。我们可以在 官方文档 找到很多代码实现的例子。[collapse status="false" title="点击这里查看具体实现"]from django.db import models
import django.utils.timezone as timezone

class STUDB(models.Model):
    userid = models.TextField(max_length=11)
    username = models.TextField(max_length=10)
    passwd = models.TextField(max_length=20)
    firstflag = models.DateTimeField(default=timezone.now)
    lastflag = models.DateTimeField(default=timezone.now)
    superflag = models.DateTimeField(default=timezone.now)
    specialflag = models.DateTimeField(default=timezone.now)
    rank = models.IntegerField(default=1)
    timesubtract = models.IntegerField(default=0)
    timesubtract_last = models.IntegerField(default=0)
    timesubtract_suprise = models.IntegerField(default=0)[/collapse]接下来是第二步，我们让 Django 检测你对模型文件的修改，并且把修改的部分储存为一次迁移。$ python manage.py makemigrations最后是第三步，在数据库里创建新定义的模型的数据表。$ python manage.py migrate表单处理与数据库交互既然数据库已经配置完毕，接下来我们要做的是读取用户的输入并写入数据库。怎样获取和处理用户的输入呢？Web 前端曾经讲过怎样用 Javascript 处理 GET 请求和 POST 请求，这里也是类似的，甚至还简单一些。首先还是要回到前端，我们已经写了一个 form 表单，目前我们的 form 标签是这样的：&lt;form method=&quot;post&quot; action=&quot;#&quot;&gt;&lt;/form&gt;我们需要将 action 属性补充完整。为此我们需要另外制作一个「页面」用来接收表单的信息，这个页面不一定要给用户看到些什么。我们在这个页面处理完用户的信息后就会跳转到相应的页面。我们把这个页面命名为 register_to_db。我们来写一下视图函数，这回我们需要进行一些逻辑上的处理了，所以这个函数注定要写的又臭又长，我们拆分一下我们要实现的逻辑。首先，我们要接收表单发过来的 POST 请求。在 Web 前端课程上，我们已经知道前端表单的 name 属性会被用于对提交到服务器后的表单数据进行标识。所以我们现在要接收的，就是 userid、username、passwd 和 repasswd。userid = request.POST.get('userid', None)
username = request.POST.get('username', None)
passwd = request.POST.get('passwd', None)
repasswd = request.POST.get('repasswd', None)接下来，我们看看学号是否已经被注册，如果被注册了，我们就跳转回注册页。从这里开始，我们就要用到数据库的增删改查操作了，然而我们并不需要写 SQL 语句，因为 Django 模型使用自带的对象关系映射（ORM）连接业务逻辑层和数据库层。简单来说，ORM 会将 Python 代码转成为 SQL 语句。菜鸟教程 提供了数据库增删改查实现的不少例子，可供参考。我们也来照葫芦画瓢，首先导入我们的模板，接下来我们使用 filter 方法查询学号信息，返回一个列表：from .models import STUDB
users = STUDB.objects.filter(userid=userid)如果这个列表不为空，意味着这个学号已经被注册，我们就跳转回注册页。怎样实现跳转呢，可以想到的第一个方法是直接使用之前讲过的 render 方法：if len(users) == 1:
    return render(request, 'register.html')会发现确实是重新「显示」注册页了，但是我们看 URL 并没有变，依然是 http://127.0.0.1:8000/register_to_db/。我们不要忘了 register.html 只是一个模板而已。但是我们希望的是跳转到 http://127.0.0.1:8000/register/。这里我们就要介绍到我们的 redirect 方法了，它专为重定向而生，我们看看它最基本的使用方法：if len(users) == 1:
    return redirect(&quot;http://127.0.0.1:8000/register/&quot;)和我们学 Web 前端接触的 a 标签的 href 属性几乎一样，填上 URL 就行。当然，上面这样填写绝对路径是不利于后续维护的。哪怕改成相对路径 redirect(&quot;../register/&quot;)，由于我们可以随时修改 myapp/urls.py 中的映射关系，事实上也不是什么好方法。还记得我们刚开始编辑 myapp/urls.py 时提到的 name 吗？[collapse status="false" title="点击这里查看具体实现"]path('register/', views.register, name='register')[/collapse]现在是将它派上用场的好机会。我们使用 reverse 方法，填上注册页的 name 参数：from django.shortcuts import render, reverse, redirect
if len(users) == 1:
    return redirect(reverse('register'))接下来我们再进一步，我们希望跳转过去之后弹出一条提示。我们知道 GET 的参数就是在 URL 后面跟一个 ?，然后是参数列表。不妨就利用 GET 请求通知注册页弹窗，具体的弹窗实现我们稍后再提及：from django.shortcuts import render, reverse, redirect
if len(users) == 1:
    return redirect(reverse('register')+&quot;?code=-1&quot;)我们尝试实现另外的几个逻辑，首先是判断输入是否齐全，然后是判断学号是否为 11 位且开头为 201，然后是判断密码是否是 6-18 位且必须是英文字母或数字，最后判断两次输入的密码是否一致。这里需要使用到正则表达式。[collapse status="false" title="点击这里查看具体实现"]import re

# 判断是否为空
if not userid or not passwd or not username or not repasswd:
    return redirect(reverse('register')+&quot;?code=-5&quot;)

# 判断学号格式
if not re.match(r'^(201).*\d{8}$', userid):
    return redirect(reverse('register')+&quot;?code=-4&quot;)

# 判断密码是否为 6-18 位且为字母或数字
if not re.match(r'^[A-Za-z0-9]{6,18}$', passwd):
    return redirect(reverse('register')+&quot;?code=-3&quot;)

# 判断两次密码是否一致
if passwd != repasswd:
    return redirect(reverse('register')+&quot;?code=-2&quot;)[/collapse]如果没啥问题，我们就可以写入数据库了，然后跳转到登录页。现在我们用到的是 save 函数。这里博主再次给出 菜鸟教程 的链接。然而我们还没有登录页。我们再再再再做一遍 Hello World，先摆上「登录页」三个大字（代码实现见下一节），别忘了在写 URL 映射的时候要把 name 参数设定好，假设是 login。STUDBdent = STUDB.objects.create(
    userid=userid, username=username, passwd=passwd)
STUDBdent.save()
return redirect(reverse('login')+&quot;?code=1&quot;)视图函数就写好了，我们再来检查一下我们刚才写的东西：[collapse status="false" title="点击这里查看具体实现"]from django.shortcuts import render, reverse, redirect
from django.http import HttpResponse
import re
from .models import STUDB

def register_to_db(request):
    userid = request.POST.get('userid', None)
    username = request.POST.get('username', None)
    passwd = request.POST.get('passwd', None)
    repasswd = request.POST.get('repasswd', None)
    if not userid or not passwd or not username or not repasswd:
        return redirect(reverse('register')+&quot;?code=-5&quot;)
    if not re.match(r'^(201).*\d{8}$', userid):
        return redirect(reverse('register')+&quot;?code=-4&quot;)
    if not re.match(r'^[A-Za-z0-9]{6,18}$', passwd):
        return redirect(reverse('register')+&quot;?code=-3&quot;)
    if passwd != repasswd:
        return redirect(reverse('register')+&quot;?code=-2&quot;)
    users = STUDB.objects.filter(userid=userid)
    if len(users) == 1:
        return redirect(reverse('register')+&quot;?code=-1&quot;)
    STUDBdent = STUDB.objects.create(
        userid=userid, username=username, passwd=passwd)
    STUDBdent.save()
    return redirect(reverse('login')+&quot;?code=1&quot;)[/collapse]接下来别忘了把映射关系写好：[collapse status="false" title="点击这里查看具体实现"]编辑 myapp/urls.py：urlpatterns = [
    path('', views.index, name='index'),
    path('register/', views.register, name='register'),
    path('login/', views.login, name='login'),
    path('register_to_db/', views.register_to_db, name='register_to_db'),
][/collapse]接下来，我们回到前端的表单，我们把这个 form 标签给鸽了很久了。&lt;form method=&quot;post&quot; action=&quot;#&quot;&gt;&lt;/form&gt;首先是 action 属性。在后端，我们使用的是 reverse 方法，回忆一下？[collapse status="false" title="点击这里查看具体实现"]return redirect(reverse('login')+&quot;?code=1&quot;)[/collapse]在模板这里，我们可以使用 {% url %} 标签。我们曾经讲过 {% static %} 标签，回忆一下？[collapse status="false" title="点击这里查看具体实现"]{% load static %}
&lt;link href=&quot;{%static 'myapp/css/style.css'%}&quot; rel=&quot;stylesheet&quot;&gt;[/collapse]下面我们就来看看 {% url %} 最简单的用法，就是带上页面的 name 参数：&lt;form method=&quot;post&quot; action=&quot;{% url 'register_to_db' %}&quot;&gt;&lt;/form&gt;我们看看另一个例子，知道注册页底部有一个按钮是链接到登录页的：&lt;input type=&quot;submit&quot; class=&quot;button&quot; style=&quot;height:25px;width:80px;font-size:12px&quot; value=&quot;直接登录&quot; onclick=&quot;location.href='#'&quot;&gt;我们来实现一下它的跳转功能吧，使用 {% url %} 标签：[collapse status="false" title="点击这里查看具体实现"]&lt;input type=&quot;submit&quot; class=&quot;button&quot; style=&quot;height:25px;width:80px;font-size:12px&quot; value=&quot;直接登录&quot; onclick=&quot;location.href='{% url 'login' %}'&quot;&gt;[/collapse]由于我们创建一个 POST 表单（它具有修改数据的作用），所以我们需要小心跨站点请求伪造。Django 自带了一个非常有用的防御系统。所有针对内部 URL 的 POST 表单都应该使用 {% csrf_token %} 模板标签，这里就没有什么用法了，在 form 标签内添加一行 {% csrf_token %} 即可。我们来看看现在的 myapp/templates/register.html 是什么样子的：[collapse status="false" title="点击这里查看具体实现"]&lt;!DOCTYPE html&gt;
&lt;html&gt;

&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;register&lt;/title&gt;
    {% load static %}
    &lt;link href=&quot;{% static 'myapp/css/style.css' %}&quot; rel=&quot;stylesheet&quot;&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div class=&quot;lg_content&quot;&gt;
        &lt;table cellspacing=&quot;30px&quot; align=&quot;center&quot;&gt;
            &lt;form method=&quot;post&quot; action=&quot;{% url 'register_to_db' %}&quot;&gt;
                {% csrf_token %}
                &lt;tr&gt;
                    &lt;td colspan=&quot;2&quot;&gt;
                        &lt;input type=&quot;text&quot; name=&quot;userid&quot; class=&quot;reg_ip&quot; placeholder=&quot;学号&quot;&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;2&quot;&gt;
                        &lt;input type=&quot;text&quot; name=&quot;username&quot; class=&quot;reg_ip&quot; placeholder=&quot;昵称&quot;&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;2&quot;&gt;
                        &lt;input type=&quot;password&quot; name=&quot;passwd&quot; class=&quot;reg_ip&quot; placeholder=&quot;密码&quot;&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;2&quot;&gt;
                        &lt;input type=&quot;password&quot; name=&quot;repasswd&quot; class=&quot;reg_ip&quot; placeholder=&quot;确认密码&quot;&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;

                &lt;tr&gt;
                    &lt;td align=&quot;left&quot;&gt;

                        &lt;input type=&quot;submit&quot; value=&quot;注册&quot; style=&quot;position:relative;left:40px;&quot; class=&quot;button&quot;&gt;

                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/form&gt;
            &lt;td align=&quot;center&quot; style=&quot;position:relative;left:-50px&quot;&gt;
                &lt;span class=&quot;font1&quot;&gt;已经注册？&lt;/span&gt;
                &lt;input type=&quot;submit&quot; class=&quot;button&quot; style=&quot;height:25px;width:80px;font-size:12px&quot; value=&quot;直接登录&quot;
                    onclick=&quot;location.href='{% url 'login' %}'&quot;&gt;
            &lt;/td&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
[/collapse]弹窗的实现施工中。Admin 管理工具让我们来看看刚才写的这么多东西到底起作用了没有。简单来说，就是模拟一下注册流程，看看是不是真的有东西写进数据表里面。我们就需要一个可视化的数据库管理工具。MySQL 下有死掉了的 PHPMyAdmin 和它的继任者 Adminer，那么 SQLite 呢？没错我们终于解锁了讲解「URL 的映射」提到过的神秘的管理工具 http://127.0.0.1:8000/admin/。然而直接访问这个页面需要账户密码。我们就创建一个超级用户：$ python manage.py createsuperuser输入你希望设定的账户、邮箱和密码。然后用这个帐号登录这个管理工具。似乎并没有显示我们的模型 STUDB。我们把将这个模型添加进管理工具里面，编辑 myapp/admin.py：from myapp.models import STUDB
admin.site.register(STUDB),现在管理页面应该能看到我们的模型，让我们愉快地开始注册吧（大雾）！以下部分正在施工。施工区域</description>
</item>
<item rdf:about="https://static.bobby285271.top/index.php/2020/04/15/NixOS-Installation-and-Configuration-Guide.html">
<title>NixOS Installation and Configuration Guide</title>
<link>https://static.bobby285271.top/index.php/2020/04/15/NixOS-Installation-and-Configuration-Guide.html</link>
<dc:date>2020-04-14T16:00:00+00:00</dc:date>
<description>本文基于 NixOS 20.03 Beta 和 NixOS Manual 20.03 撰写。本文的写作缘由是 NixOS Manual 的编排设计很容易导致习惯了其它发行版安装和配置流程的新人入坑失败。本篇指南给出的解决方案基本能满足大一软工专业课程学习和日常使用的需要。本文将假定你已经独立安装和配置过 Arch Linux、Gentoo 或任一官方不提供 GUI 安装程序的 Linux 发行版并掌握安装过程中涉及的大部分命令。了解 NixOS可以先从 DistroWatch 开始了解 NixOS 这个发行版，接下来建议阅读 NixOS 官方的介绍。有一个不太恰当的比喻，NixOS 相对于其它发行版有点像使用 Git + Markdown + Hexo 相对于无版本管理 + 手撸 HTML 文件，NixOS Wiki 也给出了 NixOS 和其它发行版的最大区别所在。而这一切实现的基础是 Nix，事实上 NixOS 中所有软件包（Nixpkgs）和系统配置都由 Nix 管理。要想了解 Nix，建议阅读 dram 大佬在知乎相关问题下的回答。dram 是 TUNA 镜像站镜像 NixOS / Nix / Nixpkgs 的主要推动者之一。至于 NixOS 是否适合你，可以阅读这篇文章自行判断。准备工作准备好安装 NixOS 了？让我们开始吧。前期的准备工作包括：数据备份、下载镜像、将镜像写入 U 盘、引导安装介质、连接到网络、建立分区、格式化分区、挂载分区，这一部分和其它（不带 GUI 安装程序的）Linux 发行版的安装几乎是一样的，这里不会细讲。2020 年 3 月后清华镜像站就有 Nix / NixOS / Nixpkgs 的镜像了，NixOS 的安装介质可在这里下载，建议选带桌面环境的镜像（可以通过文件名判断）。将写入 U 盘可以使用 dd 命令，具体用法（path-to-image 是 NixOS 安装介质的路径，/dev/sdX 则是写入目标）：sudo dd if=path-to-image of=/dev/sdX
引导安装介质后，按照 /etc/issue 的提示操作即可进入桌面环境（启动登录管理器），注意默认搭载的账户 nixos 和 root 都没有密码：sudo systemctl start display-manager
因为在线安装，联网是必须的。通常情况使用 NetworkManager 联网即可，当然这里还有其它的联网方式。可选的分区工具除了熟悉的 GDisk 和 GNU Parted 这些 CLI 的分区工具之外，还有 GUI 的分区工具 GParted。NixOS Manual 对在命令行下分区做了详细的介绍，还配有不少的例子，可以配合 ArchWiki 的相关文章进行阅读。因为 Nix 并不会自动删除历史的软件包安装，根目录尽可能分大一些，否则随着时间推移 /nix 可能会占用较大空间。除了 Home 和 EFI 分区之外不建议（也没必要）设置独立分区。另外 NixOS 的回滚功能是由 Nix 实现的，和 Btrfs 无关，如果你选择 Btrfs 仅仅是因为它的快照特性，那么没有必要给根分区使用 Btrfs。格式化分区之后就可以挂载分区了。分区应该挂载到 /mnt 下，例如根分区就挂载到 /mnt，Home 分区则 /mnt/home。特别留意 NixOS 下 EFI 分区应该挂载到 /mnt/boot。Swap 分区使用 swapon 启用即可。初始化 NixOS 配置文件接下来就是后期的准备工作了。事实上，如果你点开了前面的几个链接，你会发现 /etc/nixos/configuration.nix 是整个系统的灵魂所在。你的系统全局搭载的软件包和系统配置都取决于这个文件。因此我们说这个发行版是「先配置后安装」的。所以接下来的主要任务，就是配置 configuration.nix，这个文件会一直伴随着你的系统。一旦配置完成，你会使用到 nixos-install 脚本，这个脚本会读取这个文件，并调用 Nix 让其根据这个文件「造出对应的系统来」。而在安装好 NixOS 之后，你可以随时改动 configuration.nix 这个文件，然后使用 nixos-rebuild 脚本，这个脚本同样也是调用 Nix，让 Nix 处理所有的变化，以「造出对应的系统来」。「造出来的系统」会和当前系统的状态无关 。这两个脚本笔者在后面会介绍其用法。当然了，如果在 Live 环境里面直接编辑 /etc/nixos/configuration.nix，打开的是 Live 环境的配置文件。而现在我们需要为新的系统创建一个默认的 NixOS 的配置文件，在进入新系统之前，应该通过 /mnt 访问其文件（本文后续的命令，除非特别注明，否则一律需要在 root 账户下执行，可以使用 su 命令从普通用户切换到 root 账户）：nixos-generate-config --root /mnt
运行这个命令之后，/mnt/etc/nixos/ 目录会被创建，里面会放置自动生成的两个文件：configuration.nix 和 hardware-configuration.nix 。我们待会再看 hardware-configuration.nix，先看看前面已经提到无数次的 configuration.nix，这个文件在 NixOS 20.03 下默认长这样。当然了，在你安装系统之后，可以使用 nixos-generate-config --force 重新生成一个 configuration.nix。初识 NixOS 模块让我们来打开 configuration.nix 这个文件：nano /mnt/etc/nixos/configuration.nix
以 # 开头的都是注释，我们先不要管注释，看看没有注释的内容。实际上，这是一个简化的 NixOS 模块（NixOS Module）。我们尝试分析一下它的结构：{ config, pkgs, ... }:

{
    imports = [
        ./hardware-configuration.nix
    ];
    boot.loader.systemd-boot.enable = true;
    boot.loader.efi.canTouchEfiVariables = true;
    networking.useDHCP = false;
    networking.interfaces.docker0.useDHCP = true;
    networking.interfaces.wlo1.useDHCP = true;
    system.stateVersion = &quot;20.03&quot;;
}
第一行的 { config, pkgs, ... }: 表示这是一个至少接受两个参数 config 和 pkgs 的函数。config 主要用于在多个 NixOS 模块的情形下引用其它模块定义的配置值，这里有相关的例子，可以说是引入了完整的系统配置。pkgs 主要用于引用 Nixpkgs 中的软件包，例如 pkgs.fcitx。当然我们现在简单地认为第一行就是要这样写的好了，即使在本文中不会使用到 config。说实话在第一次接触 C++ 时对着 using namespace std; 自闭了半天，其实到后面需要到名称空间的时候自然就懂了。imports 导入了其它的 NixOS 模块，这里它导入了 ./hardware-configuration.nix。另外 modules/module-list.nix 里面定义了一系列的模块，这些模块会被自动导入。modules/module-list.nix 的绝对路径是啥呢，可以看回 NixOS 官方的介绍，阅读 How does NixOS work?，你会发现 /nix/store/ 下的目录都带上了 Hash 值，这是为了避免新的安装覆盖旧的安装（便于需要的时候回滚啊！事实上这也是开始时我说根目录尽可能分大一些的原因，后面会提供旧安装清理的方法）。所以要想找到这个 modules/module-list.nix，不妨用点小技巧：find / | grep &quot;modules/module-list.nix&quot;
cat 查看相应的文件就可以看到这个列表了，事实上还真导入了不少的 NixOS 模块。当然我们现在先打开 hardware-configuration.nix 看看（要注意上面的 ./hardware-configuration.nix 是相对于 /mnt/etc/nixos/configuration.nix 的路径）：cat /mnt/etc/nixos/hardware-configuration.nix
你会发现上面记录了你的分区信息，如果不是那就是你分区过程中出了差错，可以调整分区后按照上面的步骤重新 nixos-generate-config。这个文件将用于生成 Fstab 等文件。这个文件被单独分出来原因也是为了避免错误地编辑了这个文件。事实上 NixOS 官方只建议使用 nixos-generate-config 更新这个文件。接下来我们来看 configuration.nix 剩余的部分。这些行的格式都是 name = value，我们称这是定义（define）操作。我们称 configuration.nix 为简化的 NixOS 模块，原因是它只有定义操作。事实上还有声明（declare）操作，这一个一个的 name 其实在其它文件声明过，这样才可以被定义。笔者接下来会详细介绍定义操作和声明操作，如果想要深入了解 NixOS 模块，可以查看这里。定义操作我们来继续来研究上面 configuration.nix 涉及到的 Nix 表达式：boot.loader.systemd-boot.enable = true;
boot.loader.efi.canTouchEfiVariables = true;
我们已经知道它们格式都是 name = value，进一步分析它的结构，这两个表达式中我们把 boot、loader、systemd-boot 还有 efi 称之为集合（_set_），把 enable 和 canTouchEfiVariables 称为选项（_option_），把 true 称为值（value）。一个集合里面可能有子集合，也有可能有选项，我们给选项定义值。集合与子集合、集合与选项之间可以像上面一样，使用 . 连接。同时也可以使用下面的使用花括号嵌套的方式（注意分号出现的位置）：boot = {
    loader = {
        systemd-boot = {
            enable = true;
        };
        efi = {
            canTouchEfiVariables = true;
        };
    };
};
当然了可以两种方式混合使用：boot = {
    loader.systemd-boot = {
        enable = true;
    };
    loader = {
        efi.canTouchEfiVariables = true;
    };
};
如果是还有疑问的，NixOS Manual 给出了更多的相关例子。至于是使用花括号还是半角句号，我认为不重要。但在我看来，如果有两个选项它们属于同一个集合，它们应该尽量在一起被定义，而不是一个在文件开头定义，一个在文件末尾定义。同一集合的两个选项会有一定的关联性，放在一起可以更好地维护。当然了，当配置文件足够复杂之后，还可以像 hardware-configuration.nix 一样将一部分拆分出来，在 imports 部分导入相关文件，这里就不细讲了。至于 value，上面的给出的 configuration.nix 中涉及到的值有 true、false、&quot;20.03&quot;。和其它编程语言的数据类型类似，我们称 true 和 false 是布尔值，称 ”20.03&quot; 是字符串（注意两个引号），每一个 name 都有对应的可接受的类型。是事实上，对于其它的选项，可以接受的值的类型也有可能是列表、浮点数、软件包等等。这里详细地介绍了 value 的各种类型，并给出了相关的例子。这里问题就来了，怎样知道在一个 NixOS 系统中我有哪些 name 可以用呢？这些 name 又接受那些 value 呢？让我们继续来了解「声明操作」。声明操作和其它编程语言类似，声明就是要告诉人家我叫啥、我接受什么样的 value。怎样查看一个 name 的声明呢？第一个方法是使用命令 nixos-option，例如我要查看 system.stateVersion 的声明：nixos-option system.stateVersion
这个是在我系统上的输出，当然了在 Live 环境下输出不一定相同：Value:
&quot;20.03&quot;

Default:
&quot;20.03&quot;

Type:
&quot;string&quot;

Description:
''
    Every once in a while, a new NixOS release may change
    configuration defaults in a way incompatible with stateful
    data...（后面的省略）
''

Declared by:
[ &quot;/nix/var/nix/profiles/per-user/root/channels/nixos/nixos/modules/misc/version.nix&quot; ]

Defined by:
[ &quot;/etc/nixos/configuration.nix&quot; ]

我们会看到 system.stateVersion 在 /nix/var/nix/profiles/per-user/root/channels/nixos/nixos/modules/misc/version.nix 声明过，而笔者刚开始的时候说过 configuration.nix 会自动导入 modules/module-list.nix 里包含的所有文件，里面就有 version.nix，因此我们才可以在 /etc/nixos/configuration.nix 定义它。另外我们也能得到其它有用的信息，例如它接受一个字符串作为它的值，system.stateVersion 默认定义的值是 &quot;20.03&quot;，事实上这些信息就是在声明它的时候提供的。我们打开这个 version.nix，这就是一个声明的真面目了：options.system = {
    stateVersion = mkOption {
        type = types.str;
        default = cfg.release;
        description = ''
            Every once in a while, a new NixOS release may change
            configuration defaults in a way incompatible with stateful
            data...（后面的省略）
        '';
    };
};
当然笔者在本文中并不会要求用户创建一个声明。但我们还是会继续探究这个文件，我们发现 version.nix 给多个选项提供了声明，例如 system.nixos.release、system.nixos.codeName 等等。我们接着再往下翻一点：config = {
    system.nixos = {
        version = mkDefault (cfg.release + cfg.versionSuffix);
    };

    # Generate /etc/os-release.
    environment.etc.os-release.text = ''
        NAME=NixOS
        ID=nixos
        VERSION=&quot;${cfg.version} (${cfg.codeName})&quot;
        VERSION_CODENAME=${toLower cfg.codeName}
        VERSION_ID=&quot;${cfg.version}&quot;
        PRETTY_NAME=&quot;NixOS ${cfg.release} (${cfg.codeName})&quot;
        LOGO=&quot;nix-snowflake&quot;
        HOME_URL=&quot;https://nixos.org/&quot;
        DOCUMENTATION_URL=&quot;https://nixos.org/nixos/manual/index.html&quot;
        SUPPORT_URL=&quot;https://nixos.org/nixos/support.html&quot;
        BUG_REPORT_URL=&quot;https://github.com/NixOS/nixpkgs/issues&quot;
    '';
};
你会在里面找到 ${cfg.version} 和 ${cfg.codeName}。cfg 是什么呢，我们回到文件开头：{ config, lib, pkgs, ... }:

with lib;

let
    cfg = config.system.nixos;
in
{
    ...
}
还记得 config 是啥吗？我们说它引入了完整的系统配置。现在，即使我没有告诉你 environment.etc.os-release.text 是个啥，相信你也能猜出来，Nix 使用了 system.nixos.release、system.nixos.codeName 创建了 /etc/os-release 这个文件。至于前面提到的 system.stateVersion 呢，则被用于其它的地方了（毕竟有了 config，我们在任何地方都可以引用它）。事实上，就是这样声明和定义一个又一个的选项，组成了最终的系统。关于怎样查看一个 name 的声明，第二个方法是使用 NixOS Options 网页。输入 name 同样可以查看到使用 nixos-options 能看到的内容。关键是它还非常适合给我们模糊搜素用。另外点击 Declared in 旁边的超链接，会跳转到 GitHub 的 NixOS/nixpkgs 仓库。例如说我们查找 system.stateVersion，我们会被带到这里。同样也可以查看 version.nix 文件，还可以切换 Git 分支查看不同 NixOS 版本下这个文件的历史状态。我们在后面会经常使用到 NixOS Options 网页和 nixos-option 命令。开始编辑 configuration.nix讲了这么多，让我们尝试把刚刚学到的东西应用到实际当中吧！接下来我们要写很多很多的 name = value 表达式。我们已经知道，当我们有一个需求，我们可以尝试去 NixOS Options 进行模糊搜索，看看有没有对应的选项。此外，我们多次提到的 NixOS Manual 提供了很多的常见需求对应的解决方案。这里还会另外推荐一些寻找解决方案的地方：NixOS Manual - NixOS 官方文档值得阅读值得信赖。NixOS Options - 列出了所有可用的选项、其声明、可以接受的值。NixOS Discourse Forum - 用户论坛，有官方开发者答疑。NixOS Packages - 列出了所有可用的 Nixpkgs 软件包。NixOS Wiki - 社区维护的维基。GitHub - 查看其它用户的配置，或查看官方的 NixOS/nixpkgs 仓库。Stack Overflow - 查看打有 nixos 标签的问题和回答。各大搜索引擎 - 这个也不用我多说吧……当然了，如果实在找不到，可以去 NixOS Discourse Forum 提问，因为官方开发者在这个论坛非常活跃，很多问题都能在短时间内得到答案。要注意的是，因为 configuration.nix 会一直伴随着你的 NixOS 安装，所以这个章节既适用于安装时进行初始化配置，也适用于安装后的日常维护进行配置。下面结合两个自认为比较实际的需求来展开介绍，我会着重说明我是如何找到解决方案的，希望能给到大家一些帮助。桌面环境会发现 NixOS Manual 有多个对应的章节，有讲 X11 的，有专门讲 Pantheon 桌面环境的，有专门讲 XFCE 桌面环境的。个人非常喜欢 Pantheon，我们也知道 X11 是一切桌面环境的基础（假设我们把 Wayland 忽略掉）。我们来看看 X11。首先看到的是这样一句：The X Window System (X11) provides the basis of NixOS’ graphical user interface. It can be enabled as follows:services.xserver.enable = true;
看上去是不是很熟悉？事实上默认的 configuration.nix 里面已经有了这样的一行，只是被注释掉了。上面还配有注释 Enable the X11 windowing system. 让我们取消注释 services.xserver.enable = true;。搞定！就这么简单。先继续看看 Pantheon 桌面对应的章节。根据 NixOS Manual，要想使用 Pantheon 桌面，需要在 configuration.nix 加入：services.xserver.desktopManager.pantheon.enable = true;
这也很简单，复制粘贴过去就完成了，搞定！在 configuration.nix 加入这个 Nix 是怎样处理的呢？还记得前面提到的 system.nixos.release、system.nixos.codeName和 /etc/os-release 吗？可以按照当时我所给的思路一探究竟，我们在后面揭晓。软件包会发现 NixOS Manual 有对应的章节。它的要求是定义 environment.systemPackages 这个选项。它给出的例子是这样的：environment.systemPackages = [ pkgs.thunderbird ];
感觉有点迷？那不妨前往 NixOS Options 查找 environment.systemPackages，这时就应该知道它要求你提供 list of packages。我们回到 NixOS Manual，查看 Package 小节。这时就可以大致推断出这个 name 怎么填了。接下来我们去 GitHub 参考一下别人的配置文件，注意语言要选择 Nix，关键字将 Option 填入即可。查看搜索结果的时候只看定义操作相关的代码（而不是声明操作），这时你会发现另一个用法：environment.systemPackages = with pkgs; [
    vscode
    freemind
];
事实上这样写，在后面就不用每个软件包前面加上 pkgs. 了，pkgs.vscode 可以直接写成 vscode。胜利在望！接下来去 NixOS Packages，查找自己需要的软件包填入。你会发现有 Package name 和 Attribute name，填哪个呢？不妨回到 GitHub 继续翻配置文件，当你发现所有配置填的都是 Attribute name，我们就可以开始了，下面的就是我的配置：environment.systemPackages = with pkgs; 
[
    dos2unix chromium fcitx fcitx-configtool firefox gcc git gptfdisk libreoffice-fresh neofetch pciutils python transmission vim wget vscode-with-extensions
];
你会发现这里面没有 X11 和 Pantheon 相关的包，事实上， services.xserver.desktopManager.pantheon.enable = true; 这一行已经为你安装了相应的包。可以查看一下包含这个选项声明的文件，我们定位到 config = 往下的内容。虽然有些选项我们没有讨论过，例如 fonts.fontconfig.defaultFonts 等等，但是你可以通过搜索 NixOS Options 或者直接按照它的字面意思知道这些选项是干什么的。有安装软件包的、设置系统服务的、设置字体的等等。有了这么一行，我们也就没有必要在我们自己的 configuration.nix 中设置它了。所以说 NixOS Options 的优先级是会高于 NixOS Packages 的，笔者才会用很大的篇幅介绍前者。当你需要一个软件或功能，首先考虑的应该是有没有对应的 NixOS Option，而不是直接安装一个 Nixpkg。*下面是另外两个比较玄学的案例，都是我安装完成之后才开始折腾的问题，当然了安装的时候也没有必要纠结这些问题，因为安装完后还可以随时编辑 configuration.nix，后面还会再介绍。同样，我会着重说明我是如何找到解决方案的，希望能给到大家一些帮助。介绍这些案例，不是为了劝退，而是为了说明，只要合理利用我在本章介绍的各类资源，善用搜索，必要时勇敢提问、开 Issue，甚至发 PR（这里有笔者本人的例子），大部分的问题都能很快地得到解决。禁用 N 卡单纯出于想要省电的原因，打算禁用 N 卡。网上给出的禁用 N 卡的方案是都是使用 BBSwitch，四处搜索之。最后在 Discourse Forum 里面找到了一个有一定关联的。提到的选项包括 extraModprobeConfig、blacklistedKernelModules、extraModulePackages。我们知道在其它发行版下要使用 BBSwitch 禁用 N 卡是这样操作的：options bbswitch load_state=0 unload_state=1
和帖子中 extraModprobeConfig 的值高度类似。而 extraModulePackages 在帖子里的值是 config.boot.kernelPackages.nvidia_x11，我们搜索到 BBSwitch 的 Attribute name 是 linuxPackages.bbswitch，相信也有一定关联。接下来我们去 NixOS Options 继续搜索，发现上面几个选项都在 boot 集合下，查找 boot module 关键词，又发现了一个 boot.kernelModules，我认为这个选项和我的需求也是高度关联的。于是我写下了以下的配置：boot = {
    extraModprobeConfig = ''
        options bbswitch load_state=0 unload_state=1
    '';
    extraModulePackages = [ pkgs.linuxPackages.bbswitch ];
    kernelModules = [ &quot;bbswitch&quot; ];
    blacklistedKernelModules = [
        &quot;nouveau&quot;
        &quot;rivafb&quot;
        &quot;nvidiafb&quot;
        &quot;rivatv&quot;
        &quot;nv&quot;
        &quot;uvcvideo&quot;
    ];
};
确实是可行的，因为我后面运行 lspci 的时候显示已经是 rev ff 了：01:00.0 3D controller: NVIDIA Corporation GP107M [GeForce GTX 1050 3 GB Max-Q] (rev ff)
Visual Studio Code 插件你可能会问这也要提及？情况是这样的，安装了 VS Code（pkgs.vscode-with-extensions）之后我安装了几个插件，发现 C++ 插件不工作。我对这个插件提供的补全功能有较大的依赖，第一时间我想到的是这是 NixOS 目录结构和其它发行版不一致的问题。于是去搜索 Discourse Forum，找到了这个帖子。下面有官方开发者给出了一个 Dirty Hack，尝试之。结果发现 fetchTarball https://github.com/nixos/nixpkgs-channels/archive/nixpkgs-unstable.tar.gz 会消耗不少时间。一个解决方案是将整个 GitHub 仓库同步到其它 Git 托管平台，但我们还是希望有更高效的解决方案。留意到了楼主的解决方案，虽然它会覆盖原有的自己在 Marketplace 安装的 VS Code 插件，但是按照楼主的描述它确实是可行的：self: super:
{
    mycode = super.vscode-with-extensions.override {
        # When the extension is already available in the default extensions set.
        vscodeExtensions = with super.vscode-extensions; [
            ms-vscode.cpptools
        ];
    };
}
但是你并不知道第一行是啥，也不知道如何添加这个方案，于是去 GitHub 搜索相关的内容。结果搜出来的结果比上面这个还要再复杂一点，而且这样写的不只一个：self: super: {
    vscode-with-extensions = super.vscode-with-extensions.override {
        vscodeExtensions = with super.vscode-extensions;
        [ 
            bbenoist.Nix
            ms-vscode.cpptools
        ]
        ++ super.vscode-utils.extensionsFromVscodeMarketplace [ {
                name = &quot;vim&quot;;
                publisher = &quot;vscodevim&quot;;
                version = &quot;1.0.8&quot;;
                sha256 = &quot;0yqfn8b2jfrijzf731sggyvik2immlx9hfgmsgp1mx01hpyisd9r&quot;;
            } {
                name = &quot;doxdocgen&quot;;
                publisher = &quot;cschlosser&quot;;
                version = &quot;0.4.1&quot;;
                sha256 = &quot;06f4nxjd5ph66bhlyjim87haams286sjhrw7vmiv2rckzinygh1h&quot;;
            } {
                ...
            }
        ];
    };
}
这时可以猜出来官方应该有相应的文档，于是就去搜索 NixOS Manual、NixOS Options 还有 NixOS Packages，发现都找不到。终于，笔者开始查找 GitHub 的 NixOS/nixpkgs 仓库。找到了这样一个文件。你会发现第一行没了，后面的内容还是类似的。现在我们可以把关注点放在这个 override 上了。我们重新发起一次搜索，在 NixOS Manual 找到了有关 override 的说明。太妙了！但是接下来又有一个问题，这里的 name、publisher、version 和 sha256 又该怎么填呢？为什么 ms-vscode.cpptools 不需要填 version 和 sha256 呢？阅读还是刚才的文件，阅读上面的注释：This expression should fetch:the nix vscode extension from whatever source defined in the default nixpkgs extensions set vscodeExtensions.the code-runner vscode extension from the marketplace using the following url: (link).The original code executable will be wrapped so that it uses the set of pre-installed / unpacked extensions as its --extensions-dir.然而我们却找不到 vscodeExtensions，但是我们可以搜索 ms-vscode.cpptools 啊！终于笔者找到了这个文件。事实上在这个文件中涉及到的所有插件都无需我们再配置 publisher、version 和 sha256 了。这和我们使用了 services.xserver.desktopManager.pantheon.enable = true; 就不需要在 environment.systemPackages 添加相关的包是一个道理。至于这个文件里没有的插件呢？例如说 ms-vscode.cpptools 的 name 就是 cpptools，publisher 就是 ms-vscode。我们可以去 Marketplace 下载这个插件（找到 Download Extension 按钮即可），用 sha256sum 命令计算下载下来的文件的 sha256，而版本号在文件名有。好了，你已经准备好了！让我们来继续完善 environment.systemPackages：environment.systemPackages = with pkgs; 
[
    dos2unix chromium fcitx fcitx-configtool firefox gcc git gptfdisk libreoffice-fresh neofetch pciutils python transmission vim wget
    ( vscode-with-extensions.override {
        vscodeExtensions = with vscode-extensions; [
            bbenoist.Nix
            ms-vscode.cpptools
            ms-azuretools.vscode-docker
        ]
        ++ vscode-utils.extensionsFromVscodeMarketplace [ {
                name = &quot;bracket-pair-colorizer-2&quot;;
                publisher = &quot;CoenraadS&quot;;
                version = &quot;0.0.29&quot;;
                sha256 = &quot;cadb50a21944e6e0293e3872d2fe23b5d2fd2b603ed2bf4a0675fd29bcfb130c&quot;;
            } {
                name = &quot;python&quot;;
                publisher = &quot;ms-python&quot;;
                version = &quot;2020.3.71113&quot;;
                sha256 = &quot;1d8a98a1eed7588dd3b57e4bbe518fcc88f883e066f1b3342453e9bc1a283fdb&quot;;
            } {
                name = &quot;php-intellisense&quot;;
                publisher = &quot;felixfbecker&quot;;
                version = &quot;2.3.14&quot;;
                sha256 = &quot;3798a5de1172b5803877357d0057e3e129d8d82b8fbe0b53ae28c777a0075ca6&quot;;
            } {
                name = &quot;vscode-language-pack-zh-hans&quot;;
                publisher = &quot;MS-CEINTL&quot;;
                version = &quot;1.44.2&quot;;
                sha256 = &quot;4f6ee18ada0e71dd1545ef49f8810f52fe872d2074612faa908d8bf2687400a0&quot;;
            }
        ];
    } )
];
*相信对于其它的需求大家也能举一反三。这里是我的 configuration.nix，供大家参考。执行安装前面已经提及过 nixos-install 这个命令了，让我们使用它执行安装，不需要带上任何参数：nixos-install
如果 configuration.nix 存在任何错误，安装会在一开始的时候就中断，修改好后重新运行上面的命令即可。网络出现问题同理。接下来安装程序会提示你设置一个密码，这个密码是给管理员用的（密码当然是不能在 configuration.nix 上设置的），盲打两次即可。重启并进入新系统：reboot
当然，重启后别忘了为你的普通用户设置密码（如 passwd bobby285271）。系统维护笔者之前讲过 configuration.nix 是可以随时修改的。当然了现在你应该处于你的新系统中了，所以你不应该编辑 /mnt/etc/nixos/configuration.nix 了，而是应该编辑 /etc/nixos/configuration.nix。nano /etc/nixos/configuration.nix
要使这个配置生效，应该使用 nixos-rebuild switch 命令，如果你希望在构建这个配置的时候顺便升级自己的系统（当然如果你不改动 configuration.nix 单纯想升级系统，同样可以执行这个命令） ：nixos-rebuild switch --upgrade
关于这个，可以查看 NixOS Manual 了解详情。</description>
</item>
<item rdf:about="https://static.bobby285271.top/index.php/2020/02/18/How-to-Port-Calamares-to-Arch-Linux-en.html">
<title>How to Port Calamares to Arch Linux (en)</title>
<link>https://static.bobby285271.top/index.php/2020/02/18/How-to-Port-Calamares-to-Arch-Linux-en.html</link>
<dc:date>2020-02-17T16:00:00+00:00</dc:date>
<description>本文将在近期重写。This article is for reference ONLY.Calamares is a distribution-independent installer framework. As distributions like Arch Linux don't provide graphical installer, we can try to adapt Calamares to them. To make things easier, we simply start by trying to provide a pacstrap part for Calamares, which allow users to install a minimal Arch Linux system, then we add the Calamares installer to our Archiso.Getting StartedMake sure that you have Git installed, fetch the source code by cloning the Calamares repository, to speed up, add --depth=1 option:git clone https://github.com/calamares/calamares.git --depth=1
Entering the repository, you will find lots of files and directories, don't panic! All you have to focus on are three files/directories: settings.conf, src/branding/ and src/modules/. Let's try to deal with them one by one.Step One: settings.confFirstly, you will find something like this:sequence:
- show:
  - welcome
  - locale
  - ...
- exec:
  - partition
  - mount
  - ...
- show:
  - finished
This is the installation process of Calamares, consisting of the show part and the exec part. Unlike Arch Linux's official install way where users DIY their system from the beginning to the end, users should setup their system in the show part and the exec part should handle the rest of the work then show again to inform user whether the installation work is succeed or not, which is considered more user-friendly. Each part (show and exec) includes several modules like welcome, locale and so on. We will talk about them later.Now go to ArchWiki and have a look at the Installation Guide, you will find that some of the modules can be safely removed because when you perform a installation by following the ArchWiki, you never do such things like plymouthcfg (In fact, plymouth is not supported by Arch Linux at all). However, you will need to add some part because Calamares doesn't provide such option, such as a pacstrap part. Simply add the line - pacstrap and do rest of the thing later in step three.sequence:
- show:
  - welcome
  - locale
  - keyboard
  - partition
  - users
  - summary
- exec:
  - partition
  - mount
  - pacstrap
  - networkcfg
  - packages
  - machineid
  - fstab
  - locale
  - keyboard
  - localecfg
  - users
  - networkcfg
  - hwclock
  - bootloader
  - umount
- show:
  - finished
Let's move on. You will then see some of the boolean variables with notes above each of them. Simply set true or false according to the notes. Leave branding as default, you will configure it in step two.Step Two: src/branding/In fact, this step is optional if you don't care about branding at all. The problem is that your users will be faced with something strange like the distro name Fancy GNU/Linux 2020.2 LTS &quot;Turgid Tuba&quot; and the slide show texted This is a customizable QML slideshow. So it is not recommend to skip this step if you want to distribute the Calamares and Archiso to others.Navigate to the src/branding/ directory, read the README.md carefully, and enter the default/ directory. There are two files that you have to pay attention. One of them is branding.desc. These entries should be modified to the actual one:strings:
    productName:         &quot;@{NAME}&quot;
    shortProductName:    Arch Linux
    version:             Rolling
    shortVersion:        Rolling
    versionedName:       Arch Linux
    shortVersionedName:  Arch Linux
    bootloaderEntryName: Arch Linux
    productUrl:          https://www.archlinux.org/
    supportUrl:          https://bbs.archlinux.org/
    knownIssuesUrl:      https://bugs.archlinux.org/
    releaseNotesUrl:     https://www.archlinux.org/
Another one is show.qml. It is used to control slide shows. Here we only add one page, with the image squid.png (already included in the directory) and text Arch Linux is a lightweight and flexible Linux distribution that tries to Keep It Simple.    Slide {

        Image {
            id: background
            source: &quot;squid.png&quot;
            width: 200; height: 200
            fillMode: Image.PreserveAspectFit
            anchors.centerIn: parent
        }
        Text {
            anchors.horizontalCenter: background.horizontalCenter
            anchors.top: background.bottom
            text: &quot;Arch Linux is a lightweight and flexible Linux distribution that tries to Keep It Simple.&quot;
            wrapMode: Text.WordWrap
            width: presentation.width
            horizontalAlignment: Text.Center
        }
    }
Step Three: src/modules/This is the most difficult part. You should do configurations for all modules listed in settings.conf. In most of the time, you don't have to do programming work, but simply edit the *.conf file. For example, if you want to edit the users module, open src/modules/users.conf and edit it. Here is a sample file:---
defaultGroups:
    - users
    - wheel

autologinGroup:  autologin
doAutologin:     true
setRootPassword: true
doReusePassword: true

passwordRequirements:
    nonempty: true
    minLength: -1
    maxLength: -1
    libpwquality:
        - minlen=0
        - minclass=0

allowWeakPasswords: false
allowWeakPasswordsDefault: false
For modules you created by yourself, like pactrap, you have to create a folder for it with the same name. Make sure you have already known a little bit about Python and Shell script, now start coding!All we have to do is to call the real pactrap command. But it seems that if we really do that, the installation process may failed because of the behavior of Calamares. So we also have to port pacstrap for Calamares later. For now, we just name the script pacstrap_calamares and forget it. Let's create a file main.py.#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import subprocess
import libcalamares
from pathlib import Path

root_mount_point = libcalamares.globalstorage.value(&quot;rootMountPoint&quot;)
    
def run():
    &quot;&quot;&quot;
    Installing base filesystem. Please wait! It may take some time!
    &quot;&quot;&quot;

    PACSTRAP = &quot;/usr/bin/pacstrap_calamares&quot;
    PACKAGES = &quot;base grub efibootmgr linux linux-firmware vi nano networkmanager&quot;

    subprocess.call(PACSTRAP.split(' ') + [root_mount_point] + PACKAGES.split(' '))

In fact, subprocess can always be used to write Shell script in Python. The only thing you have do is to save command into a string foo, then split it using foo.split(' '), and put it into subprocess.call(). Here, we call /usr/bin/pacstrap_calamares and ask it to install some basic package base grub efibootmgr linux linux-firmware vi nano networkmanager. When pacstrap_calamares is running, Calamares will show Installing base filesystem. Please wait! It may take some time! on the screen.Step Four: Build CalamaresWe can build Calamares when we are building Archiso so the build process won't make your system dirty. Assume that you already have a Archiso profile. First, we add the needed packages to packages.x86_64.kf5
qt5
boost
kpmcore
yaml-cpp
polkit-qt5
Assume that you have entered the chroot environment. To build Calamares, three steps are reqired: cmake, make and make install. Write all the steps down, and put it into airootfs/root/. Here is an example file:#/bin/bash
cd /root/
mkdir ./calamares/build/
cd ./calamares/build/
cmake ..
make
make install
mkdir /etc/calamares/
cp -p /root/archlinux-calamares/settings.conf /etc/calamares/
rm -rf /root/archlinux-calamares/ /root/calamares/ /root/build_calamares.sh
pacman -Rscun qt5-doc qt5-examples --noconfirm
Now we can ask airootfs/root/customize_airootfs.sh to run this shell script after a chroot environment is entered. Make sure the script is executable.cd /root
./build_calamares.sh
Almost done! Don't forget to create a pacstrap_calamares file for Calamares. Create a airootfs/usr/bin/pacstrap_calamares file. You don't have to worry about how to fill the file. Someone has already done that for you! And here is the file. Thanks for the work done by Endeavour OS team.</description>
</item>
<item rdf:about="https://static.bobby285271.top/index.php/2020/02/09/2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html">
<title>2020 Nowcoder Basic Algorithm Training Camp Solutions</title>
<link>https://static.bobby285271.top/index.php/2020/02/09/2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html</link>
<dc:date>2020-02-08T16:00:00+00:00</dc:date>
<description>颓废了一个寒假，Codeforces 打来打去都是 Specialist，菜的一批。POJ 又刷到怀疑人生。后来被 Kaidora 神犇安排了这个集训营。当时已经是第四场要开始了，还是去了。果然，哪怕都是自闭五小时每小时过一题，氪了金感觉就是不一样。点击下方的页码查看相应场次的记录，第 $i$ 页对应的是第 $i-1$ 场比赛。2020 牛客寒假算法基础集训营 1字符串、贪心、矩阵快速幂、概率论、计算几何、并查集、数论1A. Honoka 和格点三角形大意给出 $m \times n$ 格点矩阵，问在矩阵里面能找出多少个面积为 $1$，且至少有一条边平行于 $x$ 轴或 $y$ 轴的三角形。答案对 $1000000007$ 取模。思路若存在平行于 $x$ 轴或 $y$ 轴的边且长度为 $2$，一共有 $2(n-1)(m-2)m+2(m-1)(n-2)n$ 种情况。若存在平行于 $x$ 轴或 $y$ 轴的边且长度为 $1$，除去已经计算过的情况（即还存在平行于$x$ 轴或 $y$ 轴且长度为 $2$ 的边），一共有 $2(m-1)(m-2)(n-2)+2(n-1)(n-2)(m-2)$ 种情况。相加后化简，得到 $2(m+n-2)(2mn-3m-3n+4)$，利用 $ab\ mod\ c = ((a\ mod\ c)(b\ mod\ c))\ mod\ c$ 计算结果。#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    long long n, m, tempa, tempb;
    cin &gt;&gt; n &gt;&gt; m;
    tempa = 2 * (m + n - 2);
    tempb = (2 * m * n - 3 * m - 3 * n + 4);
    cout &lt;&lt; (tempa % 1000000007) * (tempb % 1000000007) % 1000000007 &lt;&lt; endl;
    return 0;
}
1B. Kotori 和 Bangdream大意及思路签到题。求数学期望，也就是可能结果的概率乘以其结果的总和。#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    double n, x, a, b;
    cin &gt;&gt; n &gt;&gt; x &gt;&gt; a &gt;&gt; b;
    double ans = (a * x + b * (100 - x)) * n / 100;
    printf(&quot;%.2lf\n&quot;, ans);
    return 0;
}
1C. Umi 和弓道大意一个人在 $(x_0,y_0)$，给出 $n$ 个靶子，在 $x$ 轴或 $y$ 轴放置挡板，令放置挡板后可以射中的靶子数量不多于 $k$ 个。思路只要靶子和 $(x_0,y_0)$ 不在一个象限就有可能被挡掉。要想挡掉一个靶子，只需求出靶子和 $(x_0,y_0)$ 所在直线与坐标轴的交点，并保证挡板覆盖了这个点。我们只需要恰好覆盖 $n-k$ 个这样的点就行了。#include &lt;bits/stdc++.h&gt;
using namespace std;
const double inf = 1e18;
vector&lt;double&gt; v1, v2;
int main()
{
    v1.clear();
    v2.clear();
    double x0, y0;
    int n, k, i;
    cin &gt;&gt; x0 &gt;&gt; y0 &gt;&gt; n &gt;&gt; k;
    k = n - k;
    for (i = 0; i &lt; n; i++)
    {
        double x, y;
        cin &gt;&gt; x &gt;&gt; y;
        if (x * x0 &lt; 0)
        {
            v2.push_back(y0 - x0 * (y - y0) / (x - x0));
        }
        if (y * y0 &lt; 0)
        {
            v1.push_back(x0 - y0 * (x - x0) / (y - y0));
        }
    }
    double mi = inf;
    sort(v1.begin(), v1.end());
    sort(v2.begin(), v2.end());
    if (v1.size() &gt;= k)
    {
        double head = 0, tail = k - 1;
        while (tail &lt; v1.size())
        {
            mi = mi &gt; (v1[tail] - v1[head]) ? (v1[tail] - v1[head]) : mi;
            tail++, head++;
        }
    }
    if (v2.size() &gt;= k)
    {
        double head = 0, tail = k - 1;
        while (tail &lt; v2.size())
        {
            mi = mi &gt; (v2[tail] - v2[head]) ? (v2[tail] - v2[head]) : mi;
            tail++, head++;
        }
    }
    if (mi == 1e18)
        cout &lt;&lt; -1;
    else
        printf(&quot;%.7lf&quot;, mi);
    return 0;
}
1D. Hanayo 和米饭大意给出 $n-1$ 个数，求一个数使得所有的 $n$ 个数经过排序后可形成公差为 $1$ 的等差数列。保证答案存在且唯一。思路签到题。将 $n-1$ 个数排序，看相邻两数的差是否为 $2$。#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int n;
    cin &gt;&gt; n;
    int a[n - 1];
    for (int i = 0; i &lt; n - 1; i++)
    {
        cin &gt;&gt; a[i];
    }
    sort(a, a + n - 1);
    for (int i = 0; i &lt; n - 2; i++)
    {
        if (a[i + 1] - a[i] != 1)
        {
            cout &lt;&lt; a[i] + 1 &lt;&lt; endl;
            break;
        }
    }
    return 0;
}
1E. Rin 和快速迭代大意令 $f(x)$ 为 $x$ 因子个数，将 $f$ 迭代下去，问迭代多少次能得到 $2$。思路模拟就行。求因子个数时注意处理完全平方数。#include &lt;bits/stdc++.h&gt;
using namespace std;
long long sol(long long x)
{
    long long temp = 0;
    long long i;
    for (i = 1; i * i &lt;= x; i++)
    {
        if (x % i == 0)
            temp++;
    }
    temp = temp &lt;&lt; 1;
    i--;
    if (i * i == x)
        temp--;
    return temp;
}
int main()
{
    long long n;
    cin &gt;&gt; n;
    int ans = 0;
    while (1)
    {
        n = sol(n);
        ans++;
        if (n == 2)
        {
            cout &lt;&lt; ans &lt;&lt; endl;
            return 0;
        }
    }
    return 0;
}
1F. Maki 和 Tree大意在树（无向）中有黑白两种点。求 $n$ 个点的树中有多少简单路径有且仅有通过一个黑色点。思路先预处理各个白色连通及其大小，具体思路是读入一条边如果这条边的两端都是白色连通块就连在一起（并查集）。然后再算各个黑点的答案。#include &lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
int fa[111111];  //父亲
int kdm[111111]; //孩子数量
string color;
int f(int x)
{ //寻找祖先
    if (fa[x] == x)
        return x;
    return f(fa[x]);
}
void uni(int x, int y)
{ //连接 x 点和 y 点
    int p = f(x), q = f(y);
    if (p != q)
    {
        if (kdm[p] &gt; kdm[q])
        {
            fa[q] = p;
            kdm[p] += kdm[q] + 1;
        }
        else
        {
            fa[p] = q;
            kdm[q] += kdm[p] + 1;
        }
    }
}
ll t[111111]; //统计连通块白点数量
vector&lt;int&gt; g[111111];
ll gao(vector&lt;int&gt; temp)
{ //temp 为黑点的每个相邻白点孩子数量集合
    ll res = 0, i;
    ll n = temp.size();
    if (n == 0)
        return 0;
    ll dp[n] = {0}, sum[n] = {0}, s = 0;
    sum[0] = s = temp[0];
    for (i = 0; i &lt; n; i++)
    {
        res += temp[i];
    }
    for (i = 1; i &lt; n; i++)
    {
        sum[i] = s += temp[i];
    }
    for (i = 1; i &lt; n; i++)
    {
        dp[i] = dp[i - 1] + temp[i] * sum[i - 1];
    }
    return res + dp[n - 1];
}
int main()
{

    int n, i, j;
    cin &gt;&gt; n &gt;&gt; color;
    for (i = 1; i &lt;= n; i++)
        fa[i] = i;
    for (i = 1; i &lt; n; i++)
    {
        int x, y;
        cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y);
        g[y].push_back(x);
        if (color[x - 1] == 'W' &amp;&amp; color[y - 1] == 'W')
            uni(x, y);
    }
    ll sum = 0;
    for (i = 1; i &lt;= n; i++)
        t[i] = kdm[f(i)] + 1;
    for (i = 1; i &lt;= n; i++)
    {
        if (color[i - 1] == 'B')
        {
            vector&lt;int&gt; temp;
            for (j = 0; j &lt; g[i].size(); j++)
            {
                if (color[g[i][j] - 1] == 'W')
                    temp.push_back(t[g[i][j]]); //若相邻点是白点，加入 temp
            }
            sum += gao(temp);
        }
    }
    cout &lt;&lt; sum;
}
1G. Eli 和字符串大意给出一个字符串，求连续子串的最小长度，要求这个连续子串要包含至少 $k$ 个相同的某个字母。思路前缀和加尺取法。前缀和用于求某个连续子串各个字母出现的次数。尺取法即连续子串两个指针，右指针不断右移，当发现满足条件的连续子串则左指针开始右移，当右指针移动到尽头则停止。#include &lt;bits/stdc++.h&gt;
using namespace std;
int cnt[26][200010];
int main()
{
    int n, k;
    string a;
    cin &gt;&gt; n &gt;&gt; k &gt;&gt; a;
    int l = a.size();
    for (int i = 0; i &lt; l; i++)
    {
        for (int j = 0; j &lt; 26; j++)
        {
            cnt[j][i + 1] = cnt[j][i];
        }
        cnt[a[i] - 'a'][i + 1]++;
    }
    int p1 = 0, p2 = 1, ans = n + 1;
    while (1)
    {
        int flag = 0;
        for (int i = 0; i &lt; 26; i++)
        {
            if (cnt[i][p2] - cnt[i][p1] &gt;= k)
            {
                ans = min(ans, p2 - p1);
                flag = 1;
            }
        }
        if (flag == 1)
            p1++;
        else
            p2++;
        if (p2 == n + 1)
            break;
    }
    if (ans == n + 1)
        cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;
    else
        cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
1H. Nozomi 和字符串大意一个 $01$ 串，允许你改变其中的 $k$ 个数字，然后找出一个尽可能长的连续子串，这个子串上的所有字符都相同。求这个子串的长度。思路依然是尺取法。分成将 $0$ 变成 $1$ 和将 $1$ 变成 $0$ 两种情况。对于前者，还是两个指针，右指针不断右移，当遇到 $0$ 就用掉一次操作直到次数用尽。接下来右指针继续右移直到再次需要操作的时候，这时左指针右移直到已用操作数恰好减一为止，这时右指针继续右移。后者同理。#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    string s;
    int n, k, ans = 0;
    cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;
    int pl = 0, pr = 0, change = 0;
    // 0 =&gt; 1
    for (int i = 0; i &lt; n; i++)
    {
        if (s[i] == '0')
        {
            if (change &lt; k)
            {
                change++;
            }
            else
            {
                while (pl &lt;= pr &amp;&amp; s[pl] != '0')
                    pl++;
                pl++;
            }
        }
        pr++;
        ans = max(ans, pr - pl);
    }
    pl = 0, pr = 0, change = 0;
    for (int i = 0; i &lt; n; i++)
    {
        if (s[i] == '1')
        {
            if (change &lt; k)
            {
                change++;
            }
            else
            {
                while (pl &lt;= pr &amp;&amp; s[pl] != '1')
                    pl++;
                pl++;
            }
        }
        pr++;
        // cout &lt;&lt; pl &lt;&lt; &quot; &quot; &lt;&lt; pr &lt;&lt; endl;
        ans = max(ans, pr - pl);
        // cout &lt;&lt; ans &lt;&lt; endl;
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
1I. Nico 和 Niconiconi大意给出一个字符串，其中 nico 计 $a$ 分，niconi 计 $b$ 分，niconiconi 计 $c$ 分，每个字符都只能参与一次计分，问最大分数。思路简单 DP。$dp[i]$ 可由 $dp[i-1]$、$dp[i-3]$、$dp[i-5]$ 和 $dp[i-9]$ 转移而来，转移后取最大者即可。要注意避免越界。#include &lt;bits/stdc++.h&gt;
using namespace std;
long long dp[300010];
int main()
{
    string s;
    long long n, a, b, c;
    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; s;
    for (long long i = 0; i &lt; n; i++)
    {
        if (i &gt; 0)
            dp[i] = dp[i - 1];
        if (i &gt;= 3 &amp;&amp; s.substr(i - 3, 4) == &quot;nico&quot;)
            dp[i] = max(dp[i], dp[i - 3] + a);
        if (i &gt;= 5 &amp;&amp; s.substr(i - 5, 6) == &quot;niconi&quot;)
            dp[i] = max(dp[i], dp[i - 5] + b);
        if (i &gt;= 9 &amp;&amp; s.substr(i - 9, 10) == &quot;niconiconi&quot;)
            dp[i] = max(dp[i], dp[i - 9] + c);
    }
    cout &lt;&lt; dp[n - 1] &lt;&lt; endl;
    return 0;
}
1J. ## TODO2020 牛客寒假算法基础集训营 2枚举、贪心、DP、数论、思维、数据结构、哈希2A. 做游戏大意石头剪刀布。已知两人分别出了多少次石头、剪刀和布，求其中一个玩家最多能获胜多少局。思路贪心。让尽量多的剪刀 - 布、石头 - 剪刀和布 - 石头成组，可以直接出答案 $min(A,Y)+min(B,Z)+min(C,X)$。#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    long long a, b, c, x, y, z;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; x &gt;&gt; y &gt;&gt; z;
    cout &lt;&lt; min(a, y) + min(b, z) + min(c, x) &lt;&lt; endl;
    return 0;
}
2B. 排数字大意给出一个字符串 $S$，问将字符串打乱后最多能有多少个不同的连续子串为 $616$ 。思路只需将所有的 $6$ 和 $1$ 集中起来：$6161616...$ ，因此统计 $6$ 和 $1$ 的个数即可，得出答案。注意 $cnt6$ 个 $6$ 最多能只造 $cnt6-1$ 个满足题意的字串，所以是 $min(cnt6-1,cnt1)$。如果算出来小于零应该将答案调整为 $0$。#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int n, cnt1 = 0, cnt6 = 0;
    string s;
    cin &gt;&gt; n &gt;&gt; s;
    for (int i = 0; i &lt; n; i++)
    {
        if (s[i] == '1')
            cnt1++;
        else if (s[i] == '6')
            cnt6++;
    }
    cout &lt;&lt; max(0, min(cnt6 - 1, cnt1)) &lt;&lt; endl;
    return 0;
}
2C. 算概率大意一共 $n$ 道题，第 $i$ 道题的正确率是 $p_i$​，给出这个正确率对 $10^9+7$ 取模的结果，求这 $n$ 题里恰好有 $0,1,\cdots,n$ 题正确的概率分别是多少，同样对 $10^9+7$ 取模。对分数取模的定义已在题目给出。思路简单 DP。一个难点是求状态转移方程，一个是理解题目中对分数取模的概念（本蒟蒻在补第四套题时才会的乘法逆元，做这道题时直接观察样例对 $\frac{1}{2}$ 取模的结果，然后分子分母代进 $a$ 和 $b$ 蒙一把，发现简单粗暴地将概率乘个 $(10^9+7)+1$ 就是了）。要求前 $i$ 题正确 $j$ 题的概率，首先要知道的是前面具体过了哪几道题我们不需要知道（这里有点靠直觉），我们只需要简单粗暴地把它当作一个整体参与后面的计算。接下来，我们要分两种情况讨论，一个是第 $i$ 题对了 $f_{i-1,j} \cdot p_i$，一个是第 $i$ 题错了 $f_{i,j} \cdot (1-p_i)$，加起来就是了。状态转移方程 $f_{i,j} = f_{i-1,j} \cdot p_i+f_{i-1,j} \cdot (1-p_i)$。#include &lt;bits/stdc++.h&gt;
using namespace std;

long long n, p[2005], dp[2005][2005];

int main()
{
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++)
    {
        cin &gt;&gt; p[i];
    }
    dp[0][0] = 1;
    for (int i = 1; i &lt;= n; i++)
    {
        dp[i][0] = dp[i - 1][0] * (1000000008 - p[i]) % 1000000007;
        for (int j = 1; j &lt;= i; j++)
            dp[i][j] = (dp[i - 1][j] * (1000000008 - p[i]) + dp[i - 1][j - 1] * p[i]) % 1000000007;
    }
    for (int i = 0; i &lt;= n; i++)
        cout &lt;&lt; dp[n][i] &lt;&lt; ' ';
    return 0;
}

2D. 数三角大意给出 $n$ 个点，问这 $n$ 个点形成的三角形中，总共有多少个钝角三角形。思路签到。枚举后比较 $a^2+b^2$ 和 $c^2$ 即可，另外注意三点不能共线。#include &lt;bits/stdc++.h&gt;
using namespace std;

int n, a[505], b[505], ans = 0;

bool f(int i, int j, int k)
{
    int check1 = (a[j] - a[i]) * (a[k] - a[i]) + (b[j] - b[i]) * (b[k] - b[i]);
    int check2 = (a[j] - a[i]) * (b[k] - b[i]) - (a[k] - a[i]) * (b[j] - b[i]);
    return check1 &lt; 0 &amp;&amp; check2 != 0;
}
int main()
{
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++)
        cin &gt;&gt; a[i] &gt;&gt; b[i];
    for (int i = 0; i &lt; n; i++)
    {
        for (int j = i + 1; j &lt; n; j++)
        {
            for (int k = j + 1; k &lt; n; k++)
            {
                if (f(i, j, k) || f(k, i, j) || f(j, i, k))
                {
                    ans++;
                }
            }
        }
    }

    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
2E. 做计数大意求有多少个不同的正整数三元组 $(i,j,k)$ 满足 $\sqrt i+\sqrt j = \sqrt k$，而且 $i \cdot j \leq n$。思路看过一样的题，所以说多去看百度贴吧的营销号推送确实能涨知识。见到根号疯狂平方就对了（必要时候还是要移项的）。等式左右两边平方，$i+j+2 \sqrt {ij}=k$，发现要使 $k$ 为整数，必需要令 $i \cdot j$ 为完全平方数，所以我们就枚举完全平方数，然后再枚举这些完全平方数的因数。#include &lt;bits/stdc++.h&gt;
using namespace std;
int n, ans;
int main()
{
    cin &gt;&gt; n;
    for (int i = 1; i * i &lt;= n; i++)
    {
        for (int j = 1; j &lt;= i; j++)
            if (i * i % j == 0)
                ans += 2;
        ans--;
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
2F. 拿物品大意多个物品，每个物品两个属性 $a$ 和 $b$， 甲乙两人轮流拿物品，最后甲的得分为其拿到物品的 $a$ 属性的和，乙则为 $b$ 属性的和。问两人最优策略下会拿哪些物品。思路假设两人赛后互换物品 $(a_1,b_1)$ 和 $(a_2,b_2)$，那么两人得分变化分别为 $-a_1+a_2$ 和 $b_1-b_2$，如果想让前者得分更大，要有 $a_1+b_1 &lt; a_2+b_2$。后者同理。所以就按照 $a+b$ 排序。#include &lt;bits/stdc++.h&gt;
using namespace std;

const int N = 2e5 + 7;
int n;
vector&lt;int&gt; sa, sb;
struct temp
{
    int a, b, id;
} a[N];

bool cmp(temp a, temp b)
{
    return a.a + a.b &gt; b.a + b.b;
}

int main()
{
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++)
        cin &gt;&gt; a[i].a;
    for (int i = 1; i &lt;= n; i++)
    {
        cin &gt;&gt; a[i].b;
        a[i].id = i;
    }
    sort(a + 1, a + 1 + n, cmp);
    for (int i = 1; i &lt;= n; ++i)
        ((i &amp; 1) ? sa : sb).push_back(a[i].id);
    for (auto i : sa)
        cout &lt;&lt; i &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;
    for (auto i : sb)
        cout &lt;&lt; i &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;
    return 0;
}
2G. 判正误大意给出七个整数 $a, b, c, d, e, f, g$ 问是否有 $a^d+b^e+c^f=g$。数据范围 $10^9$ 级别，数据量 $10^3$ 级别。思路在模的意义下上快速幂验证，也就是验证 $a^d+b^e+c^f \equiv g \left ( mod \ M\right )$。模数越多，数据越水，就越稳。#include &lt;bits/stdc++.h&gt;
using namespace std;
const int mod[] = {2, 3, 5, 7, 11, 31, 71, 97, 233, 397, 433, 449, 607, 857, 10007, 21179, 36251, 44579, 62003, 72883, 97843, 139991, 232013, 369353, 681521, 692711, 777241, 822821, 1956761, 2145137, 2915837, 6229117, 7788787, 13743493, 17331841, 19260817, 19269293, 19959809, 21006959, 23937083, 24410849, 28452757, 28478603, 29229359, 35570827, 35604011, 35875487, 37370863, 38303347, 38475517, 38819149, 40455791, 44021539, 45641993, 46531301, 48866749, 50529641, 52634191, 52790587, 55180799, 56971613, 58259351, 60954737, 62207269, 63367453, 65072599, 66017821, 67952779, 69475349, 74689217, 77059907, 77907121, 79391659, 84768797, 85584601, 85724879, 85756609, 86850899, 91783511, 92331541, 94519499, 96375241, 99033413, 99486311, 100569829, 106873549, 109329881, 109913681, 111186487, 111894067, 112136617, 112417363, 114011921, 119143363, 122994493, 123747781, 124001021, 126515639, 128191039, 128767909, 132222763, 133587661, 139644719, 145641527, 153388423, 155187077, 156883333, 157989581, 159538063, 161488643, 164039129, 166070447, 169181543, 169554227, 173564801, 175742867, 185469637, 187203899, 191263223, 198691817, 204144887, 211631201, 217903877, 218028203, 220073423, 228143453, 228667423, 232064653, 240519263, 245647159, 247586411, 247936121, 250949197, 253413211, 253464329, 260572729, 260590409, 262887773, 265711423, 266763641, 273585149, 276472817, 276500531, 280543667, 280649591, 281385491, 291366337, 293273159, 296973107, 302890501, 306568693, 315614297, 316729409, 317617121, 320337781, 320613497, 321322823, 324691051, 325963067, 327184157, 329900633, 330670159, 332058781, 332213669, 332300869, 334382221, 341895677, 347938237, 349011827, 349347503, 349906439, 353796941, 364557253, 364755931, 367946441, 372413831, 374358983, 379589897, 381149689, 389431873, 404683493, 405216109, 405495029, 408142403, 408989747, 410841979, 410935093, 412405351, 412592459, 412722139, 412990573, 418171483, 421270357, 424233613, 427938449, 428492083, 429962881, 430883569, 434988383, 435941201, 438816151, 440052953, 440143589, 444693631, 453646433, 455847109, 456640189, 457911511, 458185237, 463116761, 463861417, 469275953, 471298573, 471712513, 478267417, 483824813, 494828483, 497397293, 499657393, 507957479, 512906621, 519346459, 519879973, 520094713, 523213693, 525673273, 529575763, 529883803, 533887031, 534260809, 535328309, 541992667, 542253071, 544780177, 545567609, 552922529, 555129893, 555820037, 558473471, 563484017, 571310471, 578121241, 582251063, 583825639, 584121323, 592038487, 599098811, 601467677, 610073969, 615059213, 619220713, 622457177, 627412609, 630547919, 632342989, 637357363, 638865419, 648268013, 650007487, 651564761, 654115433, 661281713, 662664461, 667914281, 682988213, 691099121, 691445809, 692038043, 692411953, 698620943, 699007259, 701164631, 706806461, 707096251, 707697451, 709566589, 719095829, 725756807, 736880491, 739603867, 743026709, 744236861, 744396049, 747393791, 749395103, 760341121, 762934307, 773124059, 773195911, 776162609, 781629113, 781884613, 786120631, 788314343, 788898377, 788939293, 790209983, 791933183, 796328783, 798643889, 802280047, 803293991, 803847559, 809752739, 818520473, 820434047, 826810489, 829359959, 829707427, 836587463, 841011167, 843763253, 849410557, 851226437, 853058471, 853168793, 853778327, 859086391, 860720017, 863193077, 873061181, 888803059, 893035529, 900902953, 904636883, 917949577, 921817139, 922328707, 931449133, 933074827, 933156233, 935241721, 935632799, 939948881, 957119773, 961329913, 965269573, 965337949, 967551691, 971080093, 973578143, 976825877, 985100197, 985413691, 986124823, 990650057, 998244353, 999058883, 1000000007};
int ff(int a, int m)
{
    return (a % m + m) % m;
}
int Pow(int a, int b, int c)
{
    int ret = 1;
    while (b)
    {
        if (b &amp; 1)
            ret = ret * 1ll * a % c;
        a = a * 1ll * a % c;
        b &gt;&gt;= 1;
    }
    return ret;
}
int a, b, c, d, e, f, g;

bool check(int m)
{
    return ((Pow(ff(a, m), d, m) + Pow(ff(b, m), e, m)) % m + Pow(ff(c, m), f, m)) % m == ff(g, m);
}

int main()
{
    int T;
    cin &gt;&gt; T;
    while (T--)
    {
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f &gt;&gt; g;
        bool flag = 1;
        for (int i = 0; i &lt; 349; ++i)
        {
            if (!check(mod[i]))
            {
                flag = 0;
                break;
            }
        }
        puts(flag ? &quot;Yes&quot; : &quot;No&quot;);
    }
    return 0;
}
第三场。2020 牛客寒假算法基础集训营 4搜索、简单 STL、前缀和、二分搜索、位运算、贪心、分治、树4A. 欧几里得大意给出了一个递归实现的 GCD 的代码，告诉你递归次数，求最开始的两个数，它们不相同且都是非负数，使这两个数的和最小。思路签到题。递归次数为 $0$ 次的时候肯定这两个是 $1$ 和 $0$。递归次数为 $1$ 次的时候则是 $2$ 和 $1$。假设说 $a$ 大于 $b$，其实就是已知 $b$ 和 $a\ mod\ b$，然后要让 $a$ 最小，那么就让 $\left \lfloor \frac{a}{b} \right \rfloor$ 最小。那就让它等于 $1$，可以很快发现是斐波那契数列。#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main()
{
    int T;
    cin &gt;&gt; T;
    while (T--)
    {
        long long n;
        cin &gt;&gt; n;
        long long a[n + 10];
        a[0] = 1;
        a[1] = 2;
        for (int i = 2; i &lt; n + 7; i++)
        {
            a[i] = a[i - 1] + a[i - 2];
        }
        if (n == 0)
            cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;
        else
            cout &lt;&lt; a[n + 1] &lt;&lt; endl;
    }
    return 0;
}
4B. 括号序列大意给出一个仅包含 [、]、(、)、{、} 六种字符的括号序列，判断其是否合法。思路签到题。开一个栈来储存左括号，读到右括号看看栈顶的左括号和它匹不匹配。匹配就 POP 一个左括号。每时每刻都判断一下栈是不是空的。#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main()
{
    string a;
    cin &gt;&gt; a;
    stack&lt;char&gt; b;
    for (int i = 0; i &lt; a.size(); i++)
    {
        // cout &lt;&lt; a[i];
        if (a[i] == '[')
            b.push('[');
        else if (a[i] == '{')
            b.push('{');
        else if (a[i] == '(')
            b.push('(');
 
 
        else if (a[i] == ']')
        {
            if (b.empty() || (! b.empty() &amp;&amp; b.top() != '['))
            {
                cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
                return 0;
            }
            else if (! b.empty())
                b.pop();
        }
        else if (a[i] == ')')
        {
            if (b.empty() || (! b.empty() &amp;&amp; b.top() != '('))
            {
                cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
                return 0;
            }
            else if (! b.empty())
                b.pop();
        }
        else if (a[i] == '}')
        {
            if (b.empty() || (! b.empty() &amp;&amp; b.top() != '{'))
            {
                cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
                return 0;
            }
            else if (! b.empty())
                b.pop();
        }
    }
    if (b.empty())
        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
    return 0;
}
4C. 子段乘积大意给出一个数列和一个数字 $k$，求其长度为 $k$ 的连续子段的乘积对 $998244353$ 取模余数的最大值。思路其实会乘法逆元的话就可以尺取了，可惜我刚开始做这题的时候不会，只好线段树了。反正期间也不用改动数字，懒标记什么的统统不要，把线段树建起来直接开始查询。#include &lt;bits/stdc++.h&gt;
 
using namespace std;
 
const int maxn = 200010;
 
int a[maxn + 2];
 
struct tree
{
    int l, r;
    long long pre, add;
} t[4 * maxn + 2];
 
void bulid(int p, int l, int r)
{
    t[p].l = l;
    t[p].r = r;
    if (l == r)
    {
        t[p].pre = a[l];
        return;
    }
    int mid = l + r &gt;&gt; 1;
    bulid(p * 2, l, mid);
    bulid(p * 2 + 1, mid + 1, r);
    t[p].pre = (t[p * 2].pre * t[p * 2 + 1].pre) % 998244353;
}
 
long long ask(int p, int x, int y)
{
    if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
        return t[p].pre;
    int mid = t[p].l + t[p].r &gt;&gt; 1;
    long long ans = 1;
    if (x &lt;= mid)
        ans = ans * ask(p * 2, x, y) % 998244353;
    if (y &gt; mid)
        ans = ans * ask(p * 2 + 1, x, y) % 998244353;
    return ans;
}
 
int main()
{
    int n, m;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; i++)
        scanf(&quot;%d&quot;, &amp;a[i]);
    bulid(1, 1, n);
    long long ans = -1;
    for (int i = 1; i + m - 1 &lt;= n; i++)
    {
        int x, y;
        ans = max(ans, ask(1, i, i + m - 1));
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
4D. 子段异或大意给出一个数列，让你需要输出其中异或值为 $0$ 的不同连续子段的数量。思路首先用到了前缀和的思想，将前缀异或存进一个数组里。然后接合异或的性质：如果 $a\ xor\ b=c$，那么 $c\ xor\ a=b$，那么数组里任意两个数异或就是某一个区间的异或值，反正我们也不用关心这个区间从哪开始从哪结束，又因为 $a\ xor\ a=0$，我们给数组排下序，看看相邻两个数字是否相等就可以啦。#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main()
{
    int n;
    cin &gt;&gt; n;
    long long a[n + 10];
    long long temp;
    cin &gt;&gt; temp;
    a[0] = temp;
    for (int i = 1; i &lt; n; i++)
    {
        cin &gt;&gt; temp;
        a[i] = a[i - 1] ^ temp;
    }
    sort(a, a + n);
    long long ans = 0, cnt = 1;
    for (int i = 0; i &lt; n; i++)
    {
        if (a[i] == 0)
            ans++;
        if (i != 0 &amp;&amp; a[i] == a[i - 1])
            cnt++;
        if (i != 0 &amp;&amp; (a[i] != a[i - 1] || i == n - 1))
        {
            ans += cnt * (cnt - 1) / 2;
            cnt = 1;
        }
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
4E. 最小表达式大意给出一个字符串，里面只包含 $1$ 到 $9$ 还有加号。要求给出字符串的一个排列，使排列后是一个合法的算式而且算式的计算结果最小。思路贪心。加号的数字知道后就知道要有多少个数相加。然后我们将大的数字放在个位十位这种低位数，将小的数字放在高位数。然后是大数加法。#include &lt;bits/stdc++.h&gt;
using namespace std;

int cnt[20];
int sum[500050];

string s;
int main()
{
    cin &gt;&gt; s;
    int ccnt = 1;
    int n = s.size();
    for (int i = 0; i &lt; n; i++)
    {
        if (isdigit(s[i]))
        {
            cnt[s[i] - '0']++;
        }
        else
        {
            ccnt++;
        }
    }
    int p = 0, cp = 0;
    for (int i = 10; i &gt;= 1; i--)
    {
        while (cnt[i])
        {
            sum[cp] += i;
            cnt[i]--;
            p = (p + 1) % ccnt;
            if (p == 0)
                cp++;
        }
    }
    for (int i = 0; i &lt; 500010; i++)
    {
        sum[i + 1] += sum[i] / 10;
        sum[i] %= 10;
    }
    int opt = 0;
    for (int i = 500010; i &gt;= 0; i--)
    {
        if (opt || sum[i])
        {
            cout &lt;&lt; sum[i];
            opt = 1;
        }
    }
    cout &lt;&lt; endl;
    return 0;
}
4J. 二维跑步完整题目一个点在平面直角坐标系中移动，初始位置 $(0,0)$，移动了 $n$ 次。从 $(i,0)$ 可以移动到 $(i+1,0)$、$(i+1,1)$、$(i+1,2)$、$(i,0)$、$(i-1,1)$、$(i-1,2)$，从 $(i,1)$ 可以移动到 $(i+1,0)$、$(i+1,1)$、$(i+1,2)$、$(i,1)$、$(i-1,0)$、$(i-1,2)$，从 $(i,2)$ 可以移动到 $(i+1,0)$、$(i+1,1)$、$(i+1,2)$、$(i,2)$、$(i-1,0)$、$(i-1,1)$。这里的 $(i,0)$ 移动到 $(i,0)$ 没有打错，而是不变换坐标的前提下消耗一个步数。已知 $n$ 和 $m$，数值均小于 $3 \cdot 10^6$，然后问你有多少种方式使得点的 $x$ 坐标最后落在 $[-m,m]$，答案对 $998244353$ 取模输出。思路坐标等价理解题目在讲啥后，首先要做的是简化题目条件，你会发现这么多的坐标其中纵坐标只有三种，$0$、$1$ 和 $2$，当横坐标增加的时候（也就是从 $i$ 变成 $i+1$ 了，后面类似），无论初始位置的纵坐标是啥，能够到达的位置的纵坐标都是任意的。当横座标不变，纵坐标都是不变的。当横坐标减少的时候，无论初始位置的纵坐标是啥，能够到达的位置的纵坐标都只有两个可选而且都不等于初始位置的纵坐标。综上所述，我们发现纵坐标在这题是无关紧要的，横坐标相同的三个点是等价的。那么我们就可以将题目理解为：从 $x=i$ 的点到 $x=i+1$ 的点有三种方法，到 $x=i$ 的点有一种方法，到 $x=i-1$ 的点有两种方法。排列组合考虑到 $n$ 步下来本质还是左移、右移、不动三种方式的组合，只需设出三种方式分别的步数，用组合数公式即可。这里不妨设 $x$ 坐标不变的次数为 $i$，其中 $a$ 次 $x$ 坐标增加了，那么就会有 $n-i-a$ 次坐标减少。我们可以知道最后的坐标位置为 $x_{final}=a-(n-i-a)=2a-n+i$。为了让这个坐标处于 $[-m,m]$ 这个区间，我们要有：$\left\{\begin{matrix} -m \leq 2a-n+i \leq m \ 0 \leq a \leq n-i \end{matrix}\right. $由于 $a$ 还是一个整数，算出来的结果还需要上下取整：$max(\left \lceil \frac{-m+n-i}{2} \right \rceil,0)\leq a \leq min(\left \lfloor \frac{m+n-i}{2} \right \rfloor,n-i)$结合高中数学内容，我们知道 $i$ 次坐标不变，$a$ 次坐标增加的方案数一共是 $C _{n}^{i}(C _{n-i}^{a} \cdot 3^{a} \cdot 2^{n-i-a})$，我们进行求和操作，得出的结果是：$ans = \sum_{i=0}^{n} \textrm{C} _{n}^{i}(\sum_{a=max(\left \lceil \frac{-m+n-i}{2} \right \rceil,0)}^{min(\left \lfloor \frac{m+n-i}{2} \right \rfloor,n-i)} \textrm{C} _{n-i}^{a} \cdot 3^{a} \cdot 2^{n-i-a}) $优化考虑到 $n$ 和 $m$ 的数据范围，直接进行计算肯定是不行，我们尝试将上面的式子拆为多部分。令：$\left\{\begin{matrix}f(p,q)=C_p^q \cdot3^q \cdot 2^{p-q} \ L(i)=max(\left \lceil \frac{-m+n-i}{2} \right \rceil,0) \ R(i)=min(\left \lfloor \frac{m+n-i}{2} \right \rfloor,n-i) \ G(i)=\sum_{a=L(i)}^{R(i)}f(n-i,a) \ ans = \sum_{i=0}^{n}C_{n}^{i} G(i) \end{matrix}\right.$在这些式子中，我们发现要缩短 $ans$ 的计算时间，就必须缩短 $G(i)$ 的计算时间。考虑到计算 $G(i)$ 时 $L(i)$ 和 $R(i)$ 都是一次性计算完成，但是 $f(p,q)$ 这样的式子我们要算上很多遍，我们我们就尝试优化 $f(p,q)$ 的计算。所谓优化很多时候就是预处理。我们看看对应的式子：组合数，得算阶乘吧，得算 $2$ 的 $p-q$ 次幂吧，得算 $3$ 的 $q$ 次幂吧，全部预处理掉。接下来就比较玄学了，考虑到我们除了要计算 $f(n-i,a)$，还要计算 $f(n-i-1,a)$、$f(n-i+1,a)$ 等等，因为恰好有 $C_p^q=C_{p-1}^{q}+C_{p-1}^{q-1}$ 这个公式，也就有了前项推后项的思路。我们尝试将 $2$ 和 $3$ 的指数和组合数匹配一下，得出 $f(p,q)=2f(p-1,q)+3f(p-1,q-1)$ 这样的式子。接下来就不用再管 $f(p,q)$ 等于什么了，回到 $G(i)$ 这个层面。我们用上面的结论尝试展开上面的式子：$G(i)=\sum_{a=L(i)}^{R(i)}f(n-i,a)$  $=\sum_{a=L(i)}^{R(i)}(3f(n-(i+1),a-1)+2f(n-(i+1),a))$  $=3f(n-(i+1),L(i)-1)+2f(n-(i+1),L(i))+3f(n-(i+1),L(i))+ \cdots +2f(n-(i+1),R(i)-1))+3f(n-(i+1),R(i)-1)+2f(n-(i+1),R(i))$  $=5 \sum_{a=L(i)}^{R(i)-1}f(n-(i+1),a)+3f(n-(i+1),L(i)-1)+2f(n-(i+1),R(i))$你会发现有一项是 $\sum_{a=L(i)}^{R(i)-1}f(n-(i+1),a)$，和 $G(i+1)$ 的形式很像，但是后者是 $\sum_{a=L(i+1)}^{R(i+1)}f(n-(i+1),a)$，还是有点区别。怎么办呢？就人为创造一个 $\sum_{a=L(i+1)}^{R(i+1)}f(n-(i+1),a)$ 呗。还是上面那个式子，我们把所有的 $L(i)$ 换成 $L(i+1)$，把 $R(i)-1$ 换成 $R(i+1)$，但这算出来就和 $G(i)$ 差了几个的 $f(n-i,a)$ 怎么办呢。先标记为 $\Delta$ 到后面再算呗。$G(i)=\sum_{a=L(i+1)}^{R(i+1)+1}f(n-i,a)+\Delta$  $=\sum_{a=L(i+1)}^{R(i+1)+1}(3f(n-(i+1),a-1)+2f(n-(i+1),a))+\Delta$  $=3f(n-(i+1),L(i+1)-1)+2f(n-(i+1),L(i+1))+3f(n-(i+1),L(i+1))+ \cdots +2f(n-(i+1),R(i+1)))+3f(n-(i+1),R(i+1))+2f(n-(i+1),R(i+1)+1)+\Delta$  $=5 \sum_{a=L(i+1)}^{R(i+1)}f(n-(i+1),a)+3f(n-(i+1),L(i+1)-1)+2f(n-(i+1),R(i+1)+1)+\Delta$  $=5G(i+1)+3f(n-(i+1),L(i+1)-1)+2f(n-(i+1),R(i+1)+1)+\Delta$代码实现在式子乘个 1ll 可以有效避免溢出的问题。计算高次幂为了避免溢出，在写快速幂的时候也要每步取模。计算组合数的时候需要用到除以比较大的数，还是为了避免溢出这时候也是要取模的。于是就打开了乘法逆元的新世界，道理其实也不是很懂，大概就是如果有一个素数 $p$，根据费马小定理则有 $a^{p-1}\equiv1(mod\;p)$，那么 ${a}\cdot a^{p-2}\equiv1(mod\;p)$，$a^{p-2}$ 就叫 $a\ mod\ p$ 意义下的逆元，照用就是了。#include &lt;bits/stdc++.h&gt;
using namespace std;
 
const int mod = 998244353;
const int N = 3000010;
int n, m, f2[N], f3[N], q[N], p[N], G[N];
 

//////// 快速幂 ////////
int qpow(int a, int b) {
    int ans = 1;
    a %= mod;
    for (; b; b &gt;&gt;= 1) {
        if (b &amp; 1) ans = 1ll * ans * a % mod;
        a = 1ll * a * a % mod;
    }
    return ans;
}

//////// 组合数 ////////
int c(int a, int b) { return 1ll * q[a] * p[b] % mod * p[a - b] % mod; }

//////// 算 f(a,b) ////////
int f(int a, int b) { return 1ll * c(a, b) * f3[b] % mod * f2[a - b] % mod; }

int main() {
    cin &gt;&gt; n &gt;&gt; m;
    f2[0] = f3[0] = q[0] = 1;
    for (int i = 1; i &lt;= n; i++) {
        // 算 i!，2 的 i 次方，3 的 i 次方，对 mod 取模
        q[i] = 1ll * q[i - 1] * i % mod;
        f2[i] = 1ll * f2[i - 1] * 2 % mod;
        f3[i] = 1ll * f3[i - 1] * 3 % mod;
    }

    // 乘法逆元
    p[n] = qpow(q[n], mod - 2);
    for (int i = n - 1; i &gt;= 0; i--) p[i] = 1ll * p[i + 1] * (i + 1) % mod;

    //////// 算 G(i) ////////
    int l = 0, r = 1; G[n] = 1;
    for (int i = n - 1; i &gt;= 0; i--, r++) {

        // 算 5 * G(i + 1) + 3 * f(...) + 5 * f(...)
        G[i] = (5ll * G[i + 1] % mod + 3ll * f(n - i - 1, l - 1) % mod + 2ll * f(n - i - 1, r) % mod) % mod;
        int ql = max((n - i - m + 1) / 2, 0), qr = min((n - i + m) / 2, n - i);
        // 此时 l = L(i + 1), r = R(i + 1) + 1
        // 此时 ql = L(i), qr = R(i)
        
        // 算 delta
        while (l &lt; ql) G[i] = (1ll * G[i] - f(n - i, l) + mod) % mod, l++;
        while (l &gt; ql) l--, G[i] = (1ll * G[i] + f(n - i, l)) % mod;
        while (r &gt; qr) G[i] = (1ll * G[i] - f(n - i, r) + mod) % mod, r--;
        while (r &lt; qr) r++, G[i] = (1ll * G[i] + f(n - i, r)) % mod;
        // 此时 l = L(i), r = R(i)
        // 此时 i--, r++
    }

    //////// 算答案 ////////
    int ans = 0;
    for (int i = n; i &gt;= 0; i--) ans = (ans + 1ll * G[i] * c(n, i) % mod) % mod;
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
2020 牛客寒假算法基础集训营 5字符串、二分、哈希、DP、模拟、搜索、数学5A. 模板大意给出两个字符串，允许对其中一个字符串做任意的替换、删除最后一位、在末尾添加一个字母。问最少的步数，使两个字符串相同。思路签到题。逐个位置匹配，发现不一样则步数加一。当长度较短的字符串匹配完后再加上两个字符串的长度差。#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    string a, b;
    cin &gt;&gt; a &gt;&gt; b;
    if (n &lt; m)
    {
        swap(n, m);
        swap(a, b);
    }
    int ans = 0;
 
    for (int i = 0; i &lt; m; i++)
    {
        if (a[i] != b[i])
            ans++;
    }
    ans += n - m;
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
5B. 牛牛战队的比赛地大意已知多个点的坐标，问平面上哪个位置满足到这些点的距离的最大值最小。思路三分答案。大概是因为它是二次函数，每次使用三分都能排除最差的一部分答案。二分答案似乎也是可以的，但二分的依据是单调性，二次函数也没法保证这一点，所以做起来似乎要麻烦很多。#include &lt;bits/stdc++.h&gt;
using namespace std;

struct p
{
    int x, y;
} a[100005];
int n;
double check(double x)
{
    double max = 0;
    for (int i = 0; i &lt; n; i++)
    {
        double tmp = sqrt(a[i].y * a[i].y + (a[i].x - x) * (a[i].x - x));
        if (tmp &gt; max)
            max = tmp;
    }
    return max;
}
double tsearch(double left, double right)
{
    int i;
    double mid, midmid;
    for (i = 0; i &lt; 100; i++)
    {
        mid = left + (right - left) / 2;
        midmid = mid + (right - mid) / 2;
        if (check(mid) &gt; check(midmid))
            left = mid;
        else
            right = midmid;
    }
    return mid;
}
int main()
{
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++)
        cin &gt;&gt; a[i].x &gt;&gt; a[i].y;
    double max = tsearch(-10000, 10000);
    cout &lt;&lt; check(max) &lt;&lt; endl;
    return 0;
}
5C. C 语言 IDE大意输入一份 C 语言代码，要求输出代码中出现的函数。思路哦，是码农大模拟！爱了爱了。#include &lt;bits/stdc++.h&gt;
using namespace std;

string source;
void replaceAll(string &amp;s, string oldstr, string newstr)
{
    for (string::size_type pos = 0; pos != string::npos; pos += newstr.length())
        if ((pos = s.find(oldstr, pos)) != string::npos)
            s.replace(pos, oldstr.length(), newstr);
        else
            break;
}
struct functions
{
    string inClass, name, outputType;
    vector&lt;string&gt; inputType;
    functions(string inClass = &quot;&quot;, string name = &quot;&quot;, string outputType = &quot;void&quot;, vector&lt;string&gt; inputType = vector&lt;string&gt;(0))
        : inClass(inClass), name(name), outputType(outputType), inputType(inputType) {}
};
vector&lt;functions&gt; funs;
void solve(string &amp;s)
{
    replaceAll(s, &quot;/*&quot;, &quot; /* &quot;);
    replaceAll(s, &quot;*/&quot;, &quot; */ &quot;);
    replaceAll(s, &quot;//&quot;, &quot; // &quot;);
    replaceAll(s, &quot;(&quot;, &quot; ( &quot;);
    replaceAll(s, &quot;)&quot;, &quot; ) &quot;);
    replaceAll(s, &quot;{&quot;, &quot; { &quot;);
    replaceAll(s, &quot;}&quot;, &quot; } &quot;);
    replaceAll(s, &quot;=&quot;, &quot; = &quot;);
    replaceAll(s, &quot;\&quot;&quot;, &quot; \&quot; &quot;);
    replaceAll(s, &quot;'&quot;, &quot; ' &quot;);
    replaceAll(s, &quot;;&quot;, &quot; ; &quot;);
    replaceAll(s, &quot;,&quot;, &quot; , &quot;);
    replaceAll(s, &quot;+ = &quot;, &quot;+=&quot;);
    replaceAll(s, &quot;- = &quot;, &quot;-=&quot;);
    replaceAll(s, &quot;* = &quot;, &quot;*=&quot;);
    replaceAll(s, &quot;/ = &quot;, &quot;/=&quot;);
    replaceAll(s, &quot;^ = &quot;, &quot;^=&quot;);
    replaceAll(s, &quot;| = &quot;, &quot;|=&quot;);
    replaceAll(s, &quot;&amp; = &quot;, &quot;&amp;=&quot;);
    replaceAll(s, &quot;:&quot;, &quot; : &quot;);
    replaceAll(s, &quot; :  : &quot;, &quot;::&quot;);
    vector&lt;string&gt; tokens;
    string now = &quot;&quot;;
    for (int i = 0; s[i]; i++)
    {
        if (s[i] == ' ' || s[i] == '\t' || s[i] == '\r' || s[i] == '\n' || s[i] == '\0')
        {
            if (now != &quot;&quot;)
            {
                if (now == &quot;:&quot; &amp;&amp; tokens.back() == &quot;)&quot;)
                {
                    string tmpnow = &quot;&quot;;
                    for (int j = i + 1; s[j]; j++)
                    {
                        if (s[j] == ' ' || s[j] == '\t' || s[j] == '\r' || s[j] == '\n' || s[j] == '\0')
                        {
                            if (tmpnow == &quot;{&quot;)
                            {
                                now = &quot;{&quot;;
                                i = j - 1;
                                break;
                            }
                            tmpnow = &quot;&quot;;
                        }
                        else
                            tmpnow += s[j];
                    }
                    continue;
                }
                if (now == &quot;const&quot;)
                {
                    now = &quot;&quot;;
                    continue;
                }
                if (now == &quot;//&quot;)
                {
                    for (int j = i; s[j]; j++)
                    {
                        if (s[j] == '\n')
                        {
                            i = j - 1;
                            break;
                        }
                    }
                    now = &quot;&quot;;
                    continue;
                }
                if (now == &quot;/*&quot;)
                {
                    int num = 1;
                    string tmpnow = &quot;&quot;;
                    for (int j = i + 1; s[j]; j++)
                    {
                        if (s[j] == ' ' || s[j] == '\t' || s[j] == '\r' || s[j] == '\n' || s[j] == '\0')
                        {
                            if (tmpnow == &quot;/*&quot;)
                                num++;
                            if (tmpnow == &quot;*/&quot;)
                            {
                                num--;
                                if (num == 0)
                                {
                                    i = j - 1;
                                    break;
                                }
                            }
                            tmpnow = &quot;&quot;;
                        }
                        else
                            tmpnow += s[j];
                    }
                    now = &quot;&quot;;
                    continue;
                }
                tokens.push_back(now);
                now = &quot;&quot;;
            }
        }
        else
            now += s[i];
    }
    int cnt = 0;
    string nowNamespace = &quot;&quot;;
    for (int i = 1; i &lt; (int)tokens.size(); i++)
    {
        if ((tokens[i] == &quot;struct&quot; || tokens[i] == &quot;class&quot;) &amp;&amp; tokens[i + 2] == &quot;{&quot;)
        {
            cnt = 0;
            nowNamespace = tokens[i + 1];
            i += 2;
        }
        functions tmp(nowNamespace);
        if (tokens[i] == &quot;{&quot; &amp;&amp; tokens[i - 1] == &quot;)&quot;)
        {
            int num = 1;
            for (int j = i - 2; j &gt;= 0; j--)
            {
                if (tokens[j] == &quot;)&quot;)
                    num++;
                if (tokens[j] == &quot;(&quot;)
                {
                    num--;
                    if (num == 0)
                    {
                        tmp.name = tokens[j - 1];
                        tmp.outputType = &quot;&quot;;
                        for (int k = j - 2; k &gt;= 0; k--)
                            if (tokens[k] != &quot;}&quot; &amp;&amp; tokens[k] != &quot;}&quot; &amp;&amp; tokens[k] != &quot;;&quot; &amp;&amp;
                                tokens[k].back() != ':' &amp;&amp; tokens[k] != &quot;inline&quot; &amp;&amp;
                                tokens[k] != &quot;static&quot; &amp;&amp; tokens[k][0] != '#' &amp;&amp;
                                tokens[k].back() != '\&quot;' &amp;&amp; tokens[k].back() != '&gt;')
                                tmp.outputType = tmp.outputType == &quot;&quot; ? tokens[k] : tokens[k] + &quot; &quot; + tmp.outputType;
                            else
                                break;
                        int last = i - 2;
                        for (int k = i - 2; k &gt;= j; k--)
                        {
                            if (tokens[k] == &quot;(&quot; || tokens[k] == &quot;,&quot;)
                            {
                                string tt = &quot;&quot;;
                                for (int t = k + 1; t &lt; last; t++)
                                    tt = tt == &quot;&quot; ? tokens[t] : tt + &quot; &quot; + tokens[t];
                                if (tt != &quot;&quot;)
                                    tmp.inputType.push_back(tt);
                                last = k - 1;
                            }
                            if (tokens[k] == &quot;=&quot; || tokens[k] == &quot;)&quot;)
                                last = k - 1;
                        }
                        reverse(tmp.inputType.begin(), tmp.inputType.end());
                        break;
                    }
                }
            }
            funs.push_back(tmp);
            num = 1;
            for (int j = i + 1; j &lt; (int)tokens.size(); j++)
            {
                if (tokens[j] == &quot;{&quot;)
                    num++;
                if (tokens[j] == &quot;}&quot;)
                {
                    num--;
                    if (num == 0)
                    {
                        i = j;
                        break;
                    }
                }
            }
            continue;
        }
        if (nowNamespace != &quot;&quot;)
        {
            if (tokens[i] == &quot;{&quot;)
                cnt++;
            if (tokens[i] == &quot;}&quot;)
            {
                cnt--;
                if (!cnt)
                    nowNamespace = &quot;&quot;;
            }
        }
    }
}
int main()
{
    char ch;
    while ((ch = getchar()) != EOF)
        source += ch;
    solve(source);
    for (auto &amp;i : funs)
    {
        if (i.outputType != &quot;&quot;)
            cout &lt;&lt; i.outputType &lt;&lt; &quot; &quot;;
        if (i.inClass != &quot;&quot;)
            cout &lt;&lt; i.inClass &lt;&lt; &quot;::&quot;;
        cout &lt;&lt; i.name &lt;&lt; &quot;(&quot;;
        for (int j = 0; j &lt; (int)i.inputType.size(); j++)
            cout &lt;&lt; i.inputType[j] &lt;&lt; (j == (int)i.inputType.size() - 1 ? &quot;)&quot; : &quot;,&quot;);
        if ((int)i.inputType.size() == 0)
            cout &lt;&lt; &quot;)&quot;;
        cout &lt;&lt; endl;
    }
    return 0;
}
5E. Enjoy the Game大意给出一个规则：$n$ 张卡牌，先手第一步最少拿 $1$ 张，最多拿 $n-1$ 张。接下来每一步，双方最少要拿 $1$ 张，最多拿等同于上一步对方拿的牌数的牌。拿走最后一张牌胜。问对不同的 $n$，先手是否有必胜策略。思路找规律找出来的，只要是二的幂就是 Alice 胜，否则就是 Bob 胜。这题好像把 __builtin_popcount(n) 给卡了，原因不明，反正下次是不敢用了。#include &lt;bits/stdc++.h&gt;
using namespace std;
 
long long lowbit(long long x)
{
    return x&amp;(-x);
}
   
int main()
{
    long long n;
    cin &gt;&gt; n;
    if (lowbit(n) == n)
    {
        cout &lt;&lt; &quot;Alice&quot; &lt;&lt; endl;
        return 0;
    }
    cout &lt;&lt; &quot;Bob&quot; &lt;&lt; endl;
    return 0;
}
5H. Hash大意给出一个字符串和一个 Hash 函数（核心代码 res = (res * 26 + str[i] - 'a') % mod;），求一个字典序最小且大于该字符串且有着相同 Hash 的字符串。思路其实就是把字符串转成了二十六进制数，然后给它取模。那么要想 Hash 值相同字典序还要大于原字符串，就直接给这个二十六进制数加上模数就好了。#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main()
{
    string a;
    int m;
    int ta[6];
    while (cin &gt;&gt; a &gt;&gt; m)
    {
        int org[6], backup[6];
        for (int i = 0; i &lt; 6; i++)
        {
            org[i] = a[i] - 'a';
            backup[i] = org[i];
        }
        string b = a;
        for (int i = 5; i &gt;= 0; i--)
        {
            ta[i] = m % 26;
            m /= 26;
        }
        if (m != 0)
        {
            cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;
        }
        for (int i = 5; i &gt; 0; i--)
        {
            org[i] += ta[i];
            if (org[i] &gt; 25)
            {
                org[i] -= 26;
                org[i - 1]++;
            }
        }
        org[0] += ta[0];
        if (org[0] &lt; 26)
        {
            for (int i = 0; i &lt; 6; i++)
            {
                printf(&quot;%c&quot;, org[i] + 'a');
            }
            cout &lt;&lt; endl;
            continue;
        }
        else
        {
            cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;
            continue;
        }
    }
 
    return 0;
}
5I. I 题是个签到题大意给出一场比赛参赛人数和各题过题人数，通过人数不低于全场人数的 $80\%$ 或在所有题目中前三多就叫签到题。问 I 题是不是签到题。思路签到题。排序即可，关键是要处理并列的情况。#include &lt;bits/stdc++.h&gt;
using namespace std;
 
struct temp
{
    int num;
    int ac;
} a[20000];
 
bool cmp(temp a, temp b)
{
    return a.ac &gt; b.ac;
}
 
int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 0; i &lt; n; i++)
    {
        cin &gt;&gt; a[i].ac;
        a[i].num = i;
    }
    if (a[8].ac * 10 &gt;= m * 8)
    {
        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
        return 0;
    }
    sort(a, a + n, cmp);
    int cnt = 1;
    int cur = 1;
    if (a[0].num == 8)
    {
        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
        return 0;
    }
    for (int i = 1; i &lt; n; i++)
    {
        if (a[i].ac != a[i - 1].ac)
        {
            cnt += cur;
            cur = 1;
        }
        else
        {
            cur++;
        }
        if (a[i].num == 8 &amp;&amp; cnt &lt;= 3)
        {
            cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
            return 0;
        }
        if (cnt &gt; 3)
        {
            cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
            return 0;
        }
    }
}
5J. 牛牛战队的秀场大意求圆内接正 $n$ 边形的边长。思路签到。可以很容易地计算每条弦对应的圆心角的大小，然后三角函数。#include &lt;bits/stdc++.h&gt;
using namespace std;
 
#define PI 3.1415926535898
 
int main()
{
    double n, r, i, j;
    cin &gt;&gt; n &gt;&gt; r &gt;&gt; i &gt;&gt; j;
    if (i == j)
    {
        cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;
        return 0;
    }
    if (i &gt; j)
        swap(i, j);
    double ans = min(j - i, i - j + n);
    printf(&quot;%.8lf\n&quot;, ans * 2 * r * sin(360 / n / 2 * PI / 180));
    return 0;
}
2020 牛客寒假算法基础集训营 6贪心、图论、构造、二分、计数、数论、思维6A. 配对大意给出两个集合，每个集合里有 $N$ 个数，不同集合的两个数配对并求和，要求最大化第 $K$ 大的和。思路#include &lt;bits/stdc++.h&gt;
using namespace std;
 
typedef long long ll;
 
int main()
{
    ll n, k;
    cin &gt;&gt; n &gt;&gt; k;
    ll a[n], b[n], c[n];
    for (ll i = 0; i &lt; n; i++)
    {
        cin &gt;&gt; a[i];
    }
    for (ll i = 0; i &lt; n; i++)
    {
        cin &gt;&gt; b[i];
    }
    sort(a, a + n);
    sort(b, b + n);
    for (int i = 0; i &lt; k; i++)
    {
        c[i] = a[n - 1 - i] + b[n - k + i];
    }
    sort(c, c + k);
    cout &lt;&lt; c[0] &lt;&lt; endl;
    return 0;
}
B.</description>
</item>
<item rdf:about="https://static.bobby285271.top/index.php/2020/02/03/How-to-Deploy-WordPress-on-a-Fedora-Server-en.html">
<title>How to Deploy WordPress on a Fedora Server (en)</title>
<link>https://static.bobby285271.top/index.php/2020/02/03/How-to-Deploy-WordPress-on-a-Fedora-Server-en.html</link>
<dc:date>2020-02-02T16:00:00+00:00</dc:date>
<description>First things firstYou should get a IP address after buying VPS, such as 123.123.123.123. Open your favourite terminal and enter:Replace 123.123.123.123 with your actual IP address.ssh root@123.123.123Enter your password to login. Perform a full upgrade on your system:dnf upgrade
Package InstallationInstall Apache, PHP and MariaDB using the DNF package manager. There is NO need to install the wordpress package.dnf install @&quot;Web Server&quot; php-mysqlnd mariadb-server
Enable the web and database services to start at boot time, then start them immediately:systemctl enable httpd.service mariadb.service
systemctl start httpd.service mariadb.serviceMariaDB ConfigurationFirstly, initialize MariaDB. If this is your first use of MariaDB, you should create a password for your root user here. Don’t use the system’s own root (administrator) password. It is suggested to answer y to all yes-no questions afterwards:mysql_secure_installationNext, create a database. You can host more than one WordPress site on a machine. Therefore, you may want to choose a distinctive name for yours. For instance, this example uses mywpsite. The -p switch prompts you for a password.Replace mywpsite with a database name you preferred.mysqladmin create mywpsite -u root -pNext, set up a special privileged user and password for the database. The web app uses these credentials to run. Use the standard mysql client program for this step. The -D option attaches to the built-in MySQL database where privileges are stored.Replace sqluser and password with a user name you preferred and a strong password.mysql -D mysql -u root -pGRANT ALL PRIVILEGES ON mywpsite.* TO 'sqluser'@'localhost' IDENTIFIED BY 'password';
FLUSH PRIVILEGES;
QUIT;Set up the Web ServerNext, tune the SELinux parameters so the web server can perform necessary functions.setsebool -P httpd_can_network_connect_db=1
setsebool -P httpd_can_sendmail=1Next, configure your firewall so it allows traffic on port 80 (HTTP):firewall-cmd --add-service=http --permanent
firewall-cmd --reloadDownload WordPressThese latest version of WordPress are always available on https://wordpress.org/latest.tar.gz.cd /var/www/html
wget https://wordpress.org/latest.tar.gzExtract the downloaded archive to the document root of your domain and update permissions on files.tar xzf latest.tar.gz
chown -R apache.apache wordpress
chmod -R 755 wordpressAll DoneVisit 123.123.123.123/wordpress, and finish the installation.</description>
</item>
<item rdf:about="https://static.bobby285271.top/index.php/2019/12/26/Dynamic-Programming-on-Tree-Structures-Luogu-P2014.html">
<title>Dynamic Programming on Tree Structures (Luogu P2014)</title>
<link>https://static.bobby285271.top/index.php/2019/12/26/Dynamic-Programming-on-Tree-Structures-Luogu-P2014.html</link>
<dc:date>2019-12-26T09:22:00+00:00</dc:date>
<description>题目https://www.luogu.com.cn/problem/P2014思路以下内容仅为个人理解，可能存在错误。树的孩子兄弟表示法想要使用孩子兄弟表示法储存上面这样的一棵树，我们就要从根节点开始，依次用链表存储各个节点的孩子节点和兄弟节点。因此，该链表中的节点应包含以下三部分内容：节点的值。指向孩子节点的指针。指向兄弟节点的指针。在这里，每个节点是一门课程，孩子节点其实就是后续课程，兄弟节点其实就是前导课程相同的一门课程。不妨将第 i 门课程编号为 i，那么每一门课都会有一个独一无二的课程编号。这个课程编号本应放在数据域，但是考虑到它的独一无二性和连续性，也方便我们查找某一课程的「后续课程」和「前导课程相同的一门课程」的课程编号，以获取它的学分，我们不妨直接用数组下标来储存这个，就不开数据域了。树形动归TODO：此部分自认为没有理解透彻，下面给出的思路也不够自然。考虑之前发过的几道题，LXY 点菜，我们逐道菜过目；上山采药，我们逐件药品过目。这里我们照葫芦画瓢，就逐门课过目。树形动归和线性动归又有些啥不同呢？首先要遵循从最简单的子问题开始，逐步扩大子问题规模的原则，从子树上动归，最后进行合并。如何体现合并这一操作呢？就是在过目某一节点（课程）的时候同时考虑这个节点（课程）的后续课程。不妨就将根节点（假设其编号为 now）的所有孩子过目完，假设现在过目了 a 门课程，选择了 b 门课程。对于这个第 a 门课程依然是两个选择，选和不选。不选的话和我过目 a - 1 门课程，选择了 b 门课程效果是一样的，而第 a 门课程我不选自然就拿不了学分，其后续课程我也选不了就无需考虑了。但如果我选择呢，我不但选了第 a 门课程，而且还要考虑它的后续课程。假设已知我过目完 a - 1 门课程时，选择了 b - c 门课程。过目第 a 门课程显然我就考虑了第 a 门课的后续课程并选择了 c 门课程（包含 a）。此时为了求出过目了 a 门课程，选择了 b 门课程的最大学分，我就要求出过目 a - 1 门课程，选择了 b - c 门课程的最大学分和考虑了第 a 门课的所有后续课程并选择了 c 门课程（包含 a）的最大学分。而由于我们从子树开始动归，所以后者我们是已经求出过的。考虑完选和不选两种情况后，取最大值即可。假设 son 是 now 的一个子节点，有：f[now][i][j] = max(f[now][i - 1][j], f[son][所有节点数][k] + f[now][i - 1][j - k]);和线性动态规划一样，由于过目了 i 门课程的情况永远由过目 i - 1 门课程的情况推出来，于是这一维可以被去掉。f[now][j] = max(f[now][j], f[son][k] + f[now][j - k]);AC 代码#include &lt;bits/stdc++.h&gt;
using namespace std;
//n、m 如题所述，f[i][j] 表示 i 为子树的根节点，在子树中选 j 门课的最大学分
int n, m, f[1000][1000], fa;
struct node //用结构体储存节点信息
{
    int pre, to; //pre 为兄弟节点在数组 e 中的下标，to 为孩子节点在数组 e 中的下标
} e[1000];       //考虑到课程编号的唯一性，这题 e 数组下标可用来表示课程编号，我们也不用开数据域了

void dp(int now) //在「根节点编号为 now 的树」中动归
{
    //遍历 now 的所有孩子节点，也就是先访问 now 的「第一个」儿子节点，然后再访问这个儿子节点的兄弟节点
    for (int i = e[now].to; i != 0; i = e[i].pre)
    {
        dp(i);                           //在「根节点编号为 i 的树」中动归
        for (int j = m + 1; j &gt;= 1; j--) //关于为什么要反向遍历，前面的文章有提及
        {
            for (int k = 0; k &lt; j; k++)
                f[now][j] = max(f[now][j], f[i][k] + f[now][j - k]); //状态转移方程
        }
    }
}
int main()
{
    ios::sync_with_stdio(false); //是输入输出挂
    cin.tie(0);                  //还是输入输出挂
    cout.tie(0);                 //依然是输入输出挂
    cin &gt;&gt; n &gt;&gt; m;
    //我们令 i 为节点（课程）的编号
    //不妨假定存在一门编号为 0 的课，是所有课程的先修课程且学分为 0
    //这样子我们就可以将所有的课程标在一棵树上
    for (int i = 1; i &lt;= n; i++) //接下来我们从 i = 1 开始读入 n 个节点（课程）
    {
        cin &gt;&gt; fa;           //fa 是节点 i 的父节点（先修课程）的编号
        cin &gt;&gt; f[i][1];      //显然 j == 1 时最大学分就是编号为 i 的这门课本身的学分
        e[i].pre = e[fa].to; //指明节点 i 的兄弟节点是节点 fa 的「第一个」儿子节点
        e[fa].to = i;        //更新节点 fa 的「第一个」儿子节点为节点 i
    }
    dp(0); //从编号为 0 的根节点开始动归
    //输出 0 为根节点，选 m + 1 门课的最大学分
    //m + 1 门课是因为我们无中生有了一门「所有课程的先修课」，也就是编号为 0 的这门课
    cout &lt;&lt; f[0][m + 1] &lt;&lt; endl;
    return 0;
}
</description>
</item>
<item rdf:about="https://static.bobby285271.top/index.php/2019/12/18/Introduction-to-Segment-Tree-Luogu-P3372.html">
<title>Introduction to Segment Tree (Luogu P3372)</title>
<link>https://static.bobby285271.top/index.php/2019/12/18/Introduction-to-Segment-Tree-Luogu-P3372.html</link>
<dc:date>2019-12-18T15:35:00+00:00</dc:date>
<description>SCNUACM 新生赛的 C 题被我用 N 方算法水过去了，很惭愧，还是想了解一下正解。当然了，一切的基础，就是熟悉相关的模板咯！题目https://www.luogu.com.cn/problem/P3372思路以下内容仅为个人理解，可能存在错误。显然，对给出的区间中的每一个数逐个加 k（操作 1）或者一个一个数累加下去来求和（操作 2）是会超时的。我们先抛开操作 1 不谈，试想一下对于操作 2，如果我们可以把这个区间分成几个小块，然后又事先知道每一小块中的元素求和的结果，那我求和的时候是不是就不需要算那么多项呢？是不是也就快一点呢？于是就有了分块思想。如果我们把这个思想给贯彻地彻底一些，事先将几个小块拼在一起形成一个大块，又事先算出每一大块中的元素求和的结果，会不会再更快一些呢？以此类推，树形结构就被我们构建出来了。事实上，线段树就是一种二叉树（但不一定是完全二叉树，下面配图就是一个反例，感谢 CGY 提醒）。它的每一个子节点都表示整个序列中的一段子区间，每个叶子节点都表示序列中的单个元素信息，父节点整合了他的每一个子节点的信息。有人会问既然是求和，直接前缀和不就好了吗。刚开始我也是这样想的，果然后来我就看到了树状数组的模板，后面也会去试一下。但是上面这个思路可以处理更多的情况，例如我求个最大值最小值我也可以应用。假设我的序列已经读入完毕并储存到数组 a 了（这个简单）：long long a[maxn + 2];
long long n, m;
scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);
for (long long i = 1; i &lt;= n; i++)
    scanf(&quot;%lld&quot;, &amp;a[i]);虽然说不一定是完全二叉数，但是可以用类似于创建完全二叉树的方式来创建线段树。首先，考虑单个节点。我们使用一个结构体来储存节点的信息，l 和 r 是这个节点维护的区间范围，sum 储存这个区间的和（也就是说 sum 储存了从 a[l] 到 a[r] 所有元素的和）。这里不妨结合图来理解（转载自洛谷）：接下来我们考虑整棵数。我们使用数组 t 存这颗树，用数组 t 的下标表示每个节点的编号。为什么数组要开数据量的四倍呢，可以通过计算树的高度，然后用等比数列求和公式得出。struct tree
{
    long long l, r;
    long long sum;
} t[4 * maxn + 2];接下来我们就开始建树。自然要从根开始一层一层地建下去。我们整一个建树函数，考虑向它传入三个参数，其中 p 是该节点的编号（其实就是数组 t 的下标），l 和 r 是这个节点维护的区间范围。void build(long long p, long long l, long long r);我们把这个节点建好了之后就去建它的左右儿子两个节点，显然它们的编号是 p * 2 和 p * 2 + 1（还是数组 t 的下标），这两个子节点维护的区间范围自然就要减半了。我们假设 mid = (l + r) / 2，那么就让左儿子维护 l 到 mid，右儿子维护 mid + 1 到 r。当然，我们不可能一直建下去，当 l == r 的时候这个节点只维护一个元素，这个元素正正是 a[l]（或者 a[r]）。这时就可以开始求 sum 而无需再往下建树了。你会发现 t[p].sum = a[l];，p 依然是这个节点本身的编号。那么那些 l != r 的节点又怎样计算 sum 呢？就利用上面所说的思想，直接把两个子节点的 sum 加在一起就是自己的 sum 了。void build(long long p, long long l, long long r)
{
    t[p].l = l;
    t[p].r = r;
    if (l == r)
    {
        t[p].sum = a[l];
        return;
    }
    long long mid = (l + r) / 2;
    build(p * 2, l, mid);
    build(p * 2 + 1, mid + 1, r);
    t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;
}让我们在 main 函数中调用这个函数，我们让根节点的编号为 1，按照题意根节点维护的区间范围自然是 l 到 n：build(1, 1, n);好了我们现在再来考虑一下操作 1，操作 1 是否也可以应用类似的思想呢？我们很容易想到一种看起来很简单的方法。同样是将序列分成一个一个的小块，我们直接给整个小块打上一个标签，告诉大家「这个小块里面的元素都应该被加上 k」。而小块中的元素我就干脆不碰它了。于是懒标签也就有了。我们在结构体中添加一 lazy，用作这个「标签」。struct tree
{
    long long l, r;
    long long sum, lazy;
} t[4 * maxn + 2];假设我现在让 x 到 y 这个区间的所有元素全部加 z。根据分块思想，我可以拆分这个区间为几个小的区间，使这些小区间的 sum 我都在建树的时候提前算过。我假设其中一个小的区间，也就是刚才建好的树的其中一个节点（假设它的编号为 p）维护的区间范围为 t[p].r 到 t[p].l。我们准备一个函数来处理这件事：void change(long long p, long long x, long long y, long long z);我们直接对 sum 加上「元素个数」个 z，然后打上标签，声明 t[p].r 到 t[p].l 中所有数都应该被加上 z。t[p].sum += z * (t[p].r - t[p].l + 1);
t[p].lazy += z;但是问题也来了，如何正确地拆分给定区间为几个小的区间呢。显然我们要让这些小的区间的数量尽量少，一个简单粗暴的方法就是：既然我们有一棵树，树上每个节点都有标明它维护的区间范围，我们就从这棵树的根开始，从上往下枚举这些区间，只到找到合适的区间。何为合适？if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
{
    t[p].sum += z * (t[p].r - t[p].l + 1);
    t[p].lazy += z;
}如果条件满足，我们就成功地找到了一个小的区间。如果条件不满足，我们还需要继续寻找其它的小的区间直到这些小区间拼起来正好是给定的区间。显然一个节点的左儿子和右儿子如果都是上面所说的合适的小区间，那么小的区间的数量就不是最小了，因为这个节点本身也必然是合适的。于是我们直接考虑下一层的节点。long long mid = (t[p].l + t[p].r) / 2;
if (x &lt;= mid)
    change(p * 2, x, y, z);
if (y &gt; mid)
    change(p * 2 + 1, x, y, z);要注意的是，当子节点的 sum 被改变了，要及时地将变更传递回来。t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;按理来说这个 change 函数我们基本就实现出来了。但是有一个非常坑的地方，就是如果我连续进行多个操作 1，在第一个操作 1 时，我的 t[p].sum 恰好是一个合适的小区间，被修改了，但是 t[p * 2].sum 和 t[p * 2 + 1].sum 是没有变动的，因为变更都被拦截在 t[p].lazy 那里了。在第二个操作 1 时，t[p].sum 可能不是一个合适的小区间，但 t[p * 2].sum 是。t[p * 2].sum 被修改了，而且通过上面这一行代码传了回去。试想一下 t[p].sum 的值是不是会出现错误呢？于是在必要的时候，懒标记储存的更改还是得下放下去。那懒标记存在的意义到底在哪里？要知道的是我下放懒标记仅仅是因为 t[p].sum 不是一个合适的小区间。如果它是的话，这个懒标记还是可以节约时间的。懒标记的下放很简单，就是将左右儿子的 sum 和 lazy 给改过来，把自己的懒标记归零：void spread(long long p)
{
    if (t[p].lazy)
    {
        t[p * 2].sum += t[p].lazy * (t[p * 2].r - t[p * 2].l + 1);
        t[p * 2 + 1].sum += t[p].lazy * (t[p * 2 + 1].r - t[p * 2 + 1].l + 1);
        t[p * 2].lazy += t[p].lazy;
        t[p * 2 + 1].lazy += t[p].lazy;
        t[p].lazy = 0;
    }
}这样子我们的 change 函数也就完成了！void change(long long p, long long x, long long y, long long z)
{
    if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
    {
        t[p].sum += z * (t[p].r - t[p].l + 1);
        t[p].lazy += z;
        return;
    }
    spread(p);
    long long mid = (t[p].l + t[p].r) / 2;
    if (x &lt;= mid)
        change(p * 2, x, y, z);
    if (y &gt; mid)
        change(p * 2 + 1, x, y, z);
    t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;
}我们回到开头，我们希望让 x 到 y 这个区间的所有元素全部加 z，那么我们来调用这个函数。要让这些小的区间的数量尽量少，我们从树根开始查找：long long q, x, y, z;
scanf(&quot;%lld&quot;, &amp;q);
if (q == 1)
{
    scanf(&quot;%lld%lld%lld&quot;, &amp;x, &amp;y, &amp;z);
    change(1, x, y, z);
}那么如果我想求出给定区间的和，按照上面的思想，同样也是拆分给定区间为几个小的区间。我们开一个 ans 变量，当找到合适的小区间时就把它的 sum 给累加进去。其实和 change 函数的实现几乎一样。但要注意的是，如果发现有懒标记没有下放而这个区间又不是一个合适的小区间的时候，还是要下放。不然如果它的左右孩子有一个是合适的小区间，累加进去的 sum 就是错的。long long ask(long long p, long long x, long long y)
{
    if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
        return t[p].sum;
    spread(p);
    long long mid = (t[p].l + t[p].r) / 2;
    long long ans = 0;
    if (x &lt;= mid)
        ans += ask(p * 2, x, y);
    if (y &gt; mid)
        ans += ask(p * 2 + 1, x, y);
    return ans;
}在 main 函数里面调用的时候，还是要从树根开始选取合适的小区间。long long q, x, y;
scanf(&quot;%lld&quot;, &amp;q);
if (q == 2)
{
    scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
    printf(&quot;%lld\n&quot;, ask(1, x, y));
}AC 代码#include &lt;bits/stdc++.h&gt;
using namespace std;
const long long maxn = 100010;
long long a[maxn + 2];
struct tree
{
    long long l, r;
    long long sum, lazy;
} t[4 * maxn + 2];

void build(long long p, long long l, long long r)
{
    t[p].l = l;
    t[p].r = r;
    if (l == r)
    {
        t[p].sum = a[l];
        return;
    }
    long long mid = (l + r) / 2;
    build(p * 2, l, mid);
    build(p * 2 + 1, mid + 1, r);
    t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;
}

void spread(long long p)
{
    if (t[p].lazy)
    {
        t[p * 2].sum += t[p].lazy * (t[p * 2].r - t[p * 2].l + 1);
        t[p * 2 + 1].sum += t[p].lazy * (t[p * 2 + 1].r - t[p * 2 + 1].l + 1);
        t[p * 2].lazy += t[p].lazy;
        t[p * 2 + 1].lazy += t[p].lazy;
        t[p].lazy = 0;
    }
}

void change(long long p, long long x, long long y, long long z)
{
    if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
    {
        t[p].sum += z * (t[p].r - t[p].l + 1);
        t[p].lazy += z;
        return;
    }
    spread(p);
    long long mid = (t[p].l + t[p].r) / 2;
    if (x &lt;= mid)
        change(p * 2, x, y, z);
    if (y &gt; mid)
        change(p * 2 + 1, x, y, z);
    t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;
}

long long ask(long long p, long long x, long long y)
{
    if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
        return t[p].sum;
    spread(p);
    long long mid = (t[p].l + t[p].r) / 2;
    long long ans = 0;
    if (x &lt;= mid)
        ans += ask(p * 2, x, y);
    if (y &gt; mid)
        ans += ask(p * 2 + 1, x, y);
    return ans;
}

int main()
{
    long long n, m;
    scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);
    for (long long i = 1; i &lt;= n; i++)
        scanf(&quot;%lld&quot;, &amp;a[i]);
    build(1, 1, n);
    for (long long i = 1; i &lt;= m; i++)
    {
        long long q, x, y, z;
        scanf(&quot;%lld&quot;, &amp;q);
        if (q == 1)
        {
            scanf(&quot;%lld%lld%lld&quot;, &amp;x, &amp;y, &amp;z);
            change(1, x, y, z);
        }
        else
        {
            scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
            printf(&quot;%lld\n&quot;,ask(1, x, y));
        }
    }
    return 0;
}</description>
</item>
<item rdf:about="https://static.bobby285271.top/index.php/2019/12/13/SCNUCS-N-2019-Tour.html">
<title>SCNUCS-N 2019 Tour</title>
<link>https://static.bobby285271.top/index.php/2019/12/13/SCNUCS-N-2019-Tour.html</link>
<dc:date>2019-12-13T13:10:00+00:00</dc:date>
<description>初赛去临时的 OJ 用临时的帐号打临时的比赛（误）感觉有点奇怪，把题目存了一份：https://pan.baidu.com/s/1tLYZA2ssDN2lCqiZWqMGqQ，提取码 jnq2。纪录一下第一次，可能也是惟一一次提前半小时 AK。问题最多的居然是 A 题签到题，刚开始还想逐个数判断是不是完全平方数。后来想想不就是两个边界开个根号的事嘛。另一个 D 题签到题似乎刚考完三个数的现在才问两个数的。异或出了两题很过分，然而一道是去年蓝桥杯热身赛的原题完全不用想，另外一道似乎是防 AK 题我刚开始还试图交个 n 方看看数据强不强。降维好像也不难吧无非是统计下序列中有多少个数转成二进制之后有奇数个一，多少个是偶数个一。奇数个一的数和偶数个一的数异或结果还是奇数个一。有一说一在洛谷看题解骚操作确实学得多，一个 __builtin_popcount 就完事。完美数嘛就打表出奇迹。开一个 10000 大的数组把结果先搞出来丢程序里也就代码长了点嘛。于是欢乐数继续打表，还担心溢出加了个 log10 算一下位数。至于交换字符那一题题目翻译一下不就是 y 可以随便挪位置嘛，反正无论怎么挪 x 和 z 的相对顺序都不会变，那就将全部 y 全部丢到第一个 z 前面其它原样输出就好了。数据似乎很弱我怀疑我漏了情况但我没有证据。下周石牌校区继续白给。决赛第一次是可以带纸质资料进赛场的。刚开始对此是真的毫无头绪，寻思这带过去的要不就是自己早就掌握的，要不就是自己本来就没理解的，那还有什么用。后来也不想考虑太多，去洛谷搜索模板，按照难度排序，从 入门 一直到 提高 只要题目看的懂的就把高赞题解的代码抄下来（还把问题本身也给抄下来了我太机智了）。后来被 CGY 嘲讽了一波（我也想拿区域铜 orz）。周四香农先修班下课后讲课的师兄也提供了一份模板，感觉不会的东西实在太多决定新生赛还是先用自己的。C 语言老师那边丧心病狂地周四周五连续上了八节课，于是我也决定要丧心病狂地划水（不是，周五那天上到最后两节笔记本没电就滚去看紫书了虽然依然没学到什么 周六在补各种作业（写到这里，突然想起有个三代单传大锅下周要出 0.1？)。比赛当天十点就出发拉到石牌校区了，看时间好像还早就跟着 PYY 去天河城玩去了，靠复印模板还骗到了一顿饭确实香。结果因为校园太大我又路痴还是差点迟到（吹一波南海校区麻雀虽小但五脏俱全）。计科居然还有专门的 ACM 实验室，但比赛现场的机子也确实该升级了，甚至还跑着 Windows XP 系统（没记错的话）。题面 PDF 存档：https://pan.baidu.com/s/1CyhXu-0SZ7axguL64xTcwQ（提取码 4ckt）。比赛开始前一分钟拿到题面，照例先看 A 题，10 的 100 次方？高精乘除法警告，下一题下一题。相比之下 B 题好像友好很多，差点忘记 d 整除 a 到底是 d % a == 0 还是 a % d == 0 全靠样例解释（不过如果真是前者还做个屁啊）。又是 GCD，交了一发 TLE 开始慌了，马上看榜发现计科已经有人过掉三题了迅速开启根榜模式。发现 J 和 L 题都是良心签到就去秒掉了。然后跑去看 E 题，马上跑去打了个表，我居然从 P == 1 一直打到 P == 63，等了一会不耐烦回到 B 题想起初赛时的 A 题我犯的错误好像一模一样，赶紧开个根号优化一下也过了。表打出来才发现 P 是素数于是又把打出来的数加一 log2 算了一发瞪眼判断是不是素数，筛掉不是的就将题目过了（讲完题解才发现打个屁的表啊题面上都有了）。接着还是继续跟榜（计科巨佬不带歪榜太良心了），H 不就是 2、3、5 出现的次数分别存一下嘛也没怎么想。F 倒是出问题了，忘记 x % 3 == 0 的情况，又忘记特判 X == 5，吃了两发 WA。终于都过掉之后榜单排前面的神犇过的题似乎都差不多。开始看 C 题和 D 题。D 题又是考异或，想到了要特判 X == 0 忘记特判 X == 1（怎么我每次 WA 都是忘记特判）。C 题看着确实像我带着的线段树模板，但是问的东西和我模板的不一样没法直接套用。当时内心：新生赛哪有可能考这种鬼东西。不是前缀和或差分一律当超纲处理。开始 n 方暴力求解，cin、cout、stringstream 全部用上，不出意料 TLE。于是又跳到 I 题，刚开始还想着如果 2、3、5 出现的次数全部符合条件怎样分情况讨论，讨论个屁。这时候还剩 A、C、G、K 没过，距离封榜时间也不多了。K 题差点又想贪心完再对连续多天刷同一 OJ 的情况作处理，不过状态转移方程好像很好写的样子（有一说一是真的好写，我第一次看洛谷 P1164 那种题时内心是绝望的）。好的还剩三题（ACG 是啥呀我也不知道呀）。开始集中火力干 C 题。我当时依然坚信暴力出奇迹，只是出题人想卡常而已。于是 cin 被改成了 scanf，cout 被改成了 printf，stringstream 改成了对十取模再对数除以十一路累加的做法（还得感谢广工的某位神犇当时点出来了所以印象非常深刻），本想着如果还过不了就再进一步上快读没想到居然过了。封榜之后看 G 题，考图的题本来是应该直接放弃的。但是我又带了单源最短路径和最小生成树的模板决定还是看一下题吧（其实是因为没得挑了）。发现问法和单源最短路径的好像差不多，就三个区别。一个是有向图变成了无向图，另外一个是指明了终点 t，还有一个是它还需要我回答经过了多少个节点。不管三七二十一把模板打上去了先，发现模板最后会输出到达每个点的情况，而我只需要到达一个点的情况，换掉就是了。至于每一条无向边我都直接转化成了两条有向边。而经过的点有多少在算距离的时候似乎可以同时算。居然也过了。感觉这次准备模板还是值得的。A 题这边实在能力有限（我觉得哪怕真的把高精写出来想不出正解估计也是得超时）。比赛完就去听题解了，师兄讲的飞快，怕是 CGY 速度（只是突然想起了 AK 杯结束后的那个中午）。发现 C 题暴力不是正解刚开始有点幸灾乐祸，后来看滚榜发现靠这题还把计院的 WSD 和 PHS 挤下去了还是感觉自己配不上这个第三名（第一名是打星玩家，第二名是 SJL，感觉都是比我强很多很多很多很多很多的人，毕竟我也只是个暑假才开始入门的萌新），说白了还是时间复杂度没学好（果然无知者无畏）。后来去计院那边的咨询群坦白了自己是暴力过的，出题人验题人反正好多人都主动背锅感觉大家都不容易啊。不知什么时候自己才能熟练掌握正解呢，无论是 A 题还是 C 题还是 G 题？靠暴力靠模板确实不是长远之计啊，就说 G 题这回还好只是有向变无向，下一回如果像 LZH 说的那样求第二短的路径？第 N 短的路径？或者 C 题时间限制从 2s 改回 1s？完。比赛结束后拍了一张自己的座位，那是真的乱得一批。顺便吐槽一句发过来的气球刚开始还是充好气的，后来就不充气直接贴桌子上了，再后来就干脆不发了。以及... 第一次看滚榜。[vplayer url="https://bobby285271.coding.net/p/img/d/img/git/raw/master/scnuacmrnk.mp4"  /]</description>
</item>
<item rdf:about="https://static.bobby285271.top/index.php/2019/11/17/Dynamic-Prgramming---0-1-Backpack-Problem-Luogu-P1164-P1048-P1020.html">
<title>Dynamic Prgramming - 0/1 Backpack Problem (Luogu P1164, P1048, P1020)</title>
<link>https://static.bobby285271.top/index.php/2019/11/17/Dynamic-Prgramming---0-1-Backpack-Problem-Luogu-P1164-P1048-P1020.html</link>
<dc:date>2019-11-17T15:29:00+00:00</dc:date>
<description>为啥突然想要看动态规划呢，是因为昨天做了去年蓝桥杯预选赛 16/17 的题，做到 B 题发现正解其实应该是动态规划的。虽然我交了一发贪心过了，但想到两个星期后就是热身赛还是得搞搞突击才行。引入周四香农先修班讲了一个斐波拉契数列的专题，有一个问题是这样的：假设有 n 级楼梯，我从底部往上爬，每次可以上 1 级，也可以上 2 级楼梯，问从底部到顶部一共有多少种爬楼梯的方法。我第一时间想到的是搜索和回溯，但是既然是斐波拉契数列的专题，也就有了 $f(n) = f(n-1) + f(n-2)$ 这个公式。我简单说一下这个式子是怎么来的吧。我们不妨假设我们走了 x 步之后上到了第 n 级，那我第 x-1 步在什么位置呢？只能是第 n-1 和 n-2 级。$f(n-1)$ 是走到 n-1 级楼梯时的方法数，$f(n-2)$ 同理。考虑一下边界情况，就是斐波拉契数列了呗。P1164 -（二维 DP）题目：https://www.luogu.org/problem/P1164不妨就来考虑一下「引入」小节的思路（模拟退火是啥我也不会），我们要求吃够 m 块钱，和爬 n 级楼梯其实是一回事。我上 1 级台阶还是 2 级台阶，其实和对于一道菜，我吃还是不吃是一回事。区别在哪呢，这里我们有很多不同的菜。然而我们也不用想太多，就让它们按顺序逐个上菜好了，然后我们逐个决定是吃还是不吃，顺便记下到底花了多少钱（注意上菜不代表我们就要吃嘛对吧，吃了才花钱）。我们定义 f[i][j] 为上了 i 道菜用光 j 元钱的办法总数。假设我们现在已经上了 i-1 道菜，接下来上第 i 道菜。我们就有两个选择：吃（花钱）。不吃（不花钱）。如果不吃，那我上 i 道菜用光 j 元钱的方法数，和上了 i-1 道菜用光 j 元钱的方法数一样。如果我吃，那我上 i 道菜用光 j 元钱的方法数，和上了 i-1 道菜用光（j-这道菜的价格）的方法数一样。将两种情况和在一起，于是有：f[i][j] = f[i - 1][j] + f[i - 1][j - 第i道菜的价格];通常来讲这就结束了，但是这道菜的价格我们却没有讨论清楚。首先，如果我没钱吃着道菜呢？那就只能不吃了呗。if(j &lt; 第i道菜的价格) f[i][j] = f[i - 1][j];
if(j &gt;= 第i道菜的价格) f[i][j] = f[i - 1][j] + f[i - 1][j - 第i道菜的价格];有些人想问 j == 第i道菜的价格 这种情况怎么搞，我们将这种情况代入到上面的代码，其实就是 f[i][j] = f[i - 1][j] + f[i - 1][0]，f[i - 1][0] 其实就是上了 i-1 个菜我全不吃，消费 0 元嘛，显然只有一种情况。但形如 f[i][0] 的数据又可以从哪推出呢？不如特判一下，当然直接给他们赋值也是可以的：if(j &lt; 第i道菜的价格) f[i][j] = f[i - 1][j];
if(j == 第i道菜的价格) f[i][j] = f[i - 1][j] + 1;
if(j &gt; 第i道菜的价格) f[i][j] = f[i - 1][j] + f[i - 1][j - 第i道菜的价格];既然有了递推式（状态转移方程），我们要的是上完 n 道菜后花掉 m 块钱的方案，那就遍历一下这个数组直到得出答案为止呗。上代码：#include &lt;bits/stdc++.h&gt;
using namespace std;
int a[101], f[101][10001];
int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; i++)
    {
        cin &gt;&gt; a[i];
    }
    for (int i = 1; i &lt;= n; i++)
    {
        for (int j = 1; j &lt;= m; j++)
        {
            if (j &gt; a[i])
                f[i][j] = f[i - 1][j] + f[i - 1][j - a[i]];
            if (j == a[i])
                f[i][j] = f[i - 1][j] + 1;
            if (j &lt; a[i])
                f[i][j] = f[i - 1][j];
        }
    }
    cout &lt;&lt; f[n][m] &lt;&lt; endl;
    return 0;
}P1048（一维 DP）题目：https://www.luogu.org/problem/P1048这道题按照上面的思路打大概是怎样的呢？显然，我们开一个二位数组 f[i][j] 来表示过目 i 件药材（过目意味着我在采摘和不采摘中二选一）耗去 j 时间后的最大价值就可以了。时间如果足够，就考虑一下要不要采摘这个药材。同样地，采摘第 i 件药材耗去 j 时间的这种情况下的最大价值是过目 i-1 件药材时耗去（j-药材采摘时间）时间的最大价值。不采摘第 i 件药材耗去 j 时间的这种情况下的最大价值是过目 i-1 件药材时耗去 j 时间的最大价值。对于两种情况我们取较大者即可。那我们为啥提出希望降维呢？我们看上面的代码：if (j &gt; a[i])
    f[i][j] = f[i - 1][j] + f[i - 1][j - a[i]];
if (j == a[i])
    f[i][j] = f[i - 1][j] + 1;
if (j &lt; a[i])
    f[i][j] = f[i - 1][j];再来看一下这一题的核心代码（a[i] 为采摘时间，v[i] 为药材价值）：if (j &gt;= a[i])
    f[i][j] = max(f[i - 1][j - a[i]] + v[i], f[i - 1][j]);
else
    f[i][j] = f[i - 1][j];第 i 件物品需要求的信息永远是从第 i-1 件物品那里得出来的。如果我们最后只需要第 i 件物品的答案而不需要 i-1、i-2... 件物品的答案，我们为何不用新的信息覆盖旧的信息呢？修改的方法很简单：if (j &gt;= a[i])
    f[j] = max(f[j - a[i]] + v[i], f[j]);
// 下面的没必要保留了吧。
// else
//     f[j] = f[j];虽然降维了，但遍历还是要以上面的方式来，于是我们就得到一个似乎很有道理的代码。for (int i = 1; i &lt;= m; i++)
{
    for (int j = a[i]; j &lt;= t; j++) // 既然上面只有一个分支结构，那我在循环条件那里保证就好了。
    {
        f[j] = max(f[j - a[i]] + v[i], f[j]);
    }
}
cout &lt;&lt; f[t] &lt;&lt; endl;这却是一个非常典型的错误，因为按照原本的意思，第 i 个物品的数据要从 i-1 个物品的数据推出来，但我在上面求第 i 个物品的 f[j] 的时候却使用到了已经更新过的，已经是第 i 个物品的数据 f[j - a[i]]。怎样避免呢：#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int t, m;
    cin &gt;&gt; t &gt;&gt; m;
    int a[m + 10], v[m + 10];
    for (int i = 1; i &lt;= m; i++)
    {
        cin &gt;&gt; a[i] &gt;&gt; v[i];
    }
    int f[t + 10];
    memset(f, 0, sizeof(f));
    for (int i = 1; i &lt;= m; i++)
    {
        for (int j = t; j &gt;= a[i]; j--)
        {
            f[j] = max(f[j], f[j - a[i]] + v[i]);
        }
    }
    cout &lt;&lt; f[t] &lt;&lt; endl;
    return 0;
}附：一位神犇提供的题解，感觉比较易懂P1020（最大上升子序列）题目：https://www.luogu.com.cn/problem/P1020第二问知道是求最大上升序列之后就很简单了，最大的问题在于为什么是求这个。试给出以下解释（严格证明需要组合数学的知识）：对于给出的序列（输入数据），必定存在至少一个的最大上升子序列。任取一个最大上升子序列，其中任两个元素（导弹）必定由两套不同系统进行拦截。意味着如果最大上升子序列长度为 n，我们最少需要的系统数目必定大于或等于 n。接下来可以用数学归纳法去解释为什么当最大上升子序列长度为 n 时最少只需要 n 套系统。当 n = 1 时，给出的序列（输入数据）是单调递减的，显然只需要一套系统，结论成立。假设 n = k 时结论成立。也就是只需要 k 套系统。当 n = k + 1 时，试将给出的序列一分为二分别求解，具体方法如下：枚举出所有的最大上升子序列，将每个最大上升子序列的尾元素分别取出。如果某个数是多个最大上升子序列的尾元素则只取出一次。将取出的数按照原本的先后顺序排列生成一个新的序列（假设叫序列 1）。未取出的数也按照原来的先后顺序排列形成另一个新的序列（假设叫序列 2）。此时序列 2 的最大上升子序列长度必定为 k，那么根据前面的假设，需要 k 套系统。而序列 1 是单调递减的（可用反证法证明），由已知需要 1 套系统。所以加起来就是 k + 1 套系统。因为 k + 1 套系统可以拦截所有导弹，而由已知，需要配备的系统数需要大于等于 k + 1，所以 n = k + 1 时结论也成立。100 分代码（n 方算法）#include &lt;bits/stdc++.h&gt;
using namespace std;

int a[100005], num = 1;
int ans[100005];
int main()
{
    while (cin &gt;&gt; a[num])
        num++;
    num--;
    a[0] = 50001;
    int maxans = 0;
    for (int i = 1; i &lt;= num; i++)
    {
        for (int j = 0; j &lt; i; j++)
        {
            if (a[i] &lt;= a[j])
            {
                // cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot; &lt;&lt; ans[j] + 1 &lt;&lt; endl;
                ans[i] = max(ans[i], ans[j] + 1);
            }
        }
        // cout &lt;&lt; ans[i] &lt;&lt; endl;
        if (ans[i] &gt; maxans)
            maxans = ans[i];
    }
    cout &lt;&lt; maxans &lt;&lt; endl;

    memset(ans,0,sizeof(ans));
    maxans = 0;
    a[0] = 0;
    for (int i = 1; i &lt;= num; i++)
    {
        for (int j = 0; j &lt; i; j++)
        {
            if (a[i] &gt; a[j])
            {
                // cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot; &lt;&lt; ans[j] + 1 &lt;&lt; endl;
                ans[i] = max(ans[i], ans[j] + 1);
            }
        }
        // cout &lt;&lt; ans[i] &lt;&lt; endl;
        if (ans[i] &gt; maxans)
            maxans = ans[i];
    }
    cout &lt;&lt; maxans &lt;&lt; endl;
    return 0;
}200 分代码（nlogn 算法）#include &lt;bits/stdc++.h&gt;
using namespace std;
int a[100010], b[100010];
int num = 0, p, ans;

bool cmp(int a, int b)
{
    return a &gt; b;
}

int main()
{
    while (cin &gt;&gt; a[num])
        num++;

    ans = 1;
    b[0] = a[0];
    for (int i = 1; i &lt; num; i++)
    {
        if (a[i] &lt;= b[ans - 1]){
            b[ans] = a[i];
            ans++;
        }
        else
        {
            p = upper_bound(b, b + ans, a[i], cmp) - b;
            b[p] = a[i];
        }
    }
    // for (int i = 0; i &lt; ans; i++)
    // {
    //     cout &lt;&lt; b[i] &lt;&lt; &quot; &quot;;
    // }
    // cout &lt;&lt; endl;
    cout &lt;&lt; ans &lt;&lt; endl;

    ans = 1;
    b[0] = a[0];
    for (int i = 1; i &lt; num; i++)
    {
        if (a[i] &gt; b[ans - 1]){
            b[ans] = a[i];
            ans++;
        }
        else
        {
            p = lower_bound(b, b + ans, a[i]) - b;
            b[p] = a[i];
        }
    }
    // for (int i = 0; i &lt; ans; i++)
    // {
    //     cout &lt;&lt; b[i] &lt;&lt; &quot; &quot;;
    // }
    // cout &lt;&lt; endl;
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}</description>
</item>
<item rdf:about="https://static.bobby285271.top/index.php/2019/10/05/How-to-Launch-a-Desktop-Environment-on-WSL-2.html">
<title>How to Launch a Desktop Environment on WSL 2</title>
<link>https://static.bobby285271.top/index.php/2019/10/05/How-to-Launch-a-Desktop-Environment-on-WSL-2.html</link>
<dc:date>2019-10-04T16:00:00+00:00</dc:date>
<description>WSL 2 是 WSL 中体系结构的新版本，它改变了 Linux 发行版与 Windows 交互的方式。WSL 2 的主要目标是提高文件系统性能并增加系统调用的完全兼容性。 每个 Linux 发行版都可以作为 WSL 1 或 WSL 2 发行版运行，并可随时进行切换。WSL 2 是底层体系结构的主要功能，它使用虚拟化技术和 Linux 内核来实现其新功能。准备为了使用 WSL 2，你需要 Windows 10 内部版本 18917 或更高版本。要想了解目前使用的版本是什么，可以到设置页面查看。首先，右击任务栏 Windows 图标，选择 Windows Powershell（管理员），输入以下命令：Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform
Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux或者前往控制面板 - 程序 - 启用或关闭 Windows 功能，然后勾选虚拟机平台和执行 Linux 程序的 Windows 子系统。完成设置后需要重启计算机！安装前往 Microsoft Store 下载并安装 Ubuntu。接下来使 WSL 2 成为你的默认体系结构。打开 Windows Powershell 或命令提示符：wsl --set-default-version 2接下来在开始菜单找到 Ubuntu，点击后稍作等候。当一切准备好后，Ubuntu 会提示你新建一个账户和密码，注意输入密码时是不会有回显的。此时你可以验证刚刚安装好的 Ubuntu 所使用的 WSL 版本：wsl --list --verbose如果你在 Windows Powershell 或命令提示符下运行 wsl，同样也是可以进入 WSL 环境的。软件切换到 Root：$ sudo -i编辑 APT 软件源（nano 大法好，不接受反驳） ：# nano /etc/apt/sources.listdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse更新可用软件包列表，随后升级系统：# apt update &amp;&amp; apt dist-upgrade -y安装基本开发环境、Xubuntu 桌面和远程桌面支持：# apt install build-essential xubuntu-desktop xrdp安装的软件包比较多，可能要等上一段时间。这里的 Xubuntu 桌面实际为 XFCE 桌面环境，换成别的问题不大但还是建议选择轻量级桌面。保存 Xsession 配置：# exit #切换回普通用户。
$ echo xfce4-session &gt; ~/.xsession远程桌面需要使用远程桌面时均要执行本节内容。启用 Xrdp 服务（这里不能使用 systemctl，因为 SystemD 不是默认的 Init 系统），记录端口信息：$ sudo service xrdp start在 Windows 开始菜单栏中找到 Windows 附件 - 远程桌面连接，输入 localhost:端口，如 localhost:3389。应该会出现如下警告，选择是即可：如果你没有看到这个警告，可能需要查找虚拟机的 IP 地址并替代 localhost 再试一次：$ ip address在这里，IP 地址查找到是 172.18.221.157，端口是 3389。注意每次重启 WSL 实例后这个 IP 地址都会换。输入 IP 地址:端口，如 172.18.221.157:3389。接下来输入自己的账户密码：然后就是很熟悉的界面了：本地化直接在终端下就可以完成设置了（以下命令在 Root 下运行）：# dpkg-reconfigure locales确认 en_US.UTF-8 UTF-8 和 zh_CN.UTF-8 UTF-8 被勾选，然后将 zh_CN.UTF-8 UTF-8 设定为默认值。然后安装语言包和输入法（按理来说装完就能用）：# apt install language-pack-zh-hans language-pack-gnome-zh-hans fcitx fcitx-table彩蛋Windows 应用能访问 Linux 根文件系统啦，包括文件资源管理器！尝试在 WSL 中使用普通用户运行 explorer.exe .（在远程桌面会话中这样做是没有用滴！），看看会发生什么。另外内部错误大法又怎能缺席呢（逃）。</description>
</item>
</rdf:RDF>