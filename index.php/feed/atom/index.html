<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"
xmlns:thr="http://purl.org/syndication/thread/1.0"
xml:lang="zh-CN"
xml:base="https://static.bobby285271.top/"
>
<title type="text">Dasyatis</title>
<subtitle type="text">Life, Love, Linux</subtitle>
<updated>2020-05-03T11:49:00+00:00</updated>
<generator uri="http://typecho.org/" version="1.2/18.1.29">Typecho</generator>
<link rel="alternate" type="text/html" href="https://static.bobby285271.top/" />
<id>https://static.bobby285271.top/index.php/feed/atom/</id>
<link rel="self" type="application/atom+xml" href="https://static.bobby285271.top/index.php/feed/atom/" />
<entry>
<title type="html"><![CDATA[Review on the Development Process of SoCoding Forum]]></title>
<link rel="alternate" type="text/html" href="https://static.bobby285271.top/index.php/2020/05/03/Review-on-the-Development-Process-of-SoCoding-Forum.html" />
<id>https://static.bobby285271.top/index.php/2020/05/03/Review-on-the-Development-Process-of-SoCoding-Forum.html</id>
<updated>2020-05-03T11:49:00+00:00</updated>
<published>2020-05-03T11:49:00+00:00</published>
<author>
    <name>bobby285271</name>
    <uri>https://static.bobby285271.top</uri>
</author>
<summary type="html"><![CDATA[迭代到 0.3 了，想写点总结，先挖个坑。要不要重复造轮子佛系开发？敏捷开发？惨痛的重构经历各种奇怪的坑]]></summary>
<content type="html" xml:base="https://static.bobby285271.top/index.php/2020/05/03/Review-on-the-Development-Process-of-SoCoding-Forum.html" xml:lang="zh-CN"><![CDATA[
<p>迭代到 0.3 了，想写点总结，先挖个坑。</p><h2>要不要重复造轮子</h2><h2>佛系开发？敏捷开发？</h2><h2>惨痛的重构经历</h2><h2>各种奇怪的坑</h2>
]]></content>
<link rel="replies" type="text/html" href="https://static.bobby285271.top/index.php/2020/05/03/Review-on-the-Development-Process-of-SoCoding-Forum.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://static.bobby285271.top/index.php/feed/atom/2020/05/03/Review-on-the-Development-Process-of-SoCoding-Forum.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[NixOS Installation and Configuration Guide]]></title>
<link rel="alternate" type="text/html" href="https://static.bobby285271.top/index.php/2020/04/15/NixOS-Installation-and-Configuration-Guide.html" />
<id>https://static.bobby285271.top/index.php/2020/04/15/NixOS-Installation-and-Configuration-Guide.html</id>
<updated>2020-04-14T16:00:00+00:00</updated>
<published>2020-04-14T16:00:00+00:00</published>
<author>
    <name>bobby285271</name>
    <uri>https://static.bobby285271.top</uri>
</author>
<summary type="html"><![CDATA[本文基于 NixOS 20.03 Beta 和 NixOS Manual 20.03 撰写。本文的写作缘由是 NixOS Manual 的编排设计很容易导致习惯了其它发行版安装和配置流程的新人入...]]></summary>
<content type="html" xml:base="https://static.bobby285271.top/index.php/2020/04/15/NixOS-Installation-and-Configuration-Guide.html" xml:lang="zh-CN"><![CDATA[
<p>本文基于 NixOS 20.03 Beta 和 <a href="https://nixos.org/nixos/manual/">NixOS Manual 20.03</a> 撰写。本文的写作缘由是 NixOS Manual 的编排设计很容易导致习惯了其它发行版安装和配置流程的新人入坑失败。本篇指南给出的解决方案基本能满足<strong>大一软工专业课程学习</strong>和<strong>日常使用</strong>的需要。</p><p><strong>本文将假定你已经独立安装和配置过 Arch Linux、Gentoo 或任一官方不提供 GUI 安装程序的 Linux 发行版并掌握安装过程中涉及的大部分命令。</strong></p><h2>了解 NixOS</h2><p><a href="https://distrowatch.com/table.php?distribution=nixos">可以先从 DistroWatch 开始了解 NixOS 这个发行版</a>，<a href="https://nixos.org/nixos/about.html">接下来建议阅读 NixOS 官方的介绍</a>。有一个不太恰当的比喻，NixOS 相对于其它发行版有点像使用 Git + Markdown + Hexo 相对于无版本管理 + 手撸 HTML 文件，<a href="https://nixos.wiki/wiki/NixOS#Comparison_with_traditional_Linux_Distributions">NixOS Wiki 也给出了 NixOS 和其它发行版的最大区别所在</a>。而这一切实现的基础是 <strong>Nix</strong>，事实上 NixOS 中所有软件包（<strong>Nixpkgs</strong>）和系统配置都由 Nix 管理。要想了解 Nix，<a href="https://www.zhihu.com/question/279855101/answer/475896416">建议阅读 dram 大佬在知乎相关问题下的回答</a>。dram 是 TUNA 镜像站镜像 NixOS / Nix / Nixpkgs 的主要推动者之一。至于 NixOS 是否适合你，<a href="https://zhuanlan.zhihu.com/p/50623869">可以阅读这篇文章自行判断</a>。</p><h2>准备工作</h2><p>准备好安装 NixOS 了？让我们开始吧。前期的准备工作包括：数据备份、下载镜像、将镜像写入 U 盘、引导安装介质、连接到网络、建立分区、格式化分区、挂载分区，<strong>这一部分和其它（不带 GUI 安装程序的）Linux 发行版的安装几乎是一样的</strong>，这里不会细讲。</p><p>2020 年 3 月后清华镜像站就有 Nix / NixOS / Nixpkgs 的镜像了，<a href="https://mirrors.tuna.tsinghua.edu.cn/nixos-images/">NixOS 的安装介质可在这里下载</a>，建议选带桌面环境的镜像（可以通过文件名判断）。将写入 U 盘可以使用 <code>dd</code> 命令，具体用法（<code>path-to-image</code> 是 NixOS 安装介质的路径，<code>/dev/sdX</code> 则是写入目标）：</p><pre><code>sudo dd if=path-to-image of=/dev/sdX
</code></pre><p>引导安装介质后，按照 <code>/etc/issue</code> 的提示操作即可进入桌面环境（启动登录管理器），注意默认搭载的账户 <code>nixos</code> 和 <code>root</code> 都没有密码：</p><pre><code>sudo systemctl start display-manager
</code></pre><p>因为在线安装，联网是必须的。通常情况使用 NetworkManager 联网即可，<a href="https://nixos.org/nixos/manual/index.html#sec-installation-booting-networking">当然这里还有其它的联网方式</a>。</p><p>可选的分区工具除了熟悉的 GDisk 和 GNU Parted 这些 CLI 的分区工具之外，还有 GUI 的分区工具 GParted。<a href="https://nixos.org/nixos/manual/index.html#sec-installation-partitioning">NixOS Manual 对在命令行下分区做了详细的介绍</a>，<a href="https://nixos.org/nixos/manual/index.html#sec-installation-summary">还配有不少的例子</a>，<a href="https://wiki.archlinux.org/index.php/Partitioning">可以配合 ArchWiki 的相关文章进行阅读</a>。因为 Nix 并不会自动删除历史的软件包安装，<strong>根目录尽可能分大一些</strong>，否则随着时间推移 <code>/nix</code> 可能会占用较大空间。<strong>除了 Home 和 EFI 分区之外不建议（也没必要）设置独立分区</strong>。<strong>另外 NixOS 的回滚功能是由 Nix 实现的，和 Btrfs 无关</strong>，如果你选择 Btrfs 仅仅是因为它的快照特性，那么没有必要给根分区使用 Btrfs。</p><p>格式化分区之后就可以挂载分区了。分区应该挂载到 <code>/mnt</code> 下，例如根分区就挂载到 <code>/mnt</code>，Home 分区则 <code>/mnt/home</code>。<strong>特别留意 NixOS 下 EFI 分区应该挂载到 <code>/mnt/boot</code>。</strong>Swap 分区使用 <code>swapon</code> 启用即可。</p><h3>初始化 NixOS 配置文件</h3><p>接下来就是后期的准备工作了。事实上，如果你点开了前面的几个链接，你会发现 <code>/etc/nixos/configuration.nix</code> 是整个系统的灵魂所在。你的系统<strong>全局搭载</strong>的软件包和系统配置都取决于这个文件。<a href="https://linux.cn/article-8976-1.html">因此我们说这个发行版是「先配置后安装」的</a>。</p><p><strong>所以接下来的主要任务，就是配置 <code>configuration.nix</code>，这个文件会一直伴随着你的系统。</strong>一旦配置完成，你会使用到 <code>nixos-install</code> 脚本，这个脚本会读取这个文件，并调用 Nix 让其根据这个文件「造出对应的系统来」。而在安装好 NixOS 之后，你可以随时改动 <code>configuration.nix</code> 这个文件，然后使用 <code>nixos-rebuild</code> 脚本，这个脚本同样也是调用 Nix，让 Nix <strong>处理所有的变化</strong>，以「造出对应的系统来」。「造出来的系统」会<strong>和当前系统的状态无关</strong> 。这两个脚本笔者在后面会介绍其用法。</p><p>当然了，如果在 Live 环境里面直接编辑 <code>/etc/nixos/configuration.nix</code>，打开的是 Live 环境的配置文件。而现在我们需要为新的系统创建一个默认的 NixOS 的配置文件，在进入新系统之前，应该通过 <code>/mnt</code> 访问其文件<strong>（本文后续的命令，除非特别注明，否则一律需要在 <code>root</code> 账户下执行，可以使用 <code>su</code> 命令从普通用户切换到 <code>root</code> 账户）</strong>：</p><pre><code>nixos-generate-config --root /mnt
</code></pre><p>运行这个命令之后，<code>/mnt/etc/nixos/</code> 目录会被创建，里面会放置自动生成的两个文件：<code>configuration.nix</code> 和 <code>hardware-configuration.nix</code> 。我们待会再看 <code>hardware-configuration.nix</code>，先看看前面已经提到无数次的 <code>configuration.nix</code>，<a href="https://paste.ubuntu.com/p/JHsyTczk3m/">这个文件在 NixOS 20.03 下默认长这样</a>。当然了，在你安装系统之后，可以使用 <code>nixos-generate-config --force</code> 重新生成一个 <code>configuration.nix</code>。</p><h3>初识 <strong>NixOS 模块</strong></h3><p>让我们来打开 <code>configuration.nix</code> 这个文件：</p><pre><code>nano /mnt/etc/nixos/configuration.nix
</code></pre><p>以 <code>#</code> 开头的都是注释，我们先不要管注释，看看没有注释的内容。实际上，这是一个简化的 <strong>NixOS 模块</strong>（NixOS Module）。我们尝试分析一下它的结构：</p><pre><code>{ config, pkgs, ... }:

{
    imports = [
        ./hardware-configuration.nix
    ];
    boot.loader.systemd-boot.enable = true;
    boot.loader.efi.canTouchEfiVariables = true;
    networking.useDHCP = false;
    networking.interfaces.docker0.useDHCP = true;
    networking.interfaces.wlo1.useDHCP = true;
    system.stateVersion = &quot;20.03&quot;;
}
</code></pre><p>第一行的 <code>{ config, pkgs, ... }:</code> 表示这是一个至少接受两个参数 <code>config</code> 和 <code>pkgs</code> 的函数。<code>config</code> 主要用于在多个 NixOS 模块的情形下<strong>引用</strong>其它模块定义的配置值，<a href="https://nixos.org/nixos/manual/index.html#sec-modularity">这里有相关的例子</a>，可以说是引入了完整的系统配置。<code>pkgs</code> 主要用于引用 Nixpkgs 中的软件包，例如 <code>pkgs.fcitx</code>。<strong>当然我们现在简单地认为第一行就是要这样写的好了</strong>，即使在本文中不会使用到 <code>config</code>。说实话在第一次接触 C++ 时对着 <code>using namespace std;</code> 自闭了半天，其实到后面需要到名称空间的时候自然就懂了。</p><p><code>imports</code> 导入了其它的 NixOS 模块，这里它导入了 <code>./hardware-configuration.nix</code>。另外 <code>modules/module-list.nix</code> 里面定义了一系列的模块，<strong>这些模块会被自动导入</strong>。<code>modules/module-list.nix</code> 的绝对路径是啥呢，可以看回 <a href="https://nixos.org/nixos/about.html">NixOS 官方的介绍</a>，阅读 <code>How does NixOS work?</code>，你会发现 <code>/nix/store/</code> 下的目录都带上了 Hash 值，这是为了避免新的安装覆盖旧的安装（便于需要的时候回滚啊！事实上这也是开始时我说根目录尽可能分大一些的原因，后面会提供旧安装清理的方法）。所以要想找到这个 <code>modules/module-list.nix</code>，不妨用点小技巧：</p><pre><code>find / | grep &quot;modules/module-list.nix&quot;
</code></pre><p><code>cat</code> 查看相应的文件就可以看到这个列表了，事实上还真导入了不少的 NixOS 模块。当然我们现在先打开 <code>hardware-configuration.nix</code> 看看（要注意上面的 <code>./hardware-configuration.nix</code> 是相对于 <code>/mnt/etc/nixos/configuration.nix</code> 的路径）：</p><pre><code>cat /mnt/etc/nixos/hardware-configuration.nix
</code></pre><p>你会发现上面记录了你的分区信息，<strong>如果不是那就是你分区过程中出了差错</strong>，可以调整分区后按照上面的步骤重新 <code>nixos-generate-config</code>。这个文件将用于生成 Fstab 等文件。这个文件被单独分出来原因也是为了避免错误地编辑了这个文件。<strong>事实上 NixOS 官方只建议使用 <code>nixos-generate-config</code> 更新这个文件。</strong></p><p>接下来我们来看 <code>configuration.nix</code> 剩余的部分。这些行的格式都是 <code>name = value</code>，我们称这是定义（<strong><em>define</em></strong>）操作。我们称 <code>configuration.nix</code> 为简化的 NixOS 模块，<strong>原因是它只有定义操作</strong>。事实上还有声明（<strong><em>declare</em></strong>）操作，这一个一个的 <code>name</code> 其实在其它文件声明过，这样才可以被定义。笔者接下来会详细介绍定义操作和声明操作，如果想要深入了解 NixOS 模块，<a href="https://nixos.org/nixos/manual/index.html#sec-writing-modules">可以查看这里</a>。</p><h3>定义操作</h3><p>我们来继续来研究上面 <code>configuration.nix</code> 涉及到的 Nix 表达式：</p><pre><code>boot.loader.systemd-boot.enable = true;
boot.loader.efi.canTouchEfiVariables = true;
</code></pre><p>我们已经知道它们格式都是 <code>name = value</code>，进一步分析它的结构，这两个表达式中我们把 <code>boot</code>、<code>loader</code>、<code>systemd-boot</code> 还有 <code>efi</code> 称之为集合（_<strong>set</strong>_），把 <code>enable</code> 和 <code>canTouchEfiVariables</code> 称为选项（_<strong>option</strong>_），把 <code>true</code> 称为值（<strong><em>value</em></strong>）。<strong>一个集合里面可能有子集合，也有可能有选项，我们给选项定义值。</strong>集合与子集合、集合与选项之间可以像上面一样，使用 <code>.</code> 连接。同时也可以使用下面的使用花括号嵌套的方式（<strong>注意分号出现的位置</strong>）：</p><pre><code>boot = {
    loader = {
        systemd-boot = {
            enable = true;
        };
        efi = {
            canTouchEfiVariables = true;
        };
    };
};
</code></pre><p>当然了可以两种方式混合使用：</p><pre><code>boot = {
    loader.systemd-boot = {
        enable = true;
    };
    loader = {
        efi.canTouchEfiVariables = true;
    };
};
</code></pre><p>如果是还有疑问的，<a href="https://nixos.org/nixos/manual/index.html#sec-configuration-syntax">NixOS Manual 给出了更多的相关例子</a>。至于是使用花括号还是半角句号，我认为不重要。但在我看来，<strong>如果有两个选项它们属于同一个集合，它们应该尽量在一起被定义</strong>，而不是一个在文件开头定义，一个在文件末尾定义。<strong>同一集合的两个选项会有一定的关联性，放在一起可以更好地维护。</strong></p><p>当然了，当配置文件足够复杂之后，还可以像 <code>hardware-configuration.nix</code> 一样将一部分拆分出来，在 <code>imports</code> 部分导入相关文件，这里就不细讲了。</p><p>至于 <code>value</code>，上面的给出的 <code>configuration.nix</code> 中涉及到的值有 <code>true</code>、<code>false</code>、<code>&quot;20.03&quot;</code>。和其它编程语言的数据类型类似，我们称 <code>true</code> 和 <code>false</code> 是<strong>布尔值</strong>，称 <code>”20.03&quot;</code> 是<strong>字符串</strong>（注意两个引号），每一个 <code>name</code> 都有对应的可接受的类型。是事实上，对于其它的选项，可以接受的值的类型也有可能是列表、浮点数、软件包等等。<a href="https://nixos.org/nixos/manual/index.html#sec-configuration-file">这里详细地介绍了 <code>value</code> 的各种类型</a>，并给出了相关的例子。</p><p>这里问题就来了，怎样知道在一个 NixOS 系统中我有哪些 <code>name</code> 可以用呢？这些 <code>name</code> 又接受那些 <code>value</code> 呢？让我们继续来了解「声明操作」。</p><h3>声明操作</h3><p>和其它编程语言类似，<strong>声明就是要告诉人家我叫啥、我接受什么样的 <code>value</code>。</strong>怎样查看一个 <code>name</code> 的声明呢？第一个方法是<strong>使用命令 <code>nixos-option</code></strong>，例如我要查看 <code>system.stateVersion</code> 的声明：</p><pre><code>nixos-option system.stateVersion
</code></pre><p>这个是在我系统上的输出，当然了在 Live 环境下输出不一定相同：</p><pre><code>Value:
&quot;20.03&quot;

Default:
&quot;20.03&quot;

Type:
&quot;string&quot;

Description:
''
    Every once in a while, a new NixOS release may change
    configuration defaults in a way incompatible with stateful
    data...（后面的省略）
''

Declared by:
[ &quot;/nix/var/nix/profiles/per-user/root/channels/nixos/nixos/modules/misc/version.nix&quot; ]

Defined by:
[ &quot;/etc/nixos/configuration.nix&quot; ]

</code></pre><p>我们会看到 <code>system.stateVersion</code> 在 <code>/nix/var/nix/profiles/per-user/root/channels/nixos/nixos/modules/misc/version.nix</code> 声明过，而笔者刚开始的时候说过 <code>configuration.nix</code> 会自动导入 <code>modules/module-list.nix</code> 里包含的所有文件，里面就有 <code>version.nix</code>，因此我们才可以在 <code>/etc/nixos/configuration.nix</code> 定义它。另外我们也能得到其它有用的信息，例如它接受一个字符串作为它的值，<code>system.stateVersion</code> 默认定义的值是 <code>&quot;20.03&quot;</code>，事实上这些信息就是在声明它的时候提供的。</p><p>我们打开这个 <code>version.nix</code>，这就是一个声明的真面目了：</p><pre><code>options.system = {
    stateVersion = mkOption {
        type = types.str;
        default = cfg.release;
        description = ''
            Every once in a while, a new NixOS release may change
            configuration defaults in a way incompatible with stateful
            data...（后面的省略）
        '';
    };
};
</code></pre><p>当然笔者在本文中并不会要求用户创建一个声明。但我们还是会继续探究这个文件，我们发现 <code>version.nix</code> 给多个选项提供了声明，例如 <code>system.nixos.release</code>、<code>system.nixos.codeName</code> 等等。</p><p>我们接着再往下翻一点：</p><pre><code>config = {
    system.nixos = {
        version = mkDefault (cfg.release + cfg.versionSuffix);
    };

    # Generate /etc/os-release.
    environment.etc.os-release.text = ''
        NAME=NixOS
        ID=nixos
        VERSION=&quot;${cfg.version} (${cfg.codeName})&quot;
        VERSION_CODENAME=${toLower cfg.codeName}
        VERSION_ID=&quot;${cfg.version}&quot;
        PRETTY_NAME=&quot;NixOS ${cfg.release} (${cfg.codeName})&quot;
        LOGO=&quot;nix-snowflake&quot;
        HOME_URL=&quot;https://nixos.org/&quot;
        DOCUMENTATION_URL=&quot;https://nixos.org/nixos/manual/index.html&quot;
        SUPPORT_URL=&quot;https://nixos.org/nixos/support.html&quot;
        BUG_REPORT_URL=&quot;https://github.com/NixOS/nixpkgs/issues&quot;
    '';
};
</code></pre><p>你会在里面找到 <code>${cfg.version}</code> 和 <code>${cfg.codeName}</code>。<code>cfg</code> 是什么呢，我们回到文件开头：</p><pre><code>{ config, lib, pkgs, ... }:

with lib;

let
    cfg = config.system.nixos;
in
{
    ...
}
</code></pre><p>还记得 <code>config</code> 是啥吗？我们说它引入了完整的系统配置。现在，即使我没有告诉你 <code>environment.etc.os-release.text</code> 是个啥，相信你也能猜出来，Nix 使用了 <code>system.nixos.release</code>、<code>system.nixos.codeName</code> 创建了 <code>/etc/os-release</code> 这个文件。至于前面提到的 <code>system.stateVersion</code> 呢，则被用于其它的地方了（毕竟有了 <code>config</code>，我们在任何地方都可以引用它）。<strong>事实上，就是这样声明和定义一个又一个的选项，组成了最终的系统。</strong></p><p>关于怎样查看一个 <code>name</code> 的声明，<a href="https://nixos.org/nixos/options.html#">第二个方法是<strong>使用 NixOS Options 网页</strong></a>。输入 <code>name</code> 同样可以查看到使用 <code>nixos-options</code> 能看到的内容。<strong>关键是它还非常适合给我们模糊搜素用。</strong>另外点击 <code>Declared in</code> 旁边的超链接，会跳转到 GitHub 的 NixOS/nixpkgs 仓库。例如说我们查找 <code>system.stateVersion</code>，<a href="https://github.com/NixOS/nixpkgs/blob/master/nixos/modules/misc/version.nix">我们会被带到这里</a>。同样也可以查看 <code>version.nix</code> 文件，还可以切换 Git 分支查看不同 NixOS 版本下这个文件的历史状态。我们在后面会经常使用到 NixOS Options 网页和 <code>nixos-option</code> 命令。</p><h2>开始编辑 <code>configuration.nix</code></h2><p>讲了这么多，让我们尝试把刚刚学到的东西应用到实际当中吧！接下来我们要写很多很多的 <code>name = value</code> 表达式。我们已经知道，当我们有一个需求，我们可以尝试去 NixOS Options 进行模糊搜索，看看有没有对应的选项。此外，我们多次提到的 NixOS Manual 提供了很多的常见需求对应的解决方案。这里还会另外推荐一些寻找解决方案的地方：</p><ul><li><a href="https://nixos.org/nixos/manual">NixOS Manual</a> - NixOS 官方文档值得阅读值得信赖。</li><li><a href="https://nixos.org/nixos/options.html">NixOS Options</a> - 列出了所有可用的选项、其声明、可以接受的值。</li><li><a href="https://discourse.nixos.org/">NixOS Discourse Forum</a> - 用户论坛，有官方开发者答疑。</li><li><a href="https://nixos.org/nixos/packages.html">NixOS Packages</a> - 列出了所有可用的 Nixpkgs 软件包。</li><li><a href="https://nixos.wiki/">NixOS Wiki</a> - 社区维护的维基。</li><li><a href="https://github.com/">GitHub</a> - 查看其它用户的配置，或查看官方的 NixOS/nixpkgs 仓库。</li><li><a href="https://stackoverflow.com/questions/tagged/nixos">Stack Overflow</a> - 查看打有 <code>nixos</code> 标签的问题和回答。</li><li>各大搜索引擎 - 这个也不用我多说吧……</li></ul><p>当然了，如果实在找不到，可以去 <a href="https://discourse.nixos.org/">NixOS Discourse Forum</a> 提问，因为官方开发者在这个论坛非常活跃，很多问题都能在短时间内得到答案。</p><p>要注意的是，因为 <code>configuration.nix</code> 会一直伴随着你的 NixOS 安装，所以这个章节既适用于安装时进行初始化配置，也适用于安装后的日常维护进行配置。下面结合两个自认为比较实际的需求来展开介绍，我会着重说明我是<strong>如何找到</strong>解决方案的，希望能给到大家一些帮助。</p><h3>桌面环境</h3><p>会发现 NixOS Manual 有多个对应的章节，<a href="https://nixos.org/nixos/manual/index.html#sec-x11">有讲 X11 的</a>，<a href="https://nixos.org/nixos/manual/index.html#chap-pantheon">有专门讲 Pantheon 桌面环境的</a>，<a href="https://nixos.org/nixos/manual/index.html#sec-xfce">有专门讲 XFCE 桌面环境的</a>。个人非常喜欢 Pantheon，我们也知道 X11 是一切桌面环境的基础（假设我们把 Wayland 忽略掉）。我们来看看 X11。首先看到的是这样一句：</p><p>The X Window System (X11) provides the basis of NixOS’ graphical user interface. It can be enabled as follows:</p><pre><code>services.xserver.enable = true;
</code></pre><p>看上去是不是很熟悉？事实上默认的 <code>configuration.nix</code> 里面已经有了这样的一行，只是被注释掉了。上面还配有注释 <code>Enable the X11 windowing system.</code> 让我们取消注释 <code>services.xserver.enable = true;</code>。</p><p>搞定！就这么简单。先继续看看 Pantheon 桌面对应的章节。根据 NixOS Manual，要想使用 Pantheon 桌面，需要在 <code>configuration.nix</code> 加入：</p><pre><code>services.xserver.desktopManager.pantheon.enable = true;
</code></pre><p>这也很简单，复制粘贴过去就完成了，搞定！在 <code>configuration.nix</code> 加入这个 Nix 是怎样处理的呢？还记得前面提到的 <code>system.nixos.release</code>、<code>system.nixos.codeName</code>和 <code>/etc/os-release</code> 吗？可以按照当时我所给的思路一探究竟，我们在后面揭晓。</p><h3>软件包</h3><p><a href="https://nixos.org/nixos/manual/index.html#sec-declarative-package-mgmt">会发现 NixOS Manual 有对应的章节</a>。它的要求是定义 <code>environment.systemPackages</code> 这个选项。它给出的例子是这样的：</p><pre><code>environment.systemPackages = [ pkgs.thunderbird ];
</code></pre><p>感觉有点迷？那不妨前往 <a href="https://nixos.org/nixos/options.html#environment.systempackages">NixOS Options</a> 查找 <code>environment.systemPackages</code>，这时就应该知道它要求你提供 <code>list of packages</code>。我们回到 <a href="https://nixos.org/nixos/manual/index.html#sec-configuration-file">NixOS Manual</a>，查看 Package 小节。这时就可以大致推断出这个 <code>name</code> 怎么填了。</p><p><a href="https://github.com/search?l=Nix&q=environment.systemPackages&type=Code">接下来我们去 GitHub 参考一下别人的配置文件</a>，注意语言要选择 Nix，关键字将 Option 填入即可。查看搜索结果的时候只看定义操作相关的代码（而不是声明操作），这时你会发现另一个用法：</p><pre><code>environment.systemPackages = with pkgs; [
    vscode
    freemind
];
</code></pre><p>事实上这样写，在后面就不用每个软件包前面加上 <code>pkgs.</code> 了，<code>pkgs.vscode</code> 可以直接写成 <code>vscode</code>。</p><p>胜利在望！接下来去 <a href="https://nixos.org/nixos/packages.html">NixOS Packages</a>，查找自己需要的软件包填入。你会发现有 Package name 和 Attribute name，填哪个呢？不妨回到 GitHub 继续翻配置文件，当你发现所有配置填的都是 Attribute name，我们就可以开始了，下面的就是我的配置：</p><pre><code>environment.systemPackages = with pkgs; 
[
    dos2unix chromium fcitx fcitx-configtool firefox gcc git gptfdisk libreoffice-fresh neofetch pciutils python transmission vim wget vscode-with-extensions
];
</code></pre><p>你会发现这里面没有 X11 和 Pantheon 相关的包，<strong>事实上， <code>services.xserver.desktopManager.pantheon.enable = true;</code> 这一行已经为你安装了相应的包。</strong><a href="https://github.com/NixOS/nixpkgs/blob/master/nixos/modules/services/x11/desktop-managers/pantheon.nix">可以查看一下包含这个选项声明的文件</a>，我们定位到 <code>config =</code> 往下的内容。虽然有些选项我们没有讨论过，例如 <code>fonts.fontconfig.defaultFonts</code> 等等，但是你可以通过搜索 NixOS Options 或者直接按照它的字面意思知道这些选项是干什么的。有安装软件包的、设置系统服务的、设置字体的等等。</p><p>有了这么一行，我们也就没有必要在我们自己的 <code>configuration.nix</code> 中设置它了。所以说 NixOS Options 的优先级是会高于 NixOS Packages 的，笔者才会用很大的篇幅介绍前者。<strong>当你需要一个软件或功能，首先考虑的应该是有没有对应的 NixOS Option，而不是直接安装一个 Nixpkg。</strong></p><ul><li><ul><li>*</li></ul></li></ul><p>下面是另外两个比较玄学的案例，都是我安装完成之后才开始折腾的问题，<strong>当然了安装的时候也没有必要纠结这些问题</strong>，因为安装完后还可以随时编辑 <code>configuration.nix</code>，后面还会再介绍。同样，我会着重说明我是<strong>如何找到</strong>解决方案的，希望能给到大家一些帮助。<strong>介绍这些案例，不是为了劝退，而是为了说明，只要合理利用我在本章介绍的各类资源，善用搜索，必要时勇敢提问、开 Issue，甚至发 PR</strong>（<a href="https://discourse.nixos.org/t/language-packs-for-libreoffice-and-firefox/698/">这里有笔者本人的例子</a>）<strong>，大部分的问题都能很快地得到解决。</strong></p><h3>禁用 N 卡</h3><p>单纯出于想要省电的原因，打算禁用 N 卡。网上给出的禁用 N 卡的方案是都是使用 BBSwitch，四处搜索之。最后在 <a href="https://discourse.nixos.org/t/external-monitors-not-working-dell-xps/1799">Discourse Forum</a> 里面找到了一个有一定关联的。提到的选项包括 <code>extraModprobeConfig</code>、<code>blacklistedKernelModules</code>、<code>extraModulePackages</code>。</p><p>我们知道在其它发行版下要使用 BBSwitch 禁用 N 卡是这样操作的：</p><pre><code>options bbswitch load_state=0 unload_state=1
</code></pre><p>和帖子中 <code>extraModprobeConfig</code> 的值高度类似。而 <code>extraModulePackages</code> 在帖子里的值是 <code>config.boot.kernelPackages.nvidia_x11</code>，我们搜索到 BBSwitch 的 Attribute name 是 <code>linuxPackages.bbswitch</code>，相信也有一定关联。</p><p>接下来我们去 NixOS Options 继续搜索，发现上面几个选项都在 <code>boot</code> 集合下，查找 <code>boot module</code> 关键词，又发现了一个 <code>boot.kernelModules</code>，我认为这个选项和我的需求也是高度关联的。于是我写下了以下的配置：</p><pre><code>boot = {
    extraModprobeConfig = ''
        options bbswitch load_state=0 unload_state=1
    '';
    extraModulePackages = [ pkgs.linuxPackages.bbswitch ];
    kernelModules = [ &quot;bbswitch&quot; ];
    blacklistedKernelModules = [
        &quot;nouveau&quot;
        &quot;rivafb&quot;
        &quot;nvidiafb&quot;
        &quot;rivatv&quot;
        &quot;nv&quot;
        &quot;uvcvideo&quot;
    ];
};
</code></pre><p>确实是可行的，因为我后面运行 <code>lspci</code> 的时候显示已经是 <code>rev ff</code> 了：</p><pre><code>01:00.0 3D controller: NVIDIA Corporation GP107M [GeForce GTX 1050 3 GB Max-Q] (rev ff)
</code></pre><h3>Visual Studio Code 插件</h3><p>你可能会问这也要提及？情况是这样的，安装了 VS Code（<code>pkgs.vscode-with-extensions</code>）之后我安装了几个插件，发现 C++ 插件不工作。我对这个插件提供的补全功能有较大的依赖，第一时间我想到的是这是 NixOS 目录结构和其它发行版不一致的问题。于是去搜索 Discourse Forum，<a href="https://discourse.nixos.org/t/vscode-extensions-setup/1801">找到了这个帖子</a>。下面有官方开发者给出了一个 Dirty Hack，尝试之。</p><p>结果发现 <code>fetchTarball https://github.com/nixos/nixpkgs-channels/archive/nixpkgs-unstable.tar.gz</code> 会消耗不少时间。一个解决方案是将整个 GitHub 仓库同步到其它 Git 托管平台，但我们还是希望有更高效的解决方案。留意到了楼主的解决方案，虽然它会覆盖原有的自己在 Marketplace 安装的 VS Code 插件，但是按照楼主的描述它确实是可行的：</p><pre><code>self: super:
{
    mycode = super.vscode-with-extensions.override {
        # When the extension is already available in the default extensions set.
        vscodeExtensions = with super.vscode-extensions; [
            ms-vscode.cpptools
        ];
    };
}
</code></pre><p>但是你并不知道第一行是啥，也不知道如何添加这个方案，<a href="https://github.com/search?l=Nix&q=vscode-with-extensions.override&type=Code">于是去 GitHub 搜索相关的内容</a>。结果搜出来的结果比上面这个还要再复杂一点，而且这样写的不只一个：</p><pre><code>self: super: {
    vscode-with-extensions = super.vscode-with-extensions.override {
        vscodeExtensions = with super.vscode-extensions;
        [ 
            bbenoist.Nix
            ms-vscode.cpptools
        ]
        ++ super.vscode-utils.extensionsFromVscodeMarketplace [ {
                name = &quot;vim&quot;;
                publisher = &quot;vscodevim&quot;;
                version = &quot;1.0.8&quot;;
                sha256 = &quot;0yqfn8b2jfrijzf731sggyvik2immlx9hfgmsgp1mx01hpyisd9r&quot;;
            } {
                name = &quot;doxdocgen&quot;;
                publisher = &quot;cschlosser&quot;;
                version = &quot;0.4.1&quot;;
                sha256 = &quot;06f4nxjd5ph66bhlyjim87haams286sjhrw7vmiv2rckzinygh1h&quot;;
            } {
                ...
            }
        ];
    };
}
</code></pre><p>这时可以猜出来官方应该有相应的文档，于是就去搜索 NixOS Manual、NixOS Options 还有 NixOS Packages，发现都找不到。终于，<a href="https://github.com/NixOS/nixpkgs">笔者开始查找 GitHub 的 NixOS/nixpkgs 仓库</a>。<a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/applications/editors/vscode/with-extensions.nix">找到了这样一个文件</a>。你会发现第一行没了，后面的内容还是类似的。现在我们可以把关注点放在这个 <code>override</code> 上了。我们重新发起一次搜索，<a href="https://nixos.org/nixos/manual/#sec-customising-packages">在 NixOS Manual 找到了有关 <code>override</code> 的说明</a>。</p><p>太妙了！但是接下来又有一个问题，这里的 <code>name</code>、<code>publisher</code>、<code>version</code> 和 <code>sha256</code> 又该怎么填呢？为什么 <code>ms-vscode.cpptools</code> 不需要填 <code>version</code> 和 <code>sha256</code> 呢？阅读还是刚才的文件，阅读上面的注释：</p><p>This expression should fetch:</p><ul><li>the <code>nix</code> vscode extension from whatever source defined in the default nixpkgs extensions set <code>vscodeExtensions</code>.</li><li>the <code>code-runner</code> vscode extension from the marketplace using the following url: <a href="https://bbenoist.gallery.vsassets.io/_apis/public/gallery/publisher/bbenoist/extension/nix/1.0.1/assetbyname/Microsoft.VisualStudio.Services.VSIXPackage">(link)</a>.</li></ul><p>The original <code>code</code> executable will be wrapped so that it uses the set of pre-installed / unpacked extensions as its <code>--extensions-dir</code>.</p><p>然而我们却找不到 <code>vscodeExtensions</code>，但是我们可以搜索 <code>ms-vscode.cpptools</code> 啊！<a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/misc/vscode-extensions/default.nix">终于笔者找到了这个文件</a>。事实上在这个文件中涉及到的所有插件都无需我们再配置 <code>publisher</code>、<code>version</code> 和 <code>sha256</code> 了。<strong>这和我们使用了 <code>services.xserver.desktopManager.pantheon.enable = true;</code> 就不需要在 <code>environment.systemPackages</code> 添加相关的包是一个道理。</strong></p><p>至于这个文件里没有的插件呢？例如说 <code>ms-vscode.cpptools</code> 的 <code>name</code> 就是 <code>cpptools</code>，<code>publisher</code> 就是 <code>ms-vscode</code>。我们可以去 <a href="https://marketplace.visualstudio.com/vscode">Marketplace</a> 下载这个插件（找到 Download Extension 按钮即可），用 <code>sha256sum</code> 命令计算下载下来的文件的 <code>sha256</code>，而版本号在文件名有。好了，你已经准备好了！让我们来继续完善 <code>environment.systemPackages</code>：</p><pre><code>environment.systemPackages = with pkgs; 
[
    dos2unix chromium fcitx fcitx-configtool firefox gcc git gptfdisk libreoffice-fresh neofetch pciutils python transmission vim wget
    ( vscode-with-extensions.override {
        vscodeExtensions = with vscode-extensions; [
            bbenoist.Nix
            ms-vscode.cpptools
            ms-azuretools.vscode-docker
        ]
        ++ vscode-utils.extensionsFromVscodeMarketplace [ {
                name = &quot;bracket-pair-colorizer-2&quot;;
                publisher = &quot;CoenraadS&quot;;
                version = &quot;0.0.29&quot;;
                sha256 = &quot;cadb50a21944e6e0293e3872d2fe23b5d2fd2b603ed2bf4a0675fd29bcfb130c&quot;;
            } {
                name = &quot;python&quot;;
                publisher = &quot;ms-python&quot;;
                version = &quot;2020.3.71113&quot;;
                sha256 = &quot;1d8a98a1eed7588dd3b57e4bbe518fcc88f883e066f1b3342453e9bc1a283fdb&quot;;
            } {
                name = &quot;php-intellisense&quot;;
                publisher = &quot;felixfbecker&quot;;
                version = &quot;2.3.14&quot;;
                sha256 = &quot;3798a5de1172b5803877357d0057e3e129d8d82b8fbe0b53ae28c777a0075ca6&quot;;
            } {
                name = &quot;vscode-language-pack-zh-hans&quot;;
                publisher = &quot;MS-CEINTL&quot;;
                version = &quot;1.44.2&quot;;
                sha256 = &quot;4f6ee18ada0e71dd1545ef49f8810f52fe872d2074612faa908d8bf2687400a0&quot;;
            }
        ];
    } )
];
</code></pre><ul><li><ul><li>*</li></ul></li></ul><p>相信对于其它的需求大家也能举一反三。<a href="https://github.com/bobby285271/nixos-configuration/blob/master/configuration.nix">这里是我的 <code>configuration.nix</code></a>，供大家参考。</p><h2>执行安装</h2><p>前面已经提及过 <code>nixos-install</code> 这个命令了，让我们使用它执行安装，不需要带上任何参数：</p><pre><code>nixos-install
</code></pre><p>如果 <code>configuration.nix</code> 存在任何错误，安装会在一开始的时候就中断，修改好后重新运行上面的命令即可。<strong>网络出现问题同理。</strong>接下来安装程序会提示你设置一个密码，这个密码是给管理员用的（<strong>密码当然是不能在 <code>configuration.nix</code> 上设置的</strong>），盲打两次即可。重启并进入新系统：</p><pre><code>reboot
</code></pre><p>当然，重启后别忘了为你的普通用户设置密码（如 <code>passwd bobby285271</code>）。</p><h2>系统维护</h2><p>笔者之前讲过 <code>configuration.nix</code> 是可以随时修改的。当然了现在你应该处于你的新系统中了，所以你不应该编辑 <code>/mnt/etc/nixos/configuration.nix</code> 了，而是应该编辑 <code>/etc/nixos/configuration.nix</code>。</p><pre><code>nano /etc/nixos/configuration.nix
</code></pre><p>要使这个配置生效，应该使用 <code>nixos-rebuild switch</code> 命令，如果你希望在构建这个配置的时候顺便升级自己的系统（当然如果你不改动 <code>configuration.nix</code> 单纯想升级系统，同样可以执行这个命令） ：</p><pre><code>nixos-rebuild switch --upgrade
</code></pre><p>关于这个，<a href="https://nixos.org/nixos/manual/index.html#sec-changing-config">可以查看 NixOS Manual 了解详情</a>。</p>
]]></content>
<link rel="replies" type="text/html" href="https://static.bobby285271.top/index.php/2020/04/15/NixOS-Installation-and-Configuration-Guide.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://static.bobby285271.top/index.php/feed/atom/2020/04/15/NixOS-Installation-and-Configuration-Guide.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[How to Port Calamares to Arch Linux (en)]]></title>
<link rel="alternate" type="text/html" href="https://static.bobby285271.top/index.php/2020/02/18/How-to-Port-Calamares-to-Arch-Linux-en.html" />
<id>https://static.bobby285271.top/index.php/2020/02/18/How-to-Port-Calamares-to-Arch-Linux-en.html</id>
<updated>2020-02-17T16:00:00+00:00</updated>
<published>2020-02-17T16:00:00+00:00</published>
<author>
    <name>bobby285271</name>
    <uri>https://static.bobby285271.top</uri>
</author>
<summary type="html"><![CDATA[This article is for reference ONLY.Calamares is a distribution-independent installer framework. A...]]></summary>
<content type="html" xml:base="https://static.bobby285271.top/index.php/2020/02/18/How-to-Port-Calamares-to-Arch-Linux-en.html" xml:lang="zh-CN"><![CDATA[
<blockquote>This article is for reference ONLY.</blockquote><p>Calamares is a distribution-independent installer framework. As distributions like Arch Linux don't provide graphical installer, we can try to adapt Calamares to them. To make things easier, we simply start by trying to provide a <code>pacstrap</code> part for Calamares, which allow users to install a minimal Arch Linux system, then we add the Calamares installer to our Archiso.</p><h2>Getting Started</h2><p>Make sure that you have Git installed, fetch the source code by cloning the Calamares repository, to speed up, add <code>--depth=1</code> option:</p><pre><code>git clone https://github.com/calamares/calamares.git --depth=1
</code></pre><p>Entering the repository, you will find lots of files and directories, don't panic! All you have to focus on are three files/directories: <code>settings.conf</code>, <code>src/branding/</code> and <code>src/modules/</code>. Let's try to deal with them one by one.</p><h2>Step One: <code>settings.conf</code></h2><p>Firstly, you will find something like this:</p><pre><code>sequence:
- show:
  - welcome
  - locale
  - ...
- exec:
  - partition
  - mount
  - ...
- show:
  - finished
</code></pre><p>This is the installation process of Calamares, consisting of the <code>show</code> part and the <code>exec</code> part. Unlike Arch Linux's official install way where users DIY their system from the beginning to the end, users should setup their system in the <code>show</code> part and the <code>exec</code> part should handle the rest of the work then <code>show</code> again to inform user whether the installation work is succeed or not, which is considered more user-friendly. Each part (<code>show</code> and <code>exec</code>) includes several modules like <code>welcome</code>, <code>locale</code> and so on. We will talk about them later.</p><p>Now go to ArchWiki and have a look at the Installation Guide, you will find that some of the modules can be safely removed because when you perform a installation by following the ArchWiki, you never do such things like <code>plymouthcfg</code> (In fact, plymouth is not supported by Arch Linux at all). However, you will need to add some part because Calamares doesn't provide such option, such as a <code>pacstrap</code> part. Simply add the line <code>- pacstrap</code> and do rest of the thing later in step three.</p><pre><code>sequence:
- show:
  - welcome
  - locale
  - keyboard
  - partition
  - users
  - summary
- exec:
  - partition
  - mount
  - pacstrap
  - networkcfg
  - packages
  - machineid
  - fstab
  - locale
  - keyboard
  - localecfg
  - users
  - networkcfg
  - hwclock
  - bootloader
  - umount
- show:
  - finished
</code></pre><p>Let's move on. You will then see some of the boolean variables with notes above each of them. Simply set <code>true</code> or <code>false</code> according to the notes. Leave <code>branding</code> as <code>default</code>, you will configure it in step two.</p><h2>Step Two: <code>src/branding/</code></h2><p>In fact, this step is optional if you don't care about branding at all. The problem is that your users will be faced with something strange like the distro name <code>Fancy GNU/Linux 2020.2 LTS &quot;Turgid Tuba&quot;</code> and the slide show texted <code>This is a customizable QML slideshow.</code> So it is not recommend to skip this step if you want to distribute the Calamares and Archiso to others.</p><p>Navigate to the <code>src/branding/</code> directory, read the <code>README.md</code> carefully, and enter the <code>default/</code> directory. There are two files that you have to pay attention. One of them is <code>branding.desc</code>. These entries should be modified to the actual one:</p><pre><code>strings:
    productName:         &quot;@{NAME}&quot;
    shortProductName:    Arch Linux
    version:             Rolling
    shortVersion:        Rolling
    versionedName:       Arch Linux
    shortVersionedName:  Arch Linux
    bootloaderEntryName: Arch Linux
    productUrl:          https://www.archlinux.org/
    supportUrl:          https://bbs.archlinux.org/
    knownIssuesUrl:      https://bugs.archlinux.org/
    releaseNotesUrl:     https://www.archlinux.org/
</code></pre><p>Another one is <code>show.qml</code>. It is used to control slide shows. Here we only add one page, with the image <code>squid.png</code> (already included in the directory) and text <code>Arch Linux is a lightweight and flexible Linux distribution that tries to Keep It Simple.</code></p><pre><code>    Slide {

        Image {
            id: background
            source: &quot;squid.png&quot;
            width: 200; height: 200
            fillMode: Image.PreserveAspectFit
            anchors.centerIn: parent
        }
        Text {
            anchors.horizontalCenter: background.horizontalCenter
            anchors.top: background.bottom
            text: &quot;Arch Linux is a lightweight and flexible Linux distribution that tries to Keep It Simple.&quot;
            wrapMode: Text.WordWrap
            width: presentation.width
            horizontalAlignment: Text.Center
        }
    }
</code></pre><h2>Step Three: <code>src/modules/</code></h2><p>This is the most difficult part. You should do configurations for all modules listed in <code>settings.conf</code>. In most of the time, you don't have to do programming work, but simply edit the <code>*.conf</code> file. For example, if you want to edit the <code>users</code> module, open <code>src/modules/users.conf</code> and edit it. Here is a sample file:</p><pre><code>---
defaultGroups:
    - users
    - wheel

autologinGroup:  autologin
doAutologin:     true
setRootPassword: true
doReusePassword: true

passwordRequirements:
    nonempty: true
    minLength: -1
    maxLength: -1
    libpwquality:
        - minlen=0
        - minclass=0

allowWeakPasswords: false
allowWeakPasswordsDefault: false
</code></pre><p>For modules you created by yourself, like <code>pactrap</code>, you have to create a folder for it with the same name. Make sure you have already known a little bit about Python and Shell script, now start coding!</p><p>All we have to do is to call the real <code>pactrap</code> command. But it seems that if we really do that, the installation process may failed because of the behavior of Calamares. So we also have to port <code>pacstrap</code> for Calamares later. For now, we just name the script <code>pacstrap_calamares</code> and forget it. Let's create a file <code>main.py</code>.</p><pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import subprocess
import libcalamares
from pathlib import Path

root_mount_point = libcalamares.globalstorage.value(&quot;rootMountPoint&quot;)
    
def run():
    &quot;&quot;&quot;
    Installing base filesystem. Please wait! It may take some time!
    &quot;&quot;&quot;

    PACSTRAP = &quot;/usr/bin/pacstrap_calamares&quot;
    PACKAGES = &quot;base grub efibootmgr linux linux-firmware vi nano networkmanager&quot;

    subprocess.call(PACSTRAP.split(' ') + [root_mount_point] + PACKAGES.split(' '))

</code></pre><p>In fact, <code>subprocess</code> can always be used to write Shell script in Python. The only thing you have do is to save command into a string <code>foo</code>, then split it using <code>foo.split(' ')</code>, and put it into <code>subprocess.call()</code>. Here, we call <code>/usr/bin/pacstrap_calamares</code> and ask it to install some basic package <code>base grub efibootmgr linux linux-firmware vi nano networkmanager</code>. When <code>pacstrap_calamares</code> is running, Calamares will show <code>Installing base filesystem. Please wait! It may take some time!</code> on the screen.</p><h2>Step Four: Build Calamares</h2><p>We can build Calamares when we are building Archiso so the build process won't make your system dirty. Assume that you already have a Archiso profile. First, we add the needed packages to <code>packages.x86_64</code>.</p><pre><code>kf5
qt5
boost
kpmcore
yaml-cpp
polkit-qt5
</code></pre><p>Assume that you have entered the chroot environment. To build Calamares, three steps are reqired: <code>cmake</code>, <code>make</code> and <code>make install</code>. Write all the steps down, and put it into <code>airootfs/root/</code>. Here is an example file:</p><pre><code>#/bin/bash
cd /root/
mkdir ./calamares/build/
cd ./calamares/build/
cmake ..
make
make install
mkdir /etc/calamares/
cp -p /root/archlinux-calamares/settings.conf /etc/calamares/
rm -rf /root/archlinux-calamares/ /root/calamares/ /root/build_calamares.sh
pacman -Rscun qt5-doc qt5-examples --noconfirm
</code></pre><p>Now we can ask <code>airootfs/root/customize_airootfs.sh</code> to run this shell script after a chroot environment is entered. Make sure the script is executable.</p><pre><code>cd /root
./build_calamares.sh
</code></pre><p>Almost done! Don't forget to create a <code>pacstrap_calamares</code> file for Calamares. Create a <code>airootfs/usr/bin/pacstrap_calamares</code> file. You don't have to worry about how to fill the file. Someone has already done that for you! And <a href="https://raw.githubusercontent.com/endeavouros-team/install-scripts/master/pacstrap_calamares">here is the file</a>. Thanks for the work done by Endeavour OS team.</p>
]]></content>
<link rel="replies" type="text/html" href="https://static.bobby285271.top/index.php/2020/02/18/How-to-Port-Calamares-to-Arch-Linux-en.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://static.bobby285271.top/index.php/feed/atom/2020/02/18/How-to-Port-Calamares-to-Arch-Linux-en.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[2020 Nowcoder Basic Algorithm Training Camp Solutions]]></title>
<link rel="alternate" type="text/html" href="https://static.bobby285271.top/index.php/2020/02/09/2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html" />
<id>https://static.bobby285271.top/index.php/2020/02/09/2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html</id>
<updated>2020-02-08T16:00:00+00:00</updated>
<published>2020-02-08T16:00:00+00:00</published>
<author>
    <name>bobby285271</name>
    <uri>https://static.bobby285271.top</uri>
</author>
<summary type="html"><![CDATA[颓废了一个寒假，Codeforces 打来打去都是 Specialist，菜的一批。POJ 又刷到怀疑人生。后来被 Kaidora 神犇安排了这个集训营。当时已经是第四场要开始了，还是去了。果然...]]></summary>
<content type="html" xml:base="https://static.bobby285271.top/index.php/2020/02/09/2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html" xml:lang="zh-CN"><![CDATA[
<p>颓废了一个寒假，Codeforces 打来打去都是 Specialist，菜的一批。POJ 又刷到怀疑人生。后来被 Kaidora 神犇安排了这个集训营。当时已经是第四场要开始了，还是去了。果然，哪怕都是自闭五小时每小时过一题，氪了金感觉就是不一样。</p><p>点击下方的页码查看相应场次的记录，第 $i$ 页对应的是第 $i-1$ 场比赛。</p><h1>2020 牛客寒假算法基础集训营 1</h1><blockquote>字符串、贪心、矩阵快速幂、概率论、计算几何、并查集、数论</blockquote><h2>1A. Honoka 和格点三角形</h2><h3>大意</h3><p>给出 $m \times n$ 格点矩阵，问在矩阵里面能找出多少个面积为 $1$，且至少有一条边平行于 $x$ 轴或 $y$ 轴的三角形。答案对 $1000000007$ 取模。</p><h3>思路</h3><p>若存在平行于 $x$ 轴或 $y$ 轴的边且长度为 $2$，一共有 $2(n-1)(m-2)m+2(m-1)(n-2)n$ 种情况。</p><p>若存在平行于 $x$ 轴或 $y$ 轴的边且长度为 $1$，除去已经计算过的情况（即还存在平行于$x$ 轴或 $y$ 轴且长度为 $2$ 的边），一共有 $2(m-1)(m-2)(n-2)+2(n-1)(n-2)(m-2)$ 种情况。</p><p>相加后化简，得到 $2(m+n-2)(2mn-3m-3n+4)$，利用 $ab\ mod\ c = ((a\ mod\ c)(b\ mod\ c))\ mod\ c$ 计算结果。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    long long n, m, tempa, tempb;
    cin &gt;&gt; n &gt;&gt; m;
    tempa = 2 * (m + n - 2);
    tempb = (2 * m * n - 3 * m - 3 * n + 4);
    cout &lt;&lt; (tempa % 1000000007) * (tempb % 1000000007) % 1000000007 &lt;&lt; endl;
    return 0;
}
</code></pre><h2>1B. Kotori 和 Bangdream</h2><h3>大意及思路</h3><p>签到题。求数学期望，也就是可能结果的概率乘以其结果的总和。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    double n, x, a, b;
    cin &gt;&gt; n &gt;&gt; x &gt;&gt; a &gt;&gt; b;
    double ans = (a * x + b * (100 - x)) * n / 100;
    printf(&quot;%.2lf\n&quot;, ans);
    return 0;
}
</code></pre><h2>1C. Umi 和弓道</h2><h3>大意</h3><p>一个人在 $(x_0,y_0)$，给出 $n$ 个靶子，在 $x$ 轴或 $y$ 轴放置挡板，令放置挡板后可以射中的靶子数量不多于 $k$ 个。</p><h3>思路</h3><p>只要靶子和 $(x_0,y_0)$ 不在一个象限就有可能被挡掉。要想挡掉一个靶子，只需求出靶子和 $(x_0,y_0)$ 所在直线与坐标轴的交点，并保证挡板覆盖了这个点。我们只需要恰好覆盖 $n-k$ 个这样的点就行了。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const double inf = 1e18;
vector&lt;double&gt; v1, v2;
int main()
{
    v1.clear();
    v2.clear();
    double x0, y0;
    int n, k, i;
    cin &gt;&gt; x0 &gt;&gt; y0 &gt;&gt; n &gt;&gt; k;
    k = n - k;
    for (i = 0; i &lt; n; i++)
    {
        double x, y;
        cin &gt;&gt; x &gt;&gt; y;
        if (x * x0 &lt; 0)
        {
            v2.push_back(y0 - x0 * (y - y0) / (x - x0));
        }
        if (y * y0 &lt; 0)
        {
            v1.push_back(x0 - y0 * (x - x0) / (y - y0));
        }
    }
    double mi = inf;
    sort(v1.begin(), v1.end());
    sort(v2.begin(), v2.end());
    if (v1.size() &gt;= k)
    {
        double head = 0, tail = k - 1;
        while (tail &lt; v1.size())
        {
            mi = mi &gt; (v1[tail] - v1[head]) ? (v1[tail] - v1[head]) : mi;
            tail++, head++;
        }
    }
    if (v2.size() &gt;= k)
    {
        double head = 0, tail = k - 1;
        while (tail &lt; v2.size())
        {
            mi = mi &gt; (v2[tail] - v2[head]) ? (v2[tail] - v2[head]) : mi;
            tail++, head++;
        }
    }
    if (mi == 1e18)
        cout &lt;&lt; -1;
    else
        printf(&quot;%.7lf&quot;, mi);
    return 0;
}
</code></pre><h2>1D. Hanayo 和米饭</h2><h3>大意</h3><p>给出 $n-1$ 个数，求一个数使得所有的 $n$ 个数经过排序后可形成公差为 $1$ 的等差数列。保证答案存在且唯一。</p><h3>思路</h3><p>签到题。将 $n-1$ 个数排序，看相邻两数的差是否为 $2$。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int n;
    cin &gt;&gt; n;
    int a[n - 1];
    for (int i = 0; i &lt; n - 1; i++)
    {
        cin &gt;&gt; a[i];
    }
    sort(a, a + n - 1);
    for (int i = 0; i &lt; n - 2; i++)
    {
        if (a[i + 1] - a[i] != 1)
        {
            cout &lt;&lt; a[i] + 1 &lt;&lt; endl;
            break;
        }
    }
    return 0;
}
</code></pre><h2>1E. Rin 和快速迭代</h2><h3>大意</h3><p>令 $f(x)$ 为 $x$ 因子个数，将 $f$ 迭代下去，问迭代多少次能得到 $2$。</p><h3>思路</h3><p>模拟就行。求因子个数时注意处理完全平方数。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
long long sol(long long x)
{
    long long temp = 0;
    long long i;
    for (i = 1; i * i &lt;= x; i++)
    {
        if (x % i == 0)
            temp++;
    }
    temp = temp &lt;&lt; 1;
    i--;
    if (i * i == x)
        temp--;
    return temp;
}
int main()
{
    long long n;
    cin &gt;&gt; n;
    int ans = 0;
    while (1)
    {
        n = sol(n);
        ans++;
        if (n == 2)
        {
            cout &lt;&lt; ans &lt;&lt; endl;
            return 0;
        }
    }
    return 0;
}
</code></pre><h2>1F. Maki 和 Tree</h2><h3>大意</h3><p>在树（无向）中有黑白两种点。求 $n$ 个点的树中有多少简单路径有且仅有通过一个黑色点。</p><h3>思路</h3><p>先预处理各个白色连通及其大小，具体思路是读入一条边如果这条边的两端都是白色连通块就连在一起（并查集）。然后再算各个黑点的答案。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
int fa[111111];  //父亲
int kdm[111111]; //孩子数量
string color;
int f(int x)
{ //寻找祖先
    if (fa[x] == x)
        return x;
    return f(fa[x]);
}
void uni(int x, int y)
{ //连接 x 点和 y 点
    int p = f(x), q = f(y);
    if (p != q)
    {
        if (kdm[p] &gt; kdm[q])
        {
            fa[q] = p;
            kdm[p] += kdm[q] + 1;
        }
        else
        {
            fa[p] = q;
            kdm[q] += kdm[p] + 1;
        }
    }
}
ll t[111111]; //统计连通块白点数量
vector&lt;int&gt; g[111111];
ll gao(vector&lt;int&gt; temp)
{ //temp 为黑点的每个相邻白点孩子数量集合
    ll res = 0, i;
    ll n = temp.size();
    if (n == 0)
        return 0;
    ll dp[n] = {0}, sum[n] = {0}, s = 0;
    sum[0] = s = temp[0];
    for (i = 0; i &lt; n; i++)
    {
        res += temp[i];
    }
    for (i = 1; i &lt; n; i++)
    {
        sum[i] = s += temp[i];
    }
    for (i = 1; i &lt; n; i++)
    {
        dp[i] = dp[i - 1] + temp[i] * sum[i - 1];
    }
    return res + dp[n - 1];
}
int main()
{

    int n, i, j;
    cin &gt;&gt; n &gt;&gt; color;
    for (i = 1; i &lt;= n; i++)
        fa[i] = i;
    for (i = 1; i &lt; n; i++)
    {
        int x, y;
        cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y);
        g[y].push_back(x);
        if (color[x - 1] == 'W' &amp;&amp; color[y - 1] == 'W')
            uni(x, y);
    }
    ll sum = 0;
    for (i = 1; i &lt;= n; i++)
        t[i] = kdm[f(i)] + 1;
    for (i = 1; i &lt;= n; i++)
    {
        if (color[i - 1] == 'B')
        {
            vector&lt;int&gt; temp;
            for (j = 0; j &lt; g[i].size(); j++)
            {
                if (color[g[i][j] - 1] == 'W')
                    temp.push_back(t[g[i][j]]); //若相邻点是白点，加入 temp
            }
            sum += gao(temp);
        }
    }
    cout &lt;&lt; sum;
}
</code></pre><h2>1G. Eli 和字符串</h2><h3>大意</h3><p>给出一个字符串，求连续子串的最小长度，要求这个连续子串要包含至少 $k$ 个相同的某个字母。</p><h3>思路</h3><p>前缀和加尺取法。前缀和用于求某个连续子串各个字母出现的次数。尺取法即连续子串两个指针，右指针不断右移，当发现满足条件的连续子串则左指针开始右移，当右指针移动到尽头则停止。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int cnt[26][200010];
int main()
{
    int n, k;
    string a;
    cin &gt;&gt; n &gt;&gt; k &gt;&gt; a;
    int l = a.size();
    for (int i = 0; i &lt; l; i++)
    {
        for (int j = 0; j &lt; 26; j++)
        {
            cnt[j][i + 1] = cnt[j][i];
        }
        cnt[a[i] - 'a'][i + 1]++;
    }
    int p1 = 0, p2 = 1, ans = n + 1;
    while (1)
    {
        int flag = 0;
        for (int i = 0; i &lt; 26; i++)
        {
            if (cnt[i][p2] - cnt[i][p1] &gt;= k)
            {
                ans = min(ans, p2 - p1);
                flag = 1;
            }
        }
        if (flag == 1)
            p1++;
        else
            p2++;
        if (p2 == n + 1)
            break;
    }
    if (ans == n + 1)
        cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;
    else
        cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h2>1H. Nozomi 和字符串</h2><h3>大意</h3><p>一个 $01$ 串，允许你改变其中的 $k$ 个数字，然后找出一个尽可能长的连续子串，这个子串上的所有字符都相同。求这个子串的长度。</p><h3>思路</h3><p>依然是尺取法。分成将 $0$ 变成 $1$ 和将 $1$ 变成 $0$ 两种情况。对于前者，还是两个指针，右指针不断右移，当遇到 $0$ 就用掉一次操作直到次数用尽。接下来右指针继续右移直到再次需要操作的时候，这时左指针右移直到已用操作数恰好减一为止，这时右指针继续右移。后者同理。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    string s;
    int n, k, ans = 0;
    cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;
    int pl = 0, pr = 0, change = 0;
    // 0 =&gt; 1
    for (int i = 0; i &lt; n; i++)
    {
        if (s[i] == '0')
        {
            if (change &lt; k)
            {
                change++;
            }
            else
            {
                while (pl &lt;= pr &amp;&amp; s[pl] != '0')
                    pl++;
                pl++;
            }
        }
        pr++;
        ans = max(ans, pr - pl);
    }
    pl = 0, pr = 0, change = 0;
    for (int i = 0; i &lt; n; i++)
    {
        if (s[i] == '1')
        {
            if (change &lt; k)
            {
                change++;
            }
            else
            {
                while (pl &lt;= pr &amp;&amp; s[pl] != '1')
                    pl++;
                pl++;
            }
        }
        pr++;
        // cout &lt;&lt; pl &lt;&lt; &quot; &quot; &lt;&lt; pr &lt;&lt; endl;
        ans = max(ans, pr - pl);
        // cout &lt;&lt; ans &lt;&lt; endl;
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h2>1I. Nico 和 Niconiconi</h2><h3>大意</h3><p>给出一个字符串，其中 <code>nico</code> 计 $a$ 分，<code>niconi</code> 计 $b$ 分，<code>niconiconi</code> 计 $c$ 分，每个字符都只能参与一次计分，问最大分数。</p><h3>思路</h3><p>简单 DP。$dp[i]$ 可由 $dp[i-1]$、$dp[i-3]$、$dp[i-5]$ 和 $dp[i-9]$ 转移而来，转移后取最大者即可。要注意避免越界。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
long long dp[300010];
int main()
{
    string s;
    long long n, a, b, c;
    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; s;
    for (long long i = 0; i &lt; n; i++)
    {
        if (i &gt; 0)
            dp[i] = dp[i - 1];
        if (i &gt;= 3 &amp;&amp; s.substr(i - 3, 4) == &quot;nico&quot;)
            dp[i] = max(dp[i], dp[i - 3] + a);
        if (i &gt;= 5 &amp;&amp; s.substr(i - 5, 6) == &quot;niconi&quot;)
            dp[i] = max(dp[i], dp[i - 5] + b);
        if (i &gt;= 9 &amp;&amp; s.substr(i - 9, 10) == &quot;niconiconi&quot;)
            dp[i] = max(dp[i], dp[i - 9] + c);
    }
    cout &lt;&lt; dp[n - 1] &lt;&lt; endl;
    return 0;
}
</code></pre><h2>1J. ## TODO</h2><h1>2020 牛客寒假算法基础集训营 2</h1><blockquote>枚举、贪心、DP、数论、思维、数据结构、哈希</blockquote><h2>2A. 做游戏</h2><h3>大意</h3><p>石头剪刀布。已知两人分别出了多少次石头、剪刀和布，求其中一个玩家最多能获胜多少局。</p><h3>思路</h3><p>贪心。让尽量多的剪刀 - 布、石头 - 剪刀和布 - 石头成组，可以直接出答案 $min(A,Y)+min(B,Z)+min(C,X)$。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    long long a, b, c, x, y, z;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; x &gt;&gt; y &gt;&gt; z;
    cout &lt;&lt; min(a, y) + min(b, z) + min(c, x) &lt;&lt; endl;
    return 0;
}
</code></pre><h2>2B. 排数字</h2><h3>大意</h3><p>给出一个字符串 $S$，问将字符串打乱后最多能有多少个不同的连续子串为 $616$ 。</p><h3>思路</h3><p>只需将所有的 $6$ 和 $1$ 集中起来：$6161616...$ ，因此统计 $6$ 和 $1$ 的个数即可，得出答案。注意 $cnt6$ 个 $6$ 最多能只造 $cnt6-1$ 个满足题意的字串，所以是 $min(cnt6-1,cnt1)$。如果算出来小于零应该将答案调整为 $0$。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int n, cnt1 = 0, cnt6 = 0;
    string s;
    cin &gt;&gt; n &gt;&gt; s;
    for (int i = 0; i &lt; n; i++)
    {
        if (s[i] == '1')
            cnt1++;
        else if (s[i] == '6')
            cnt6++;
    }
    cout &lt;&lt; max(0, min(cnt6 - 1, cnt1)) &lt;&lt; endl;
    return 0;
}
</code></pre><h2>2C. 算概率</h2><h3>大意</h3><p>一共 $n$ 道题，第 $i$ 道题的正确率是 $p_i$​，给出这个正确率对 $10^9+7$ 取模的结果，求这 $n$ 题里恰好有 $0,1,\cdots,n$ 题正确的概率分别是多少，同样对 $10^9+7$ 取模。对分数取模的定义已在题目给出。</p><h3>思路</h3><p>简单 DP。一个难点是求状态转移方程，一个是理解题目中对分数取模的概念（本蒟蒻在补第四套题时才会的乘法逆元，做这道题时直接观察样例对 $\frac{1}{2}$ 取模的结果，然后分子分母代进 $a$ 和 $b$ 蒙一把，发现简单粗暴地将概率乘个 $(10^9+7)+1$ 就是了）。要求前 $i$ 题正确 $j$ 题的概率，首先要知道的是前面具体过了哪几道题我们不需要知道（这里有点靠直觉），我们只需要简单粗暴地把它当作一个整体参与后面的计算。接下来，我们要分两种情况讨论，一个是第 $i$ 题对了 $f_{i-1,j} \cdot p_i$，一个是第 $i$ 题错了 $f_{i,j} \cdot (1-p_i)$，加起来就是了。状态转移方程 $f_{i,j} = f_{i-1,j} \cdot p_i+f_{i-1,j} \cdot (1-p_i)$。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

long long n, p[2005], dp[2005][2005];

int main()
{
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++)
    {
        cin &gt;&gt; p[i];
    }
    dp[0][0] = 1;
    for (int i = 1; i &lt;= n; i++)
    {
        dp[i][0] = dp[i - 1][0] * (1000000008 - p[i]) % 1000000007;
        for (int j = 1; j &lt;= i; j++)
            dp[i][j] = (dp[i - 1][j] * (1000000008 - p[i]) + dp[i - 1][j - 1] * p[i]) % 1000000007;
    }
    for (int i = 0; i &lt;= n; i++)
        cout &lt;&lt; dp[n][i] &lt;&lt; ' ';
    return 0;
}

</code></pre><h2>2D. 数三角</h2><h3>大意</h3><p>给出 $n$ 个点，问这 $n$ 个点形成的三角形中，总共有多少个钝角三角形。</p><h3>思路</h3><p>签到。枚举后比较 $a^2+b^2$ 和 $c^2$ 即可，另外注意三点不能共线。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int n, a[505], b[505], ans = 0;

bool f(int i, int j, int k)
{
    int check1 = (a[j] - a[i]) * (a[k] - a[i]) + (b[j] - b[i]) * (b[k] - b[i]);
    int check2 = (a[j] - a[i]) * (b[k] - b[i]) - (a[k] - a[i]) * (b[j] - b[i]);
    return check1 &lt; 0 &amp;&amp; check2 != 0;
}
int main()
{
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++)
        cin &gt;&gt; a[i] &gt;&gt; b[i];
    for (int i = 0; i &lt; n; i++)
    {
        for (int j = i + 1; j &lt; n; j++)
        {
            for (int k = j + 1; k &lt; n; k++)
            {
                if (f(i, j, k) || f(k, i, j) || f(j, i, k))
                {
                    ans++;
                }
            }
        }
    }

    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h2>2E. 做计数</h2><h3>大意</h3><p>求有多少个不同的正整数三元组 $(i,j,k)$ 满足 $\sqrt i+\sqrt j = \sqrt k$，而且 $i \cdot j \leq n$。</p><h3>思路</h3><p>看过一样的题，所以说多去看百度贴吧的营销号推送确实能涨知识。见到根号疯狂平方就对了（必要时候还是要移项的）。等式左右两边平方，$i+j+2 \sqrt {ij}=k$，发现要使 $k$ 为整数，必需要令 $i \cdot j$ 为完全平方数，所以我们就枚举完全平方数，然后再枚举这些完全平方数的因数。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int n, ans;
int main()
{
    cin &gt;&gt; n;
    for (int i = 1; i * i &lt;= n; i++)
    {
        for (int j = 1; j &lt;= i; j++)
            if (i * i % j == 0)
                ans += 2;
        ans--;
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h2>2F. 拿物品</h2><h3>大意</h3><p>多个物品，每个物品两个属性 $a$ 和 $b$， 甲乙两人轮流拿物品，最后甲的得分为其拿到物品的 $a$ 属性的和，乙则为 $b$ 属性的和。问两人最优策略下会拿哪些物品。</p><h3>思路</h3><p>假设两人赛后互换物品 $(a_1,b_1)$ 和 $(a_2,b_2)$，那么两人得分变化分别为 $-a_1+a_2$ 和 $b_1-b_2$，如果想让前者得分更大，要有 $a_1+b_1 &lt; a_2+b_2$。后者同理。所以就按照 $a+b$ 排序。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

const int N = 2e5 + 7;
int n;
vector&lt;int&gt; sa, sb;
struct temp
{
    int a, b, id;
} a[N];

bool cmp(temp a, temp b)
{
    return a.a + a.b &gt; b.a + b.b;
}

int main()
{
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++)
        cin &gt;&gt; a[i].a;
    for (int i = 1; i &lt;= n; i++)
    {
        cin &gt;&gt; a[i].b;
        a[i].id = i;
    }
    sort(a + 1, a + 1 + n, cmp);
    for (int i = 1; i &lt;= n; ++i)
        ((i &amp; 1) ? sa : sb).push_back(a[i].id);
    for (auto i : sa)
        cout &lt;&lt; i &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;
    for (auto i : sb)
        cout &lt;&lt; i &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;
    return 0;
}
</code></pre><h2>2G. 判正误</h2><h3>大意</h3><p>给出七个整数 $a, b, c, d, e, f, g$ 问是否有 $a^d+b^e+c^f=g$。数据范围 $10^9$ 级别，数据量 $10^3$ 级别。</p><h3>思路</h3><p>在模的意义下上快速幂验证，也就是验证 $a^d+b^e+c^f \equiv g \left ( mod \ M\right )$。模数越多，数据越水，就越稳。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int mod[] = {2, 3, 5, 7, 11, 31, 71, 97, 233, 397, 433, 449, 607, 857, 10007, 21179, 36251, 44579, 62003, 72883, 97843, 139991, 232013, 369353, 681521, 692711, 777241, 822821, 1956761, 2145137, 2915837, 6229117, 7788787, 13743493, 17331841, 19260817, 19269293, 19959809, 21006959, 23937083, 24410849, 28452757, 28478603, 29229359, 35570827, 35604011, 35875487, 37370863, 38303347, 38475517, 38819149, 40455791, 44021539, 45641993, 46531301, 48866749, 50529641, 52634191, 52790587, 55180799, 56971613, 58259351, 60954737, 62207269, 63367453, 65072599, 66017821, 67952779, 69475349, 74689217, 77059907, 77907121, 79391659, 84768797, 85584601, 85724879, 85756609, 86850899, 91783511, 92331541, 94519499, 96375241, 99033413, 99486311, 100569829, 106873549, 109329881, 109913681, 111186487, 111894067, 112136617, 112417363, 114011921, 119143363, 122994493, 123747781, 124001021, 126515639, 128191039, 128767909, 132222763, 133587661, 139644719, 145641527, 153388423, 155187077, 156883333, 157989581, 159538063, 161488643, 164039129, 166070447, 169181543, 169554227, 173564801, 175742867, 185469637, 187203899, 191263223, 198691817, 204144887, 211631201, 217903877, 218028203, 220073423, 228143453, 228667423, 232064653, 240519263, 245647159, 247586411, 247936121, 250949197, 253413211, 253464329, 260572729, 260590409, 262887773, 265711423, 266763641, 273585149, 276472817, 276500531, 280543667, 280649591, 281385491, 291366337, 293273159, 296973107, 302890501, 306568693, 315614297, 316729409, 317617121, 320337781, 320613497, 321322823, 324691051, 325963067, 327184157, 329900633, 330670159, 332058781, 332213669, 332300869, 334382221, 341895677, 347938237, 349011827, 349347503, 349906439, 353796941, 364557253, 364755931, 367946441, 372413831, 374358983, 379589897, 381149689, 389431873, 404683493, 405216109, 405495029, 408142403, 408989747, 410841979, 410935093, 412405351, 412592459, 412722139, 412990573, 418171483, 421270357, 424233613, 427938449, 428492083, 429962881, 430883569, 434988383, 435941201, 438816151, 440052953, 440143589, 444693631, 453646433, 455847109, 456640189, 457911511, 458185237, 463116761, 463861417, 469275953, 471298573, 471712513, 478267417, 483824813, 494828483, 497397293, 499657393, 507957479, 512906621, 519346459, 519879973, 520094713, 523213693, 525673273, 529575763, 529883803, 533887031, 534260809, 535328309, 541992667, 542253071, 544780177, 545567609, 552922529, 555129893, 555820037, 558473471, 563484017, 571310471, 578121241, 582251063, 583825639, 584121323, 592038487, 599098811, 601467677, 610073969, 615059213, 619220713, 622457177, 627412609, 630547919, 632342989, 637357363, 638865419, 648268013, 650007487, 651564761, 654115433, 661281713, 662664461, 667914281, 682988213, 691099121, 691445809, 692038043, 692411953, 698620943, 699007259, 701164631, 706806461, 707096251, 707697451, 709566589, 719095829, 725756807, 736880491, 739603867, 743026709, 744236861, 744396049, 747393791, 749395103, 760341121, 762934307, 773124059, 773195911, 776162609, 781629113, 781884613, 786120631, 788314343, 788898377, 788939293, 790209983, 791933183, 796328783, 798643889, 802280047, 803293991, 803847559, 809752739, 818520473, 820434047, 826810489, 829359959, 829707427, 836587463, 841011167, 843763253, 849410557, 851226437, 853058471, 853168793, 853778327, 859086391, 860720017, 863193077, 873061181, 888803059, 893035529, 900902953, 904636883, 917949577, 921817139, 922328707, 931449133, 933074827, 933156233, 935241721, 935632799, 939948881, 957119773, 961329913, 965269573, 965337949, 967551691, 971080093, 973578143, 976825877, 985100197, 985413691, 986124823, 990650057, 998244353, 999058883, 1000000007};
int ff(int a, int m)
{
    return (a % m + m) % m;
}
int Pow(int a, int b, int c)
{
    int ret = 1;
    while (b)
    {
        if (b &amp; 1)
            ret = ret * 1ll * a % c;
        a = a * 1ll * a % c;
        b &gt;&gt;= 1;
    }
    return ret;
}
int a, b, c, d, e, f, g;

bool check(int m)
{
    return ((Pow(ff(a, m), d, m) + Pow(ff(b, m), e, m)) % m + Pow(ff(c, m), f, m)) % m == ff(g, m);
}

int main()
{
    int T;
    cin &gt;&gt; T;
    while (T--)
    {
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f &gt;&gt; g;
        bool flag = 1;
        for (int i = 0; i &lt; 349; ++i)
        {
            if (!check(mod[i]))
            {
                flag = 0;
                break;
            }
        }
        puts(flag ? &quot;Yes&quot; : &quot;No&quot;);
    }
    return 0;
}
</code></pre><p>第三场。</p><h1>2020 牛客寒假算法基础集训营 4</h1><blockquote>搜索、简单 STL、前缀和、二分搜索、位运算、贪心、分治、树</blockquote><h2>4A. 欧几里得</h2><h3>大意</h3><p>给出了一个递归实现的 GCD 的代码，告诉你递归次数，求最开始的两个数，它们不相同且都是非负数，使这两个数的和最小。</p><h3>思路</h3><p>签到题。递归次数为 $0$ 次的时候肯定这两个是 $1$ 和 $0$。递归次数为 $1$ 次的时候则是 $2$ 和 $1$。假设说 $a$ 大于 $b$，其实就是已知 $b$ 和 $a\ mod\ b$，然后要让 $a$ 最小，那么就让 $\left \lfloor \frac{a}{b} \right \rfloor$ 最小。那就让它等于 $1$，可以很快发现是斐波那契数列。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main()
{
    int T;
    cin &gt;&gt; T;
    while (T--)
    {
        long long n;
        cin &gt;&gt; n;
        long long a[n + 10];
        a[0] = 1;
        a[1] = 2;
        for (int i = 2; i &lt; n + 7; i++)
        {
            a[i] = a[i - 1] + a[i - 2];
        }
        if (n == 0)
            cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;
        else
            cout &lt;&lt; a[n + 1] &lt;&lt; endl;
    }
    return 0;
}
</code></pre><h2>4B. 括号序列</h2><h3>大意</h3><p>给出一个仅包含 <code>[</code>、<code>]</code>、<code>(</code>、<code>)</code>、<code>{</code>、<code>}</code> 六种字符的括号序列，判断其是否合法。</p><h3>思路</h3><p>签到题。开一个栈来储存左括号，读到右括号看看栈顶的左括号和它匹不匹配。匹配就 POP 一个左括号。每时每刻都判断一下栈是不是空的。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main()
{
    string a;
    cin &gt;&gt; a;
    stack&lt;char&gt; b;
    for (int i = 0; i &lt; a.size(); i++)
    {
        // cout &lt;&lt; a[i];
        if (a[i] == '[')
            b.push('[');
        else if (a[i] == '{')
            b.push('{');
        else if (a[i] == '(')
            b.push('(');
 
 
        else if (a[i] == ']')
        {
            if (b.empty() || (! b.empty() &amp;&amp; b.top() != '['))
            {
                cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
                return 0;
            }
            else if (! b.empty())
                b.pop();
        }
        else if (a[i] == ')')
        {
            if (b.empty() || (! b.empty() &amp;&amp; b.top() != '('))
            {
                cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
                return 0;
            }
            else if (! b.empty())
                b.pop();
        }
        else if (a[i] == '}')
        {
            if (b.empty() || (! b.empty() &amp;&amp; b.top() != '{'))
            {
                cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
                return 0;
            }
            else if (! b.empty())
                b.pop();
        }
    }
    if (b.empty())
        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
    return 0;
}
</code></pre><h2>4C. 子段乘积</h2><h3>大意</h3><p>给出一个数列和一个数字 $k$，求其长度为 $k$ 的连续子段的乘积对 $998244353$ 取模余数的最大值。</p><h3>思路</h3><p>其实会乘法逆元的话就可以尺取了，可惜我刚开始做这题的时候不会，只好线段树了。反正期间也不用改动数字，懒标记什么的统统不要，把线段树建起来直接开始查询。</p><pre><code>#include &lt;bits/stdc++.h&gt;
 
using namespace std;
 
const int maxn = 200010;
 
int a[maxn + 2];
 
struct tree
{
    int l, r;
    long long pre, add;
} t[4 * maxn + 2];
 
void bulid(int p, int l, int r)
{
    t[p].l = l;
    t[p].r = r;
    if (l == r)
    {
        t[p].pre = a[l];
        return;
    }
    int mid = l + r &gt;&gt; 1;
    bulid(p * 2, l, mid);
    bulid(p * 2 + 1, mid + 1, r);
    t[p].pre = (t[p * 2].pre * t[p * 2 + 1].pre) % 998244353;
}
 
long long ask(int p, int x, int y)
{
    if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
        return t[p].pre;
    int mid = t[p].l + t[p].r &gt;&gt; 1;
    long long ans = 1;
    if (x &lt;= mid)
        ans = ans * ask(p * 2, x, y) % 998244353;
    if (y &gt; mid)
        ans = ans * ask(p * 2 + 1, x, y) % 998244353;
    return ans;
}
 
int main()
{
    int n, m;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; i++)
        scanf(&quot;%d&quot;, &amp;a[i]);
    bulid(1, 1, n);
    long long ans = -1;
    for (int i = 1; i + m - 1 &lt;= n; i++)
    {
        int x, y;
        ans = max(ans, ask(1, i, i + m - 1));
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h2>4D. 子段异或</h2><h3>大意</h3><p>给出一个数列，让你需要输出其中异或值为 $0$ 的不同连续子段的数量。</p><h3>思路</h3><p>首先用到了前缀和的思想，将前缀异或存进一个数组里。然后接合异或的性质：如果 $a\ xor\ b=c$，那么 $c\ xor\ a=b$，那么数组里任意两个数异或就是某一个区间的异或值，反正我们也不用关心这个区间从哪开始从哪结束，又因为 $a\ xor\ a=0$，我们给数组排下序，看看相邻两个数字是否相等就可以啦。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main()
{
    int n;
    cin &gt;&gt; n;
    long long a[n + 10];
    long long temp;
    cin &gt;&gt; temp;
    a[0] = temp;
    for (int i = 1; i &lt; n; i++)
    {
        cin &gt;&gt; temp;
        a[i] = a[i - 1] ^ temp;
    }
    sort(a, a + n);
    long long ans = 0, cnt = 1;
    for (int i = 0; i &lt; n; i++)
    {
        if (a[i] == 0)
            ans++;
        if (i != 0 &amp;&amp; a[i] == a[i - 1])
            cnt++;
        if (i != 0 &amp;&amp; (a[i] != a[i - 1] || i == n - 1))
        {
            ans += cnt * (cnt - 1) / 2;
            cnt = 1;
        }
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h2>4E. 最小表达式</h2><h3>大意</h3><p>给出一个字符串，里面只包含 $1$ 到 $9$ 还有加号。要求给出字符串的一个排列，使排列后是一个合法的算式而且算式的计算结果最小。</p><h3>思路</h3><p>贪心。加号的数字知道后就知道要有多少个数相加。然后我们将大的数字放在个位十位这种低位数，将小的数字放在高位数。然后是大数加法。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int cnt[20];
int sum[500050];

string s;
int main()
{
    cin &gt;&gt; s;
    int ccnt = 1;
    int n = s.size();
    for (int i = 0; i &lt; n; i++)
    {
        if (isdigit(s[i]))
        {
            cnt[s[i] - '0']++;
        }
        else
        {
            ccnt++;
        }
    }
    int p = 0, cp = 0;
    for (int i = 10; i &gt;= 1; i--)
    {
        while (cnt[i])
        {
            sum[cp] += i;
            cnt[i]--;
            p = (p + 1) % ccnt;
            if (p == 0)
                cp++;
        }
    }
    for (int i = 0; i &lt; 500010; i++)
    {
        sum[i + 1] += sum[i] / 10;
        sum[i] %= 10;
    }
    int opt = 0;
    for (int i = 500010; i &gt;= 0; i--)
    {
        if (opt || sum[i])
        {
            cout &lt;&lt; sum[i];
            opt = 1;
        }
    }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre><h2>4J. 二维跑步</h2><h3>完整题目</h3><p>一个点在平面直角坐标系中移动，初始位置 $(0,0)$，移动了 $n$ 次。从 $(i,0)$ 可以移动到 $(i+1,0)$、$(i+1,1)$、$(i+1,2)$、$(i,0)$、$(i-1,1)$、$(i-1,2)$，从 $(i,1)$ 可以移动到 $(i+1,0)$、$(i+1,1)$、$(i+1,2)$、$(i,1)$、$(i-1,0)$、$(i-1,2)$，从 $(i,2)$ 可以移动到 $(i+1,0)$、$(i+1,1)$、$(i+1,2)$、$(i,2)$、$(i-1,0)$、$(i-1,1)$。这里的 $(i,0)$ 移动到 $(i,0)$ 没有打错，而是不变换坐标的前提下消耗一个步数。已知 $n$ 和 $m$，数值均小于 $3 \cdot 10^6$，然后问你有多少种方式使得点的 $x$ 坐标最后落在 $[-m,m]$，答案对 $998244353$ 取模输出。</p><h3>思路</h3><h4>坐标等价</h4><p>理解题目在讲啥后，首先要做的是简化题目条件，你会发现这么多的坐标其中纵坐标只有三种，$0$、$1$ 和 $2$，当横坐标增加的时候（也就是从 $i$ 变成 $i+1$ 了，后面类似），无论初始位置的纵坐标是啥，能够到达的位置的纵坐标都是任意的。当横座标不变，纵坐标都是不变的。当横坐标减少的时候，无论初始位置的纵坐标是啥，能够到达的位置的纵坐标都只有两个可选而且都不等于初始位置的纵坐标。综上所述，我们发现纵坐标在这题是无关紧要的，横坐标相同的三个点是等价的。那么我们就可以将题目理解为：从 $x=i$ 的点到 $x=i+1$ 的点有三种方法，到 $x=i$ 的点有一种方法，到 $x=i-1$ 的点有两种方法。</p><h4>排列组合</h4><p>考虑到 $n$ 步下来本质还是左移、右移、不动三种方式的组合，只需设出三种方式分别的步数，用组合数公式即可。这里不妨设 $x$ 坐标不变的次数为 $i$，其中 $a$ 次 $x$ 坐标增加了，那么就会有 $n-i-a$ 次坐标减少。我们可以知道最后的坐标位置为 $x_{final}=a-(n-i-a)=2a-n+i$。为了让这个坐标处于 $[-m,m]$ 这个区间，我们要有：</p><p>$\left\{\begin{matrix} -m \leq 2a-n+i \leq m \ 0 \leq a \leq n-i \end{matrix}\right. $</p><p>由于 $a$ 还是一个整数，算出来的结果还需要上下取整：</p><p>$max(\left \lceil \frac{-m+n-i}{2} \right \rceil,0)\leq a \leq min(\left \lfloor \frac{m+n-i}{2} \right \rfloor,n-i)$</p><p>结合高中数学内容，我们知道 $i$ 次坐标不变，$a$ 次坐标增加的方案数一共是 $C _{n}^{i}(C _{n-i}^{a} \cdot 3^{a} \cdot 2^{n-i-a})$，我们进行求和操作，得出的结果是：</p><p>$ans = \sum_{i=0}^{n} \textrm{C} _{n}^{i}(\sum_{a=max(\left \lceil \frac{-m+n-i}{2} \right \rceil,0)}^{min(\left \lfloor \frac{m+n-i}{2} \right \rfloor,n-i)} \textrm{C} _{n-i}^{a} \cdot 3^{a} \cdot 2^{n-i-a}) $</p><h4>优化</h4><p>考虑到 $n$ 和 $m$ 的数据范围，直接进行计算肯定是不行，我们尝试将上面的式子拆为多部分。令：</p><p>$\left\{\begin{matrix}f(p,q)=C_p^q \cdot3^q \cdot 2^{p-q} \ L(i)=max(\left \lceil \frac{-m+n-i}{2} \right \rceil,0) \ R(i)=min(\left \lfloor \frac{m+n-i}{2} \right \rfloor,n-i) \ G(i)=\sum_{a=L(i)}^{R(i)}f(n-i,a) \ ans = \sum_{i=0}^{n}C_{n}^{i} G(i) \end{matrix}\right.$</p><p>在这些式子中，我们发现要缩短 $ans$ 的计算时间，就必须缩短 $G(i)$ 的计算时间。考虑到计算 $G(i)$ 时 $L(i)$ 和 $R(i)$ 都是一次性计算完成，但是 $f(p,q)$ 这样的式子我们要算上很多遍，我们我们就尝试优化 $f(p,q)$ 的计算。所谓优化很多时候就是预处理。我们看看对应的式子：组合数，得算阶乘吧，得算 $2$ 的 $p-q$ 次幂吧，得算 $3$ 的 $q$ 次幂吧，全部预处理掉。接下来就比较玄学了，考虑到我们除了要计算 $f(n-i,a)$，还要计算 $f(n-i-1,a)$、$f(n-i+1,a)$ 等等，因为恰好有 $C_p^q=C_{p-1}^{q}+C_{p-1}^{q-1}$ 这个公式，也就有了前项推后项的思路。我们尝试将 $2$ 和 $3$ 的指数和组合数匹配一下，得出 $f(p,q)=2f(p-1,q)+3f(p-1,q-1)$ 这样的式子。</p><p>接下来就不用再管 $f(p,q)$ 等于什么了，回到 $G(i)$ 这个层面。我们用上面的结论尝试展开上面的式子：</p><p>$G(i)=\sum_{a=L(i)}^{R(i)}f(n-i,a)$  <br>$=\sum_{a=L(i)}^{R(i)}(3f(n-(i+1),a-1)+2f(n-(i+1),a))$  <br>$=3f(n-(i+1),L(i)-1)+2f(n-(i+1),L(i))+3f(n-(i+1),L(i))+ \cdots +2f(n-(i+1),R(i)-1))+3f(n-(i+1),R(i)-1)+2f(n-(i+1),R(i))$  <br>$=5 \sum_{a=L(i)}^{R(i)-1}f(n-(i+1),a)+3f(n-(i+1),L(i)-1)+2f(n-(i+1),R(i))$</p><p>你会发现有一项是 $\sum_{a=L(i)}^{R(i)-1}f(n-(i+1),a)$，和 $G(i+1)$ 的形式很像，但是后者是 $\sum_{a=L(i+1)}^{R(i+1)}f(n-(i+1),a)$，还是有点区别。怎么办呢？就人为创造一个 $\sum_{a=L(i+1)}^{R(i+1)}f(n-(i+1),a)$ 呗。还是上面那个式子，我们把所有的 $L(i)$ 换成 $L(i+1)$，把 $R(i)-1$ 换成 $R(i+1)$，但这算出来就和 $G(i)$ 差了几个的 $f(n-i,a)$ 怎么办呢。先标记为 $\Delta$ 到后面再算呗。</p><p>$G(i)=\sum_{a=L(i+1)}^{R(i+1)+1}f(n-i,a)+\Delta$  <br>$=\sum_{a=L(i+1)}^{R(i+1)+1}(3f(n-(i+1),a-1)+2f(n-(i+1),a))+\Delta$  <br>$=3f(n-(i+1),L(i+1)-1)+2f(n-(i+1),L(i+1))+3f(n-(i+1),L(i+1))+ \cdots +2f(n-(i+1),R(i+1)))+3f(n-(i+1),R(i+1))+2f(n-(i+1),R(i+1)+1)+\Delta$  <br>$=5 \sum_{a=L(i+1)}^{R(i+1)}f(n-(i+1),a)+3f(n-(i+1),L(i+1)-1)+2f(n-(i+1),R(i+1)+1)+\Delta$  <br>$=5G(i+1)+3f(n-(i+1),L(i+1)-1)+2f(n-(i+1),R(i+1)+1)+\Delta$</p><h4>代码实现</h4><p>在式子乘个 <code>1ll</code> 可以有效避免溢出的问题。计算高次幂为了避免溢出，在写快速幂的时候也要每步取模。计算组合数的时候需要用到除以比较大的数，还是为了避免溢出这时候也是要取模的。于是就打开了乘法逆元的新世界，道理其实也不是很懂，大概就是如果有一个素数 $p$，根据费马小定理则有 $a^{p-1}\equiv1(mod\;p)$，那么 ${a}\cdot a^{p-2}\equiv1(mod\;p)$，$a^{p-2}$ 就叫 $a\ mod\ p$ 意义下的逆元，照用就是了。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
const int mod = 998244353;
const int N = 3000010;
int n, m, f2[N], f3[N], q[N], p[N], G[N];
 

//////// 快速幂 ////////
int qpow(int a, int b) {
    int ans = 1;
    a %= mod;
    for (; b; b &gt;&gt;= 1) {
        if (b &amp; 1) ans = 1ll * ans * a % mod;
        a = 1ll * a * a % mod;
    }
    return ans;
}

//////// 组合数 ////////
int c(int a, int b) { return 1ll * q[a] * p[b] % mod * p[a - b] % mod; }

//////// 算 f(a,b) ////////
int f(int a, int b) { return 1ll * c(a, b) * f3[b] % mod * f2[a - b] % mod; }

int main() {
    cin &gt;&gt; n &gt;&gt; m;
    f2[0] = f3[0] = q[0] = 1;
    for (int i = 1; i &lt;= n; i++) {
        // 算 i!，2 的 i 次方，3 的 i 次方，对 mod 取模
        q[i] = 1ll * q[i - 1] * i % mod;
        f2[i] = 1ll * f2[i - 1] * 2 % mod;
        f3[i] = 1ll * f3[i - 1] * 3 % mod;
    }

    // 乘法逆元
    p[n] = qpow(q[n], mod - 2);
    for (int i = n - 1; i &gt;= 0; i--) p[i] = 1ll * p[i + 1] * (i + 1) % mod;

    //////// 算 G(i) ////////
    int l = 0, r = 1; G[n] = 1;
    for (int i = n - 1; i &gt;= 0; i--, r++) {

        // 算 5 * G(i + 1) + 3 * f(...) + 5 * f(...)
        G[i] = (5ll * G[i + 1] % mod + 3ll * f(n - i - 1, l - 1) % mod + 2ll * f(n - i - 1, r) % mod) % mod;
        int ql = max((n - i - m + 1) / 2, 0), qr = min((n - i + m) / 2, n - i);
        // 此时 l = L(i + 1), r = R(i + 1) + 1
        // 此时 ql = L(i), qr = R(i)
        
        // 算 delta
        while (l &lt; ql) G[i] = (1ll * G[i] - f(n - i, l) + mod) % mod, l++;
        while (l &gt; ql) l--, G[i] = (1ll * G[i] + f(n - i, l)) % mod;
        while (r &gt; qr) G[i] = (1ll * G[i] - f(n - i, r) + mod) % mod, r--;
        while (r &lt; qr) r++, G[i] = (1ll * G[i] + f(n - i, r)) % mod;
        // 此时 l = L(i), r = R(i)
        // 此时 i--, r++
    }

    //////// 算答案 ////////
    int ans = 0;
    for (int i = n; i &gt;= 0; i--) ans = (ans + 1ll * G[i] * c(n, i) % mod) % mod;
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h1>2020 牛客寒假算法基础集训营 5</h1><blockquote>字符串、二分、哈希、DP、模拟、搜索、数学</blockquote><h2>5A. 模板</h2><h3>大意</h3><p>给出两个字符串，允许对其中一个字符串做任意的替换、删除最后一位、在末尾添加一个字母。问最少的步数，使两个字符串相同。</p><h3>思路</h3><p>签到题。逐个位置匹配，发现不一样则步数加一。当长度较短的字符串匹配完后再加上两个字符串的长度差。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    string a, b;
    cin &gt;&gt; a &gt;&gt; b;
    if (n &lt; m)
    {
        swap(n, m);
        swap(a, b);
    }
    int ans = 0;
 
    for (int i = 0; i &lt; m; i++)
    {
        if (a[i] != b[i])
            ans++;
    }
    ans += n - m;
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><h2>5B. 牛牛战队的比赛地</h2><h3>大意</h3><p>已知多个点的坐标，问平面上哪个位置满足到这些点的距离的最大值最小。</p><h3>思路</h3><p>三分答案。大概是因为它是二次函数，每次使用三分都能排除最差的一部分答案。二分答案似乎也是可以的，但二分的依据是单调性，二次函数也没法保证这一点，所以做起来似乎要麻烦很多。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

struct p
{
    int x, y;
} a[100005];
int n;
double check(double x)
{
    double max = 0;
    for (int i = 0; i &lt; n; i++)
    {
        double tmp = sqrt(a[i].y * a[i].y + (a[i].x - x) * (a[i].x - x));
        if (tmp &gt; max)
            max = tmp;
    }
    return max;
}
double tsearch(double left, double right)
{
    int i;
    double mid, midmid;
    for (i = 0; i &lt; 100; i++)
    {
        mid = left + (right - left) / 2;
        midmid = mid + (right - mid) / 2;
        if (check(mid) &gt; check(midmid))
            left = mid;
        else
            right = midmid;
    }
    return mid;
}
int main()
{
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++)
        cin &gt;&gt; a[i].x &gt;&gt; a[i].y;
    double max = tsearch(-10000, 10000);
    cout &lt;&lt; check(max) &lt;&lt; endl;
    return 0;
}
</code></pre><h2>5C. C 语言 IDE</h2><h3>大意</h3><p>输入一份 C 语言代码，要求输出代码中出现的函数。</p><h3>思路</h3><p>哦，是码农大模拟！爱了爱了。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

string source;
void replaceAll(string &amp;s, string oldstr, string newstr)
{
    for (string::size_type pos = 0; pos != string::npos; pos += newstr.length())
        if ((pos = s.find(oldstr, pos)) != string::npos)
            s.replace(pos, oldstr.length(), newstr);
        else
            break;
}
struct functions
{
    string inClass, name, outputType;
    vector&lt;string&gt; inputType;
    functions(string inClass = &quot;&quot;, string name = &quot;&quot;, string outputType = &quot;void&quot;, vector&lt;string&gt; inputType = vector&lt;string&gt;(0))
        : inClass(inClass), name(name), outputType(outputType), inputType(inputType) {}
};
vector&lt;functions&gt; funs;
void solve(string &amp;s)
{
    replaceAll(s, &quot;/*&quot;, &quot; /* &quot;);
    replaceAll(s, &quot;*/&quot;, &quot; */ &quot;);
    replaceAll(s, &quot;//&quot;, &quot; // &quot;);
    replaceAll(s, &quot;(&quot;, &quot; ( &quot;);
    replaceAll(s, &quot;)&quot;, &quot; ) &quot;);
    replaceAll(s, &quot;{&quot;, &quot; { &quot;);
    replaceAll(s, &quot;}&quot;, &quot; } &quot;);
    replaceAll(s, &quot;=&quot;, &quot; = &quot;);
    replaceAll(s, &quot;\&quot;&quot;, &quot; \&quot; &quot;);
    replaceAll(s, &quot;'&quot;, &quot; ' &quot;);
    replaceAll(s, &quot;;&quot;, &quot; ; &quot;);
    replaceAll(s, &quot;,&quot;, &quot; , &quot;);
    replaceAll(s, &quot;+ = &quot;, &quot;+=&quot;);
    replaceAll(s, &quot;- = &quot;, &quot;-=&quot;);
    replaceAll(s, &quot;* = &quot;, &quot;*=&quot;);
    replaceAll(s, &quot;/ = &quot;, &quot;/=&quot;);
    replaceAll(s, &quot;^ = &quot;, &quot;^=&quot;);
    replaceAll(s, &quot;| = &quot;, &quot;|=&quot;);
    replaceAll(s, &quot;&amp; = &quot;, &quot;&amp;=&quot;);
    replaceAll(s, &quot;:&quot;, &quot; : &quot;);
    replaceAll(s, &quot; :  : &quot;, &quot;::&quot;);
    vector&lt;string&gt; tokens;
    string now = &quot;&quot;;
    for (int i = 0; s[i]; i++)
    {
        if (s[i] == ' ' || s[i] == '\t' || s[i] == '\r' || s[i] == '\n' || s[i] == '\0')
        {
            if (now != &quot;&quot;)
            {
                if (now == &quot;:&quot; &amp;&amp; tokens.back() == &quot;)&quot;)
                {
                    string tmpnow = &quot;&quot;;
                    for (int j = i + 1; s[j]; j++)
                    {
                        if (s[j] == ' ' || s[j] == '\t' || s[j] == '\r' || s[j] == '\n' || s[j] == '\0')
                        {
                            if (tmpnow == &quot;{&quot;)
                            {
                                now = &quot;{&quot;;
                                i = j - 1;
                                break;
                            }
                            tmpnow = &quot;&quot;;
                        }
                        else
                            tmpnow += s[j];
                    }
                    continue;
                }
                if (now == &quot;const&quot;)
                {
                    now = &quot;&quot;;
                    continue;
                }
                if (now == &quot;//&quot;)
                {
                    for (int j = i; s[j]; j++)
                    {
                        if (s[j] == '\n')
                        {
                            i = j - 1;
                            break;
                        }
                    }
                    now = &quot;&quot;;
                    continue;
                }
                if (now == &quot;/*&quot;)
                {
                    int num = 1;
                    string tmpnow = &quot;&quot;;
                    for (int j = i + 1; s[j]; j++)
                    {
                        if (s[j] == ' ' || s[j] == '\t' || s[j] == '\r' || s[j] == '\n' || s[j] == '\0')
                        {
                            if (tmpnow == &quot;/*&quot;)
                                num++;
                            if (tmpnow == &quot;*/&quot;)
                            {
                                num--;
                                if (num == 0)
                                {
                                    i = j - 1;
                                    break;
                                }
                            }
                            tmpnow = &quot;&quot;;
                        }
                        else
                            tmpnow += s[j];
                    }
                    now = &quot;&quot;;
                    continue;
                }
                tokens.push_back(now);
                now = &quot;&quot;;
            }
        }
        else
            now += s[i];
    }
    int cnt = 0;
    string nowNamespace = &quot;&quot;;
    for (int i = 1; i &lt; (int)tokens.size(); i++)
    {
        if ((tokens[i] == &quot;struct&quot; || tokens[i] == &quot;class&quot;) &amp;&amp; tokens[i + 2] == &quot;{&quot;)
        {
            cnt = 0;
            nowNamespace = tokens[i + 1];
            i += 2;
        }
        functions tmp(nowNamespace);
        if (tokens[i] == &quot;{&quot; &amp;&amp; tokens[i - 1] == &quot;)&quot;)
        {
            int num = 1;
            for (int j = i - 2; j &gt;= 0; j--)
            {
                if (tokens[j] == &quot;)&quot;)
                    num++;
                if (tokens[j] == &quot;(&quot;)
                {
                    num--;
                    if (num == 0)
                    {
                        tmp.name = tokens[j - 1];
                        tmp.outputType = &quot;&quot;;
                        for (int k = j - 2; k &gt;= 0; k--)
                            if (tokens[k] != &quot;}&quot; &amp;&amp; tokens[k] != &quot;}&quot; &amp;&amp; tokens[k] != &quot;;&quot; &amp;&amp;
                                tokens[k].back() != ':' &amp;&amp; tokens[k] != &quot;inline&quot; &amp;&amp;
                                tokens[k] != &quot;static&quot; &amp;&amp; tokens[k][0] != '#' &amp;&amp;
                                tokens[k].back() != '\&quot;' &amp;&amp; tokens[k].back() != '&gt;')
                                tmp.outputType = tmp.outputType == &quot;&quot; ? tokens[k] : tokens[k] + &quot; &quot; + tmp.outputType;
                            else
                                break;
                        int last = i - 2;
                        for (int k = i - 2; k &gt;= j; k--)
                        {
                            if (tokens[k] == &quot;(&quot; || tokens[k] == &quot;,&quot;)
                            {
                                string tt = &quot;&quot;;
                                for (int t = k + 1; t &lt; last; t++)
                                    tt = tt == &quot;&quot; ? tokens[t] : tt + &quot; &quot; + tokens[t];
                                if (tt != &quot;&quot;)
                                    tmp.inputType.push_back(tt);
                                last = k - 1;
                            }
                            if (tokens[k] == &quot;=&quot; || tokens[k] == &quot;)&quot;)
                                last = k - 1;
                        }
                        reverse(tmp.inputType.begin(), tmp.inputType.end());
                        break;
                    }
                }
            }
            funs.push_back(tmp);
            num = 1;
            for (int j = i + 1; j &lt; (int)tokens.size(); j++)
            {
                if (tokens[j] == &quot;{&quot;)
                    num++;
                if (tokens[j] == &quot;}&quot;)
                {
                    num--;
                    if (num == 0)
                    {
                        i = j;
                        break;
                    }
                }
            }
            continue;
        }
        if (nowNamespace != &quot;&quot;)
        {
            if (tokens[i] == &quot;{&quot;)
                cnt++;
            if (tokens[i] == &quot;}&quot;)
            {
                cnt--;
                if (!cnt)
                    nowNamespace = &quot;&quot;;
            }
        }
    }
}
int main()
{
    char ch;
    while ((ch = getchar()) != EOF)
        source += ch;
    solve(source);
    for (auto &amp;i : funs)
    {
        if (i.outputType != &quot;&quot;)
            cout &lt;&lt; i.outputType &lt;&lt; &quot; &quot;;
        if (i.inClass != &quot;&quot;)
            cout &lt;&lt; i.inClass &lt;&lt; &quot;::&quot;;
        cout &lt;&lt; i.name &lt;&lt; &quot;(&quot;;
        for (int j = 0; j &lt; (int)i.inputType.size(); j++)
            cout &lt;&lt; i.inputType[j] &lt;&lt; (j == (int)i.inputType.size() - 1 ? &quot;)&quot; : &quot;,&quot;);
        if ((int)i.inputType.size() == 0)
            cout &lt;&lt; &quot;)&quot;;
        cout &lt;&lt; endl;
    }
    return 0;
}
</code></pre><h2>5E. Enjoy the Game</h2><h3>大意</h3><p>给出一个规则：$n$ 张卡牌，先手第一步最少拿 $1$ 张，最多拿 $n-1$ 张。接下来每一步，双方最少要拿 $1$ 张，最多拿等同于上一步对方拿的牌数的牌。拿走最后一张牌胜。问对不同的 $n$，先手是否有必胜策略。</p><h3>思路</h3><p>找规律找出来的，只要是二的幂就是 Alice 胜，否则就是 Bob 胜。这题好像把 <code>__builtin_popcount(n)</code> 给卡了，原因不明，反正下次是不敢用了。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
long long lowbit(long long x)
{
    return x&amp;(-x);
}
   
int main()
{
    long long n;
    cin &gt;&gt; n;
    if (lowbit(n) == n)
    {
        cout &lt;&lt; &quot;Alice&quot; &lt;&lt; endl;
        return 0;
    }
    cout &lt;&lt; &quot;Bob&quot; &lt;&lt; endl;
    return 0;
}
</code></pre><h2>5H. Hash</h2><h3>大意</h3><p>给出一个字符串和一个 Hash 函数（核心代码 <code>res = (res * 26 + str[i] - 'a') % mod;</code>），求一个字典序最小且大于该字符串且有着相同 Hash 的字符串。</p><h3>思路</h3><p>其实就是把字符串转成了二十六进制数，然后给它取模。那么要想 Hash 值相同字典序还要大于原字符串，就直接给这个二十六进制数加上模数就好了。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main()
{
    string a;
    int m;
    int ta[6];
    while (cin &gt;&gt; a &gt;&gt; m)
    {
        int org[6], backup[6];
        for (int i = 0; i &lt; 6; i++)
        {
            org[i] = a[i] - 'a';
            backup[i] = org[i];
        }
        string b = a;
        for (int i = 5; i &gt;= 0; i--)
        {
            ta[i] = m % 26;
            m /= 26;
        }
        if (m != 0)
        {
            cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;
        }
        for (int i = 5; i &gt; 0; i--)
        {
            org[i] += ta[i];
            if (org[i] &gt; 25)
            {
                org[i] -= 26;
                org[i - 1]++;
            }
        }
        org[0] += ta[0];
        if (org[0] &lt; 26)
        {
            for (int i = 0; i &lt; 6; i++)
            {
                printf(&quot;%c&quot;, org[i] + 'a');
            }
            cout &lt;&lt; endl;
            continue;
        }
        else
        {
            cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;
            continue;
        }
    }
 
    return 0;
}
</code></pre><h2>5I. I 题是个签到题</h2><h3>大意</h3><p>给出一场比赛参赛人数和各题过题人数，通过人数不低于全场人数的 $80\%$ 或在所有题目中前三多就叫签到题。问 I 题是不是签到题。</p><h3>思路</h3><p>签到题。排序即可，关键是要处理并列的情况。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
struct temp
{
    int num;
    int ac;
} a[20000];
 
bool cmp(temp a, temp b)
{
    return a.ac &gt; b.ac;
}
 
int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 0; i &lt; n; i++)
    {
        cin &gt;&gt; a[i].ac;
        a[i].num = i;
    }
    if (a[8].ac * 10 &gt;= m * 8)
    {
        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
        return 0;
    }
    sort(a, a + n, cmp);
    int cnt = 1;
    int cur = 1;
    if (a[0].num == 8)
    {
        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
        return 0;
    }
    for (int i = 1; i &lt; n; i++)
    {
        if (a[i].ac != a[i - 1].ac)
        {
            cnt += cur;
            cur = 1;
        }
        else
        {
            cur++;
        }
        if (a[i].num == 8 &amp;&amp; cnt &lt;= 3)
        {
            cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
            return 0;
        }
        if (cnt &gt; 3)
        {
            cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
            return 0;
        }
    }
}
</code></pre><h2>5J. 牛牛战队的秀场</h2><h3>大意</h3><p>求圆内接正 $n$ 边形的边长。</p><h3>思路</h3><p>签到。可以很容易地计算每条弦对应的圆心角的大小，然后三角函数。</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
#define PI 3.1415926535898
 
int main()
{
    double n, r, i, j;
    cin &gt;&gt; n &gt;&gt; r &gt;&gt; i &gt;&gt; j;
    if (i == j)
    {
        cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;
        return 0;
    }
    if (i &gt; j)
        swap(i, j);
    double ans = min(j - i, i - j + n);
    printf(&quot;%.8lf\n&quot;, ans * 2 * r * sin(360 / n / 2 * PI / 180));
    return 0;
}
</code></pre><h1>2020 牛客寒假算法基础集训营 6</h1><blockquote>贪心、图论、构造、二分、计数、数论、思维</blockquote><h2>6A. 配对</h2><h3>大意</h3><p>给出两个集合，每个集合里有 $N$ 个数，不同集合的两个数配对并求和，要求最大化第 $K$ 大的和。</p><h3>思路</h3><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
typedef long long ll;
 
int main()
{
    ll n, k;
    cin &gt;&gt; n &gt;&gt; k;
    ll a[n], b[n], c[n];
    for (ll i = 0; i &lt; n; i++)
    {
        cin &gt;&gt; a[i];
    }
    for (ll i = 0; i &lt; n; i++)
    {
        cin &gt;&gt; b[i];
    }
    sort(a, a + n);
    sort(b, b + n);
    for (int i = 0; i &lt; k; i++)
    {
        c[i] = a[n - 1 - i] + b[n - k + i];
    }
    sort(c, c + k);
    cout &lt;&lt; c[0] &lt;&lt; endl;
    return 0;
}
</code></pre><h2>B.</h2>
]]></content>
<link rel="replies" type="text/html" href="https://static.bobby285271.top/index.php/2020/02/09/2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://static.bobby285271.top/index.php/feed/atom/2020/02/09/2020-Nowcoder-Basic-Algorithm-Training-Camp-Solutions.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[How to Deploy WordPress on a Fedora Server (en)]]></title>
<link rel="alternate" type="text/html" href="https://static.bobby285271.top/index.php/2020/02/03/How-to-Deploy-WordPress-on-a-Fedora-Server-en.html" />
<id>https://static.bobby285271.top/index.php/2020/02/03/How-to-Deploy-WordPress-on-a-Fedora-Server-en.html</id>
<updated>2020-02-02T16:00:00+00:00</updated>
<published>2020-02-02T16:00:00+00:00</published>
<author>
    <name>bobby285271</name>
    <uri>https://static.bobby285271.top</uri>
</author>
<summary type="html"><![CDATA[First things firstYou should get a IP address after buying VPS, such as 123.123.123.123. Open you...]]></summary>
<content type="html" xml:base="https://static.bobby285271.top/index.php/2020/02/03/How-to-Deploy-WordPress-on-a-Fedora-Server-en.html" xml:lang="zh-CN"><![CDATA[
<h2>First things first</h2><p>You should get a IP address after buying VPS, such as <code>123.123.123.123</code>. Open your favourite terminal and enter:</p><blockquote>Replace <code>123.123.123.123</code> with your actual IP address.</blockquote><pre><code>ssh root@123.123.123</code></pre><p>Enter your password to login. Perform a full upgrade on your system:</p><pre><code>dnf upgrade
</code></pre><h2>Package Installation</h2><p>Install Apache, PHP and MariaDB using the DNF package manager. There is NO need to install the <code>wordpress</code> package.</p><pre><code>dnf install @&quot;Web Server&quot; php-mysqlnd mariadb-server
</code></pre><p>Enable the web and database services to start at boot time, then start them immediately:</p><pre><code>systemctl enable httpd.service mariadb.service
systemctl start httpd.service mariadb.service</code></pre><h2>MariaDB Configuration</h2><p>Firstly, initialize MariaDB. If this is your first use of MariaDB, you should create a password for your root user here. <strong>Don’t use</strong> the system’s own root (administrator) password. It is suggested to answer <code>y</code> to all yes-no questions afterwards:</p><pre><code>mysql_secure_installation</code></pre><p>Next, create a database. You can host more than one WordPress site on a machine. Therefore, you may want to choose a distinctive name for yours. For instance, this example uses <code>mywpsite</code>. The <code>-p</code> switch prompts you for a password.</p><blockquote>Replace <code>mywpsite</code> with a database name you preferred.</blockquote><pre><code>mysqladmin create mywpsite -u root -p</code></pre><p>Next, set up a special privileged user and password for the database. The web app uses these credentials to run. Use the standard <code>mysql</code> client program for this step. The <code>-D</code> option attaches to the built-in MySQL database where privileges are stored.</p><blockquote>Replace <code>sqluser</code> and <code>password</code> with a user name you preferred and a strong password.</blockquote><pre><code>mysql -D mysql -u root -p</code></pre><pre><code>GRANT ALL PRIVILEGES ON mywpsite.* TO 'sqluser'@'localhost' IDENTIFIED BY 'password';
FLUSH PRIVILEGES;
QUIT;</code></pre><h2>Set up the Web Server</h2><p>Next, tune the SELinux parameters so the web server can perform necessary functions.</p><pre><code>setsebool -P httpd_can_network_connect_db=1
setsebool -P httpd_can_sendmail=1</code></pre><p>Next, configure your firewall so it allows traffic on port <code>80</code> (HTTP):</p><pre><code>firewall-cmd --add-service=http --permanent
firewall-cmd --reload</code></pre><h2>Download WordPress</h2><p>These latest version of WordPress are always available on <code>https://wordpress.org/latest.tar.gz</code>.</p><pre><code>cd /var/www/html
wget https://wordpress.org/latest.tar.gz</code></pre><p>Extract the downloaded archive to the document root of your domain and update permissions on files.</p><pre><code>tar xzf latest.tar.gz
chown -R apache.apache wordpress
chmod -R 755 wordpress</code></pre><h2>All Done</h2><p>Visit <code>123.123.123.123/wordpress</code>, and finish the installation.</p>
]]></content>
<link rel="replies" type="text/html" href="https://static.bobby285271.top/index.php/2020/02/03/How-to-Deploy-WordPress-on-a-Fedora-Server-en.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://static.bobby285271.top/index.php/feed/atom/2020/02/03/How-to-Deploy-WordPress-on-a-Fedora-Server-en.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[Dynamic Programming on Tree Structures (Luogu P2014)]]></title>
<link rel="alternate" type="text/html" href="https://static.bobby285271.top/index.php/2019/12/26/Dynamic-Programming-on-Tree-Structures-Luogu-P2014.html" />
<id>https://static.bobby285271.top/index.php/2019/12/26/Dynamic-Programming-on-Tree-Structures-Luogu-P2014.html</id>
<updated>2019-12-26T09:22:00+00:00</updated>
<published>2019-12-26T09:22:00+00:00</published>
<author>
    <name>bobby285271</name>
    <uri>https://static.bobby285271.top</uri>
</author>
<summary type="html"><![CDATA[题目https://www.luogu.com.cn/problem/P2014思路以下内容仅为个人理解，可能存在错误。树的孩子兄弟表示法想要使用孩子兄弟表示法储存上面这样的一棵树，我们就要从根...]]></summary>
<content type="html" xml:base="https://static.bobby285271.top/index.php/2019/12/26/Dynamic-Programming-on-Tree-Structures-Luogu-P2014.html" xml:lang="zh-CN"><![CDATA[
<h2>题目</h2><p><a href="https://www.luogu.com.cn/problem/P2014">https://www.luogu.com.cn/problem/P2014</a></p><h2>思路</h2><blockquote>以下内容<strong>仅为个人理解，可能存在错误</strong>。</blockquote><h3>树的孩子兄弟表示法</h3><p><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/p2014-2.gif" alt="" title=""></p><p>想要使用孩子兄弟表示法储存上面这样的一棵树，我们就要从根节点开始，依次用链表存储各个节点的孩子节点和兄弟节点。因此，该链表中的节点应包含以下三部分内容：</p><ul><li>节点的值。</li><li>指向孩子节点的指针。</li><li>指向兄弟节点的指针。</li></ul><p><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/p2014-1.gif" alt="" title=""></p><p>在这里，每个节点是一门课程，孩子节点其实就是后续课程，兄弟节点其实就是前导课程相同的一门课程。不妨将第 i 门课程编号为 i，那么每一门课都会有一个独一无二的课程编号。这个课程编号本应放在数据域，但是考虑到它的独一无二性和连续性，也方便我们查找某一课程的「后续课程」和「前导课程相同的一门课程」的课程编号，以获取它的学分，我们不妨直接用数组下标来储存这个，就不开数据域了。</p><h3>树形动归</h3><blockquote><strong>TODO</strong>：此部分自认为没有理解透彻，下面给出的思路也不够自然。</blockquote><p>考虑之前发过的几道题，LXY 点菜，我们逐道菜过目；上山采药，我们逐件药品过目。这里我们照葫芦画瓢，就逐门课过目。树形动归和线性动归又有些啥不同呢？首先要遵循从最简单的子问题开始，逐步扩大子问题规模的原则，从子树上动归，最后进行合并。如何体现合并这一操作呢？就是在过目某一节点（课程）的时候同时考虑这个节点（课程）的后续课程。</p><p>不妨就将根节点（假设其编号为 now）的所有孩子过目完，假设现在过目了 a 门课程，选择了 b 门课程。对于这个第 a 门课程依然是两个选择，<strong>选和不选</strong>。不选的话和我过目 a - 1 门课程，选择了 b 门课程效果是一样的，而第 a 门课程我不选自然就拿不了学分，其后续课程我也选不了就无需考虑了。但如果我选择呢，我不但选了第 a 门课程，而且还要考虑它的后续课程。假设已知我过目完 a - 1 门课程时，选择了 b - c 门课程。过目第 a 门课程显然我就考虑了第 a 门课的后续课程并选择了 c 门课程（包含 a）。此时为了求出过目了 a 门课程，选择了 b 门课程的最大学分，我就要求出过目 a - 1 门课程，选择了 b - c 门课程的最大学分和考虑了第 a 门课的<strong>所有</strong>后续课程并选择了 c 门课程（包含 a）的最大学分。而由于我们从子树开始动归，所以后者我们是已经求出过的。考虑完选和不选两种情况后，取最大值即可。</p><p>假设 <code>son</code> 是 <code>now</code> 的一个子节点，有：</p><pre><code class="lang-cpp">f[now][i][j] = max(f[now][i - 1][j], f[son][所有节点数][k] + f[now][i - 1][j - k]);</code></pre><p>和线性动态规划一样，由于过目了 i 门课程的情况永远由过目 i - 1 门课程的情况推出来，于是这一维可以被去掉。</p><pre><code class="lang-cpp">f[now][j] = max(f[now][j], f[son][k] + f[now][j - k]);</code></pre><h2>AC 代码</h2><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
//n、m 如题所述，f[i][j] 表示 i 为子树的根节点，在子树中选 j 门课的最大学分
int n, m, f[1000][1000], fa;
struct node //用结构体储存节点信息
{
    int pre, to; //pre 为兄弟节点在数组 e 中的下标，to 为孩子节点在数组 e 中的下标
} e[1000];       //考虑到课程编号的唯一性，这题 e 数组下标可用来表示课程编号，我们也不用开数据域了

void dp(int now) //在「根节点编号为 now 的树」中动归
{
    //遍历 now 的所有孩子节点，也就是先访问 now 的「第一个」儿子节点，然后再访问这个儿子节点的兄弟节点
    for (int i = e[now].to; i != 0; i = e[i].pre)
    {
        dp(i);                           //在「根节点编号为 i 的树」中动归
        for (int j = m + 1; j &gt;= 1; j--) //关于为什么要反向遍历，前面的文章有提及
        {
            for (int k = 0; k &lt; j; k++)
                f[now][j] = max(f[now][j], f[i][k] + f[now][j - k]); //状态转移方程
        }
    }
}
int main()
{
    ios::sync_with_stdio(false); //是输入输出挂
    cin.tie(0);                  //还是输入输出挂
    cout.tie(0);                 //依然是输入输出挂
    cin &gt;&gt; n &gt;&gt; m;
    //我们令 i 为节点（课程）的编号
    //不妨假定存在一门编号为 0 的课，是所有课程的先修课程且学分为 0
    //这样子我们就可以将所有的课程标在一棵树上
    for (int i = 1; i &lt;= n; i++) //接下来我们从 i = 1 开始读入 n 个节点（课程）
    {
        cin &gt;&gt; fa;           //fa 是节点 i 的父节点（先修课程）的编号
        cin &gt;&gt; f[i][1];      //显然 j == 1 时最大学分就是编号为 i 的这门课本身的学分
        e[i].pre = e[fa].to; //指明节点 i 的兄弟节点是节点 fa 的「第一个」儿子节点
        e[fa].to = i;        //更新节点 fa 的「第一个」儿子节点为节点 i
    }
    dp(0); //从编号为 0 的根节点开始动归
    //输出 0 为根节点，选 m + 1 门课的最大学分
    //m + 1 门课是因为我们无中生有了一门「所有课程的先修课」，也就是编号为 0 的这门课
    cout &lt;&lt; f[0][m + 1] &lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content>
<link rel="replies" type="text/html" href="https://static.bobby285271.top/index.php/2019/12/26/Dynamic-Programming-on-Tree-Structures-Luogu-P2014.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://static.bobby285271.top/index.php/feed/atom/2019/12/26/Dynamic-Programming-on-Tree-Structures-Luogu-P2014.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[Segment Tree (Luogu P3372)]]></title>
<link rel="alternate" type="text/html" href="https://static.bobby285271.top/index.php/2019/12/18/segment-tree.html" />
<id>https://static.bobby285271.top/index.php/2019/12/18/segment-tree.html</id>
<updated>2019-12-18T15:35:00+00:00</updated>
<published>2019-12-18T15:35:00+00:00</published>
<author>
    <name>bobby285271</name>
    <uri>https://static.bobby285271.top</uri>
</author>
<summary type="html"><![CDATA[SCNUACM 新生赛的 C 题被我用 N 方算法水过去了，很惭愧，还是想了解一下正解。当然了，一切的基础，就是熟悉相关的模板咯！题目https://www.luogu.com.cn/probl...]]></summary>
<content type="html" xml:base="https://static.bobby285271.top/index.php/2019/12/18/segment-tree.html" xml:lang="zh-CN"><![CDATA[
<p>SCNUACM 新生赛的 C 题被我用 N 方算法水过去了，很惭愧，还是想了解一下正解。当然了，一切的基础，就是熟悉相关的模板咯！</p><h2>题目</h2><p><a href="https://www.luogu.com.cn/problem/P3372">https://www.luogu.com.cn/problem/P3372</a></p><h2>思路</h2><blockquote>以下内容<strong>仅为个人理解，可能存在错误</strong>。</blockquote><p>显然，对给出的区间中的每一个数逐个加 k（操作 1）或者一个一个数累加下去来求和（操作 2）是会超时的。我们先抛开操作 1 不谈，试想一下对于操作 2，如果我们可以把这个区间分成几个小块，然后又事先知道每一小块中的元素求和的结果，那我求和的时候是不是就不需要算那么多项呢？是不是也就快一点呢？于是就有了分块思想。如果我们把这个思想给贯彻地彻底一些，事先将几个小块拼在一起形成一个大块，又事先算出每一大块中的元素求和的结果，会不会再更快一些呢？以此类推，树形结构就被我们构建出来了。事实上，线段树就是一种二叉树（但不一定是完全二叉树，下面配图就是一个反例，感谢 CGY 提醒）。它的每一个子节点都表示整个序列中的一段子区间，每个叶子节点都表示序列中的单个元素信息，父节点整合了他的每一个子节点的信息。</p><blockquote>有人会问既然是求和，直接前缀和不就好了吗。刚开始我也是这样想的，果然后来我就看到了树状数组的模板，后面也会去试一下。但是上面这个思路可以处理更多的情况，例如我求个最大值最小值我也可以应用。</blockquote><p>假设我的序列已经读入完毕并储存到数组 a 了（这个简单）：</p><pre><code class="lang-cpp">long long a[maxn + 2];
long long n, m;
scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);
for (long long i = 1; i &lt;= n; i++)
    scanf(&quot;%lld&quot;, &amp;a[i]);</code></pre><p>虽然说不一定是完全二叉数，但是可以用<strong>类似于</strong>创建完全二叉树的方式来创建线段树。首先，考虑单个节点。我们使用一个结构体来储存节点的信息，<code>l</code> 和 <code>r</code> 是这个节点维护的区间范围，<code>sum</code> 储存这个区间的和（也就是说 <code>sum</code> 储存了从 <code>a[l]</code> 到 <code>a[r]</code> 所有元素的和）。这里不妨结合图来理解（转载自洛谷）：</p><p><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/xianduanshu.png" alt="" title=""></p><p>接下来我们考虑整棵数。我们使用数组 t 存这颗树，用数组 t 的下标表示每个节点的编号。为什么数组要开数据量的四倍呢，可以通过计算树的高度，然后用等比数列求和公式得出。</p><pre><code class="lang-cpp">struct tree
{
    long long l, r;
    long long sum;
} t[4 * maxn + 2];</code></pre><p>接下来我们就开始建树。自然要从根开始一层一层地建下去。我们整一个建树函数，考虑向它传入三个参数，其中 <code>p</code> 是该节点的编号（其实就是数组 t 的下标），<code>l</code> 和 <code>r</code> 是这个节点维护的区间范围。</p><pre><code class="lang-cpp">void build(long long p, long long l, long long r);</code></pre><p>我们把这个节点建好了之后就去建它的左右儿子两个节点，显然它们的编号是 <code>p * 2</code> 和 <code>p * 2 + 1</code>（还是数组 t 的下标），这两个子节点维护的区间范围自然就要减半了。我们假设 <code>mid = (l + r) / 2</code>，那么就让左儿子维护 <code>l</code> 到 <code>mid</code>，右儿子维护 <code>mid + 1</code> 到 <code>r</code>。</p><p>当然，我们不可能一直建下去，当 <code>l == r</code> 的时候这个节点只维护一个元素，这个元素正正是 <code>a[l]</code>（或者 <code>a[r]</code>）。这时就可以开始求 <code>sum</code> 而无需再往下建树了。你会发现 <code>t[p].sum = a[l];</code>，<code>p</code> 依然是这个节点本身的编号。那么那些 <code>l != r</code> 的节点又怎样计算 <code>sum</code> 呢？就利用上面所说的思想，直接把两个子节点的 <code>sum</code> 加在一起就是自己的 <code>sum</code> 了。</p><pre><code class="lang-cpp">void build(long long p, long long l, long long r)
{
    t[p].l = l;
    t[p].r = r;
    if (l == r)
    {
        t[p].sum = a[l];
        return;
    }
    long long mid = (l + r) / 2;
    build(p * 2, l, mid);
    build(p * 2 + 1, mid + 1, r);
    t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;
}</code></pre><p>让我们在 main 函数中调用这个函数，我们让根节点的编号为 1，按照题意根节点维护的区间范围自然是 <code>l</code> 到 <code>n</code>：</p><pre><code class="lang-cpp">build(1, 1, n);</code></pre><p>好了我们现在再来考虑一下操作 1，操作 1 是否也可以应用类似的思想呢？我们很容易想到一种看起来很简单的方法。同样是将序列分成一个一个的小块，我们直接给整个小块打上一个标签，告诉大家「这个小块里面的元素都应该被加上 k」。而小块中的元素我就干脆不碰它了。于是<strong>懒标签</strong>也就有了。我们在结构体中添加一 <code>lazy</code>，用作这个「标签」。</p><pre><code class="lang-cpp">struct tree
{
    long long l, r;
    long long sum, lazy;
} t[4 * maxn + 2];</code></pre><p>假设我现在让 <code>x</code> 到 <code>y</code> 这个区间的所有元素全部加 z。根据分块思想，我可以拆分这个区间为几个小的区间，使这些小区间的 <code>sum</code> 我都在建树的时候提前算过。我假设其中一个小的区间，也就是刚才建好的树的其中一个节点（假设它的编号为 p）维护的区间范围为 <code>t[p].r</code> 到 <code>t[p].l</code>。我们准备一个函数来处理这件事：</p><pre><code class="lang-cpp">void change(long long p, long long x, long long y, long long z);</code></pre><p>我们直接对 <code>sum</code> 加上「元素个数」个 z，然后打上标签，声明 <code>t[p].r</code> 到 <code>t[p].l</code> 中所有数都应该被加上 z。</p><pre><code class="lang-cpp">t[p].sum += z * (t[p].r - t[p].l + 1);
t[p].lazy += z;</code></pre><p>但是问题也来了，如何正确地<strong>拆分给定区间为几个小的区间</strong>呢。显然我们要让这些<strong>小的区间</strong>的数量尽量少，一个简单粗暴的方法就是：既然我们有一棵树，树上每个节点都有标明它维护的区间范围，我们就从这棵树的根开始，从上往下枚举这些区间，只到找到合适的区间。何为合适？</p><pre><code class="lang-cpp">if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
{
    t[p].sum += z * (t[p].r - t[p].l + 1);
    t[p].lazy += z;
}</code></pre><p>如果条件满足，我们就成功地找到了一个<strong>小的区间</strong>。如果条件不满足，我们还需要继续寻找其它的<strong>小的区间</strong>直到这些小区间拼起来正好是给定的区间。显然一个节点的左儿子和右儿子如果都是上面所说的<strong>合适的</strong>小区间，那么<strong>小的区间</strong>的数量就不是最小了，因为这个节点本身也必然是合适的。于是我们直接考虑下一层的节点。</p><pre><code class="lang-cpp">long long mid = (t[p].l + t[p].r) / 2;
if (x &lt;= mid)
    change(p * 2, x, y, z);
if (y &gt; mid)
    change(p * 2 + 1, x, y, z);</code></pre><p>要注意的是，当子节点的 <code>sum</code> 被改变了，要及时地将变更传递回来。</p><pre><code class="lang-cpp">t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;</code></pre><p>按理来说这个 change 函数我们基本就实现出来了。但是有一个非常坑的地方，就是如果我连续进行多个操作 1，在第一个操作 1 时，我的 <code>t[p].sum</code> 恰好是一个合适的小区间，被修改了，但是 <code>t[p * 2].sum</code> 和 <code>t[p * 2 + 1].sum</code> 是没有变动的，因为变更都被拦截在 <code>t[p].lazy</code> 那里了。在第二个操作 1 时，<code>t[p].sum</code> 可能不是一个合适的小区间，但 <code>t[p * 2].sum</code> 是。<code>t[p * 2].sum</code> 被修改了，而且通过上面这一行代码传了回去。试想一下 <code>t[p].sum</code> 的值是不是会出现错误呢？于是在必要的时候，懒标记储存的更改还是得下放下去。那懒标记存在的意义到底在哪里？要知道的是我下放懒标记仅仅是因为 <code>t[p].sum</code> 不是一个合适的小区间。如果它是的话，这个懒标记还是可以节约时间的。</p><p>懒标记的下放很简单，就是将左右儿子的 <code>sum</code> 和 <code>lazy</code> 给改过来，<strong>把自己的懒标记归零</strong>：</p><pre><code class="lang-cpp">void spread(long long p)
{
    if (t[p].lazy)
    {
        t[p * 2].sum += t[p].lazy * (t[p * 2].r - t[p * 2].l + 1);
        t[p * 2 + 1].sum += t[p].lazy * (t[p * 2 + 1].r - t[p * 2 + 1].l + 1);
        t[p * 2].lazy += t[p].lazy;
        t[p * 2 + 1].lazy += t[p].lazy;
        t[p].lazy = 0;
    }
}</code></pre><p>这样子我们的 change 函数也就完成了！</p><pre><code class="lang-cpp">void change(long long p, long long x, long long y, long long z)
{
    if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
    {
        t[p].sum += z * (t[p].r - t[p].l + 1);
        t[p].lazy += z;
        return;
    }
    spread(p);
    long long mid = (t[p].l + t[p].r) / 2;
    if (x &lt;= mid)
        change(p * 2, x, y, z);
    if (y &gt; mid)
        change(p * 2 + 1, x, y, z);
    t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;
}</code></pre><p>我们回到开头，我们希望让 <code>x</code> 到 <code>y</code> 这个区间的所有元素全部加 z，那么我们来调用这个函数。要让这些<strong>小的区间</strong>的数量尽量少，我们从树根开始查找：</p><pre><code class="lang-cpp">long long q, x, y, z;
scanf(&quot;%lld&quot;, &amp;q);
if (q == 1)
{
    scanf(&quot;%lld%lld%lld&quot;, &amp;x, &amp;y, &amp;z);
    change(1, x, y, z);
}</code></pre><p>那么如果我想求出给定区间的和，按照上面的思想，同样也是<strong>拆分给定区间为几个小的区间</strong>。我们开一个 <code>ans</code> 变量，当找到合适的小区间时就把它的 <code>sum</code> 给累加进去。其实和 change 函数的实现几乎一样。但要注意的是，如果发现有懒标记没有下放而这个区间又不是一个合适的小区间的时候，还是要下放。不然如果它的左右孩子有一个是合适的小区间，累加进去的 <code>sum</code> 就是错的。</p><pre><code class="lang-cpp">long long ask(long long p, long long x, long long y)
{
    if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
        return t[p].sum;
    spread(p);
    long long mid = (t[p].l + t[p].r) / 2;
    long long ans = 0;
    if (x &lt;= mid)
        ans += ask(p * 2, x, y);
    if (y &gt; mid)
        ans += ask(p * 2 + 1, x, y);
    return ans;
}</code></pre><p>在 main 函数里面调用的时候，还是要从树根开始选取合适的小区间。</p><pre><code class="lang-cpp">long long q, x, y;
scanf(&quot;%lld&quot;, &amp;q);
if (q == 2)
{
    scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
    printf(&quot;%lld\n&quot;, ask(1, x, y));
}</code></pre><h2>AC 代码</h2><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const long long maxn = 100010;
long long a[maxn + 2];
struct tree
{
    long long l, r;
    long long sum, lazy;
} t[4 * maxn + 2];

void build(long long p, long long l, long long r)
{
    t[p].l = l;
    t[p].r = r;
    if (l == r)
    {
        t[p].sum = a[l];
        return;
    }
    long long mid = (l + r) / 2;
    build(p * 2, l, mid);
    build(p * 2 + 1, mid + 1, r);
    t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;
}

void spread(long long p)
{
    if (t[p].lazy)
    {
        t[p * 2].sum += t[p].lazy * (t[p * 2].r - t[p * 2].l + 1);
        t[p * 2 + 1].sum += t[p].lazy * (t[p * 2 + 1].r - t[p * 2 + 1].l + 1);
        t[p * 2].lazy += t[p].lazy;
        t[p * 2 + 1].lazy += t[p].lazy;
        t[p].lazy = 0;
    }
}

void change(long long p, long long x, long long y, long long z)
{
    if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
    {
        t[p].sum += z * (t[p].r - t[p].l + 1);
        t[p].lazy += z;
        return;
    }
    spread(p);
    long long mid = (t[p].l + t[p].r) / 2;
    if (x &lt;= mid)
        change(p * 2, x, y, z);
    if (y &gt; mid)
        change(p * 2 + 1, x, y, z);
    t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;
}

long long ask(long long p, long long x, long long y)
{
    if (x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)
        return t[p].sum;
    spread(p);
    long long mid = (t[p].l + t[p].r) / 2;
    long long ans = 0;
    if (x &lt;= mid)
        ans += ask(p * 2, x, y);
    if (y &gt; mid)
        ans += ask(p * 2 + 1, x, y);
    return ans;
}

int main()
{
    long long n, m;
    scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);
    for (long long i = 1; i &lt;= n; i++)
        scanf(&quot;%lld&quot;, &amp;a[i]);
    build(1, 1, n);
    for (long long i = 1; i &lt;= m; i++)
    {
        long long q, x, y, z;
        scanf(&quot;%lld&quot;, &amp;q);
        if (q == 1)
        {
            scanf(&quot;%lld%lld%lld&quot;, &amp;x, &amp;y, &amp;z);
            change(1, x, y, z);
        }
        else
        {
            scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
            printf(&quot;%lld\n&quot;,ask(1, x, y));
        }
    }
    return 0;
}</code></pre>
]]></content>
<link rel="replies" type="text/html" href="https://static.bobby285271.top/index.php/2019/12/18/segment-tree.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://static.bobby285271.top/index.php/feed/atom/2019/12/18/segment-tree.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[SCNUCS-N 2019 Tour]]></title>
<link rel="alternate" type="text/html" href="https://static.bobby285271.top/index.php/2019/12/13/SCNUCS-N-2019-Tour.html" />
<id>https://static.bobby285271.top/index.php/2019/12/13/SCNUCS-N-2019-Tour.html</id>
<updated>2019-12-13T13:10:00+00:00</updated>
<published>2019-12-13T13:10:00+00:00</published>
<author>
    <name>bobby285271</name>
    <uri>https://static.bobby285271.top</uri>
</author>
<summary type="html"><![CDATA[初赛去临时的 OJ 用临时的帐号打临时的比赛（误）感觉有点奇怪，把题目存了一份：https://pan.baidu.com/s/1tLYZA2ssDN2lCqiZWqMGqQ，提取码 jnq2。...]]></summary>
<content type="html" xml:base="https://static.bobby285271.top/index.php/2019/12/13/SCNUCS-N-2019-Tour.html" xml:lang="zh-CN"><![CDATA[
<h2>初赛</h2><blockquote>去临时的 OJ 用临时的帐号打临时的比赛（误）感觉有点奇怪，把题目存了一份：<code>https://pan.baidu.com/s/1tLYZA2ssDN2lCqiZWqMGqQ</code>，提取码 <code>jnq2</code>。</blockquote><p><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/scnuacm19.png" alt="" title=""></p><p>纪录一下第一次，可能也是惟一一次提前半小时 AK。</p><p>问题最多的居然是 A 题签到题，刚开始还想逐个数判断是不是完全平方数。后来想想不就是两个边界开个根号的事嘛。另一个 D 题签到题似乎刚考完三个数的现在才问两个数的。</p><p>异或出了两题很过分，然而一道是去年蓝桥杯热身赛的原题完全不用想，另外一道似乎是防 AK 题我刚开始还试图交个 n 方看看数据强不强。降维好像也不难吧无非是统计下序列中有多少个数转成二进制之后有奇数个一，多少个是偶数个一。奇数个一的数和偶数个一的数异或结果还是奇数个一。有一说一在洛谷看题解骚操作确实学得多，一个 <code>__builtin_popcount</code> 就完事。</p><p>完美数嘛就打表出奇迹。开一个 10000 大的数组把结果先搞出来丢程序里也就代码长了点嘛。于是欢乐数继续打表，还担心溢出加了个 <code>log10</code> 算一下位数。</p><p>至于交换字符那一题题目翻译一下不就是 y 可以随便挪位置嘛，反正无论怎么挪 x 和 z 的相对顺序都不会变，那就将全部 y 全部丢到第一个 z 前面其它原样输出就好了。数据似乎很弱我怀疑我漏了情况但我没有证据。</p><p>下周石牌校区继续白给。</p><h2>决赛</h2><p>第一次是可以带纸质资料进赛场的。刚开始对此是真的毫无头绪，寻思这带过去的要不就是自己早就掌握的，要不就是自己本来就没理解的，那还有什么用。后来也不想考虑太多，去洛谷搜索模板，按照难度排序，从 <code>入门</code> 一直到 <code>提高</code> 只要题目看的懂的就把高赞题解的代码抄下来（还把问题本身也给抄下来了我太机智了）。后来被 CGY 嘲讽了一波（<del>我也想拿区域铜 orz</del>）。周四香农先修班下课后讲课的师兄也提供了一份模板，感觉不会的东西实在太多决定新生赛还是先用自己的。</p><p>C 语言老师那边丧心病狂地周四周五连续上了八节课，于是<del>我也决定要丧心病狂地划水</del>（不是，周五那天上到最后两节笔记本没电就滚去看紫书了<del>虽然依然没学到什么</del> 周六在补各种作业（<del>写到这里，突然想起有个三代单传大锅下周要出 0.1？</del>)。</p><p>比赛当天十点就出发拉到石牌校区了，看时间好像还早就跟着 PYY 去天河城玩去了，靠复印模板还骗到了一顿饭确实香。结果<del>因为校园太大我又路痴</del>还是差点迟到（<del>吹一波南海校区麻雀虽小但五脏俱全</del>）。计科居然还有专门的 ACM 实验室，<del>但比赛现场的机子也确实该升级了，甚至还跑着 Windows XP 系统（没记错的话）</del>。</p><blockquote>题面 PDF 存档：<code>https://pan.baidu.com/s/1CyhXu-0SZ7axguL64xTcwQ</code>（提取码 <code>4ckt</code>）。</blockquote><p>比赛开始前一分钟拿到题面，照例先看 A 题，10 的 100 次方？高精乘除法警告，下一题下一题。相比之下 B 题好像友好很多，差点忘记 d 整除 a 到底是 <code>d % a == 0</code> 还是 <code>a % d == 0</code> 全靠样例解释（不过如果真是前者还做个屁啊）。又是 GCD，交了一发 TLE 开始慌了，马上看榜发现计科已经有人过掉三题了迅速开启根榜模式。发现 J 和 L 题都是良心签到就去秒掉了。然后跑去看 E 题，马上跑去打了个表，我居然从 <code>P == 1</code> 一直打到 <code>P == 63</code>，等了一会不耐烦回到 B 题想起初赛时的 A 题我犯的错误好像一模一样，赶紧开个根号优化一下也过了。表打出来才发现 P 是素数于是又把打出来的数加一 <code>log2</code> 算了一发瞪眼判断是不是素数，筛掉不是的就将题目过了（<del>讲完题解才发现<strong>打个屁的表啊</strong>题面上都有了</del>）。</p><p>接着还是继续跟榜（<del>计科巨佬不带歪榜太良心了</del>），H 不就是 2、3、5 出现的次数分别存一下嘛也没怎么想。F 倒是出问题了，忘记 <code>x % 3 == 0</code> 的情况，又忘记特判 <code>X == 5</code>，吃了两发 WA。终于都过掉之后榜单排前面的神犇过的题似乎都差不多。开始看 C 题和 D 题。D 题又是考异或，想到了要特判 <code>X == 0</code> 忘记特判 <code>X == 1</code>（怎么我每次 WA 都是忘记特判）。C 题看着确实像我带着的线段树模板，但是问的东西和我模板的不一样没法直接套用。<del>当时内心：新生赛哪有可能考这种<strong>鬼东西</strong>。不是前缀和或差分一律当超纲处理。</del>开始 n 方暴力求解，<code>cin</code>、<code>cout</code>、<code>stringstream</code> 全部用上，不出意料 TLE。于是又跳到 I 题，刚开始还想着如果 2、3、5 出现的次数全部符合条件怎样分情况讨论，<strong>讨论个屁</strong>。</p><p>这时候还剩 A、C、G、K 没过，距离封榜时间也不多了。K 题<del>差点又想贪心</del>完再对连续多天刷同一 OJ 的情况作处理，不过状态转移方程好像很好写的样子（有一说一是真的好写，我第一次看洛谷 P1164 那种题时内心是绝望的）。好的还剩三题（<del>ACG 是啥呀我也不知道呀</del>）。</p><p>开始集中火力干 C 题。我当时依然坚信暴力出奇迹，只是出题人想卡常而已。于是 <code>cin</code> 被改成了 <code>scanf</code>，<code>cout</code> 被改成了 <code>printf</code>，<code>stringstream</code> 改成了对十取模再对数除以十一路累加的做法（还得感谢广工的某位<strong>神犇</strong>当时点出来了所以印象非常深刻），本想着如果还过不了就再进一步上快读没想到居然过了。封榜之后看 G 题，考图的题本来是应该直接放弃的。但是我又带了单源最短路径和最小生成树的模板决定还是看一下题吧（<del>其实是因为没得挑了</del>）。发现问法和单源最短路径的好像差不多，就三个区别。一个是有向图变成了无向图，另外一个是指明了终点 t，还有一个是它还需要我回答经过了多少个节点。不管三七二十一把模板打上去了先，发现模板最后会输出到达<strong>每个点</strong>的情况，而我只需要到达<strong>一个点</strong>的情况，换掉就是了。至于每一条无向边我都直接转化成了两条有向边。而经过的点有多少在算距离的时候似乎可以同时算。居然也过了。感觉这次准备模板还是值得的。A 题这边实在能力有限（我觉得哪怕真的把高精写出来想不出正解估计也是得超时）。</p><p>比赛完就去听题解了，师兄讲的飞快，怕是 CGY 速度（<del>只是突然想起了 AK 杯结束后的那个中午</del>）。发现 C 题暴力不是正解刚开始有点幸灾乐祸，后来看滚榜发现靠这题还把计院的 WSD 和 PHS 挤下去了还是感觉自己配不上这个第三名（第一名是打星玩家，第二名是 SJL，感觉都是比我强很多很多很多很多很多的人，毕竟我也只是个暑假才开始入门的萌新），说白了还是时间复杂度没学好（<del>果然无知者无畏</del>）。后来去计院那边的咨询群坦白了自己是暴力过的，出题人验题人反正好多人都主动背锅感觉大家都不容易啊。</p><p>不知什么时候自己才能熟练掌握正解呢，无论是 A 题还是 C 题还是 G 题？靠暴力靠模板确实不是长远之计啊，就说 G 题这回还好只是有向变无向，下一回如果像 LZH 说的那样求第二短的路径？第 N 短的路径？或者 C 题时间限制从 2s 改回 1s？</p><p>完。</p><hr><p>比赛结束后拍了一张自己的座位，那是真的乱得一批。<del>顺便吐槽一句发过来的气球刚开始还是充好气的，后来就不充气直接贴桌子上了，再后来就干脆不发了。</del></p><p><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/817882057.jpg" alt="" title=""></p><p>以及... 第一次看滚榜。</p><p>[vplayer url="https://bobby285271.coding.net/p/img/d/img/git/raw/master/scnuacmrnk.mp4"  /]</p>
]]></content>
<link rel="replies" type="text/html" href="https://static.bobby285271.top/index.php/2019/12/13/SCNUCS-N-2019-Tour.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://static.bobby285271.top/index.php/feed/atom/2019/12/13/SCNUCS-N-2019-Tour.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[Dynamic Prgramming - 0/1 Backpack Problem (Luogu P1164, P1048, P1020)]]></title>
<link rel="alternate" type="text/html" href="https://static.bobby285271.top/index.php/2019/11/17/Dynamic-Prgramming---0-1-Backpack-Problem-Luogu-P1164-P1048-P1020.html" />
<id>https://static.bobby285271.top/index.php/2019/11/17/Dynamic-Prgramming---0-1-Backpack-Problem-Luogu-P1164-P1048-P1020.html</id>
<updated>2019-11-17T15:29:00+00:00</updated>
<published>2019-11-17T15:29:00+00:00</published>
<author>
    <name>bobby285271</name>
    <uri>https://static.bobby285271.top</uri>
</author>
<summary type="html"><![CDATA[为啥突然想要看动态规划呢，是因为昨天做了去年蓝桥杯预选赛 16/17 的题，做到 B 题发现正解其实应该是动态规划的。虽然我交了一发贪心过了，但想到两个星期后就是热身赛还是得搞搞突击才行。引入周...]]></summary>
<content type="html" xml:base="https://static.bobby285271.top/index.php/2019/11/17/Dynamic-Prgramming---0-1-Backpack-Problem-Luogu-P1164-P1048-P1020.html" xml:lang="zh-CN"><![CDATA[
<p>为啥突然想要看动态规划呢，是因为昨天做了去年蓝桥杯预选赛 16/17 的题，做到 B 题发现正解其实应该是动态规划的。虽然我交了一发贪心过了，但想到两个星期后就是热身赛还是得搞搞突击才行。</p><h2>引入</h2><p>周四香农先修班讲了一个斐波拉契数列的专题，有一个问题是这样的：假设有 n 级楼梯，我从底部往上爬，每次可以上 1 级，也可以上 2 级楼梯，问从底部到顶部一共有多少种爬楼梯的方法。</p><p>我第一时间想到的是搜索和回溯，但是既然是斐波拉契数列的专题，也就有了 $f(n) = f(n-1) + f(n-2)$ 这个公式。我简单说一下这个式子是怎么来的吧。我们不妨假设我们走了 x 步之后上到了第 n 级，那我第 x-1 步在什么位置呢？只能是第 n-1 和 n-2 级。$f(n-1)$ 是走到 n-1 级楼梯时的方法数，$f(n-2)$ 同理。考虑一下边界情况，就是斐波拉契数列了呗。</p><h2>P1164 -（二维 DP）</h2><p>题目：<a href="https://www.luogu.org/problem/P1164">https://www.luogu.org/problem/P1164</a></p><p>不妨就来考虑一下「引入」小节的思路（模拟退火是啥我也不会），我们要求吃够 m 块钱，和爬 n 级楼梯其实是一回事。我<strong>上 1 级台阶还是 2 级台阶</strong>，其实和对于一道菜，我<strong>吃还是不吃</strong>是一回事。区别在哪呢，这里我们有很多不同的菜。然而我们也不用想太多，就让它们按顺序逐个上菜好了，然后我们<strong>逐个</strong>决定是吃还是不吃，顺便记下到底花了多少钱<del>（注意上菜不代表我们就要吃嘛对吧，吃了才花钱）</del>。</p><p>我们定义 <code>f[i][j]</code> 为上了 i 道菜用光 j 元钱的办法总数。假设我们现在已经上了 i-1 道菜，接下来上第 i 道菜。我们就有两个选择：</p><ul><li>吃（花钱）。</li><li>不吃（不花钱）。</li></ul><p>如果不吃，那我上 i 道菜用光 j 元钱的方法数，和上了 i-1 道菜用光 j 元钱的方法数一样。如果我吃，那我上 i 道菜用光 j 元钱的方法数，和上了 i-1 道菜用光（j-这道菜的价格）的方法数一样。将两种情况和在一起，于是有：</p><pre><code class="lang-cpp">f[i][j] = f[i - 1][j] + f[i - 1][j - 第i道菜的价格];</code></pre><p>通常来讲这就结束了，但是这道菜的价格我们却没有讨论清楚。首先，如果我没钱吃着道菜呢？那就只能不吃了呗。</p><pre><code class="lang-cpp">if(j &lt; 第i道菜的价格) f[i][j] = f[i - 1][j];
if(j &gt;= 第i道菜的价格) f[i][j] = f[i - 1][j] + f[i - 1][j - 第i道菜的价格];</code></pre><p>有些人想问 <code>j == 第i道菜的价格</code> 这种情况怎么搞，我们将这种情况代入到上面的代码，其实就是 <code>f[i][j] = f[i - 1][j] + f[i - 1][0]</code>，<code>f[i - 1][0]</code> 其实就是上了 i-1 个菜我全不吃，消费 0 元嘛，显然只有一种情况。但形如 <code>f[i][0]</code> 的数据又可以从哪推出呢？不如特判一下，当然直接给他们赋值也是可以的：</p><pre><code class="lang-cpp">if(j &lt; 第i道菜的价格) f[i][j] = f[i - 1][j];
if(j == 第i道菜的价格) f[i][j] = f[i - 1][j] + 1;
if(j &gt; 第i道菜的价格) f[i][j] = f[i - 1][j] + f[i - 1][j - 第i道菜的价格];</code></pre><p>既然有了递推式（状态转移方程），我们要的是上完 n 道菜后花掉 m 块钱的方案，那就遍历一下这个数组直到得出答案为止呗。上代码：</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int a[101], f[101][10001];
int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; i++)
    {
        cin &gt;&gt; a[i];
    }
    for (int i = 1; i &lt;= n; i++)
    {
        for (int j = 1; j &lt;= m; j++)
        {
            if (j &gt; a[i])
                f[i][j] = f[i - 1][j] + f[i - 1][j - a[i]];
            if (j == a[i])
                f[i][j] = f[i - 1][j] + 1;
            if (j &lt; a[i])
                f[i][j] = f[i - 1][j];
        }
    }
    cout &lt;&lt; f[n][m] &lt;&lt; endl;
    return 0;
}</code></pre><h2>P1048（一维 DP）</h2><p>题目：<a href="https://www.luogu.org/problem/P1048">https://www.luogu.org/problem/P1048</a></p><p>这道题按照上面的思路打大概是怎样的呢？<del>显然</del>，我们开一个二位数组 <code>f[i][j]</code> 来表示过目 i 件药材（过目意味着我在采摘和不采摘中二选一）耗去 j 时间后的最大价值就可以了。时间如果足够，就考虑一下要不要采摘这个药材。同样地，<strong>采摘</strong>第 i 件药材耗去 j 时间的这种情况下的最大价值是过目 i-1 件药材时耗去（j-药材采摘时间）时间的最大价值。<strong>不采摘</strong>第 i 件药材耗去 j 时间的这种情况下的最大价值是过目 i-1 件药材时耗去 j 时间的最大价值。对于两种情况我们取较大者即可。</p><p>那我们为啥提出希望降维呢？我们看上面的代码：</p><pre><code class="lang-cpp">if (j &gt; a[i])
    f[i][j] = f[i - 1][j] + f[i - 1][j - a[i]];
if (j == a[i])
    f[i][j] = f[i - 1][j] + 1;
if (j &lt; a[i])
    f[i][j] = f[i - 1][j];</code></pre><p>再来看一下这一题的核心代码（<code>a[i]</code> 为采摘时间，<code>v[i]</code> 为药材价值）：</p><pre><code class="lang-cpp">if (j &gt;= a[i])
    f[i][j] = max(f[i - 1][j - a[i]] + v[i], f[i - 1][j]);
else
    f[i][j] = f[i - 1][j];</code></pre><p>第 i 件物品需要求的信息永远是从第 i-1 件物品那里得出来的。如果我们最后只需要第 i 件物品的答案而不需要 i-1、i-2... 件物品的答案，我们为何不用新的信息覆盖旧的信息呢？修改的方法很简单：</p><pre><code class="lang-cpp">if (j &gt;= a[i])
    f[j] = max(f[j - a[i]] + v[i], f[j]);
// 下面的没必要保留了吧。
// else
//     f[j] = f[j];</code></pre><p>虽然降维了，但遍历还是要以上面的方式来，于是我们就得到一个似乎很有道理的代码。</p><pre><code class="lang-cpp">for (int i = 1; i &lt;= m; i++)
{
    for (int j = a[i]; j &lt;= t; j++) // 既然上面只有一个分支结构，那我在循环条件那里保证就好了。
    {
        f[j] = max(f[j - a[i]] + v[i], f[j]);
    }
}
cout &lt;&lt; f[t] &lt;&lt; endl;</code></pre><p>这却是一个非常典型的错误，因为按照原本的意思，第 i 个物品的数据要从 i-1 个物品的数据推出来，但我在上面求第 i 个物品的 <code>f[j]</code> 的时候却使用到了已经更新过的，已经是第 i 个物品的数据 f[j - a[i]]。怎样避免呢：</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int t, m;
    cin &gt;&gt; t &gt;&gt; m;
    int a[m + 10], v[m + 10];
    for (int i = 1; i &lt;= m; i++)
    {
        cin &gt;&gt; a[i] &gt;&gt; v[i];
    }
    int f[t + 10];
    memset(f, 0, sizeof(f));
    for (int i = 1; i &lt;= m; i++)
    {
        for (int j = t; j &gt;= a[i]; j--)
        {
            f[j] = max(f[j], f[j - a[i]] + v[i]);
        }
    }
    cout &lt;&lt; f[t] &lt;&lt; endl;
    return 0;
}</code></pre><p>附：<a href="https://www.luogu.org/blog/lenfrey/post-ti-xie-p1048-cai-yao">一位神犇提供的题解，感觉比较易懂</a></p><h2>P1020（最大上升子序列）</h2><p>题目：<a href="https://www.luogu.com.cn/problem/P1020">https://www.luogu.com.cn/problem/P1020</a></p><p>第二问知道是求最大上升序列之后就很简单了，最大的问题在于为什么是求这个。试给出以下解释（严格证明需要组合数学的知识）：对于给出的序列（输入数据），必定存在至少一个的最大上升子序列。任取一个最大上升子序列，其中任两个元素（导弹）必定由两套不同系统进行拦截。意味着如果最大上升子序列长度为 n，我们最少需要的系统数目必定大于或等于 n。<br>接下来可以用数学归纳法去解释为什么当最大上升子序列长度为 n 时最少只需要 n 套系统。<br>当 n = 1 时，给出的序列（输入数据）是单调递减的，显然只需要一套系统，结论成立。<br>假设 n = k 时结论成立。也就是只需要 k 套系统。当 n = k + 1 时，试将给出的序列一分为二分别求解，具体方法如下：枚举出所有的最大上升子序列，将每个最大上升子序列的尾元素分别取出。如果某个数是多个最大上升子序列的尾元素则只取出一次。将取出的数按照原本的先后顺序排列生成一个新的序列（假设叫序列 1）。未取出的数也按照原来的先后顺序排列形成另一个新的序列（假设叫序列 2）。<br>此时序列 2 的最大上升子序列长度必定为 k，那么根据前面的假设，需要 k 套系统。而序列 1 是单调递减的（可用反证法证明），由已知需要 1 套系统。所以加起来就是 k + 1 套系统。因为 k + 1 套系统可以拦截所有导弹，而由已知，需要配备的系统数需要大于等于 k + 1，所以 n = k + 1 时结论也成立。</p><p>100 分代码（n 方算法）</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

int a[100005], num = 1;
int ans[100005];
int main()
{
    while (cin &gt;&gt; a[num])
        num++;
    num--;
    a[0] = 50001;
    int maxans = 0;
    for (int i = 1; i &lt;= num; i++)
    {
        for (int j = 0; j &lt; i; j++)
        {
            if (a[i] &lt;= a[j])
            {
                // cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot; &lt;&lt; ans[j] + 1 &lt;&lt; endl;
                ans[i] = max(ans[i], ans[j] + 1);
            }
        }
        // cout &lt;&lt; ans[i] &lt;&lt; endl;
        if (ans[i] &gt; maxans)
            maxans = ans[i];
    }
    cout &lt;&lt; maxans &lt;&lt; endl;

    memset(ans,0,sizeof(ans));
    maxans = 0;
    a[0] = 0;
    for (int i = 1; i &lt;= num; i++)
    {
        for (int j = 0; j &lt; i; j++)
        {
            if (a[i] &gt; a[j])
            {
                // cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot; &lt;&lt; ans[j] + 1 &lt;&lt; endl;
                ans[i] = max(ans[i], ans[j] + 1);
            }
        }
        // cout &lt;&lt; ans[i] &lt;&lt; endl;
        if (ans[i] &gt; maxans)
            maxans = ans[i];
    }
    cout &lt;&lt; maxans &lt;&lt; endl;
    return 0;
}</code></pre><p>200 分代码（nlogn 算法）</p><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int a[100010], b[100010];
int num = 0, p, ans;

bool cmp(int a, int b)
{
    return a &gt; b;
}

int main()
{
    while (cin &gt;&gt; a[num])
        num++;

    ans = 1;
    b[0] = a[0];
    for (int i = 1; i &lt; num; i++)
    {
        if (a[i] &lt;= b[ans - 1]){
            b[ans] = a[i];
            ans++;
        }
        else
        {
            p = upper_bound(b, b + ans, a[i], cmp) - b;
            b[p] = a[i];
        }
    }
    // for (int i = 0; i &lt; ans; i++)
    // {
    //     cout &lt;&lt; b[i] &lt;&lt; &quot; &quot;;
    // }
    // cout &lt;&lt; endl;
    cout &lt;&lt; ans &lt;&lt; endl;

    ans = 1;
    b[0] = a[0];
    for (int i = 1; i &lt; num; i++)
    {
        if (a[i] &gt; b[ans - 1]){
            b[ans] = a[i];
            ans++;
        }
        else
        {
            p = lower_bound(b, b + ans, a[i]) - b;
            b[p] = a[i];
        }
    }
    // for (int i = 0; i &lt; ans; i++)
    // {
    //     cout &lt;&lt; b[i] &lt;&lt; &quot; &quot;;
    // }
    // cout &lt;&lt; endl;
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}</code></pre>
]]></content>
<link rel="replies" type="text/html" href="https://static.bobby285271.top/index.php/2019/11/17/Dynamic-Prgramming---0-1-Backpack-Problem-Luogu-P1164-P1048-P1020.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://static.bobby285271.top/index.php/feed/atom/2019/11/17/Dynamic-Prgramming---0-1-Backpack-Problem-Luogu-P1164-P1048-P1020.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[How to Launch a Desktop Environment on WSL 2]]></title>
<link rel="alternate" type="text/html" href="https://static.bobby285271.top/index.php/2019/10/05/How-to-Launch-a-Desktop-Environment-on-WSL-2.html" />
<id>https://static.bobby285271.top/index.php/2019/10/05/How-to-Launch-a-Desktop-Environment-on-WSL-2.html</id>
<updated>2019-10-04T16:00:00+00:00</updated>
<published>2019-10-04T16:00:00+00:00</published>
<author>
    <name>bobby285271</name>
    <uri>https://static.bobby285271.top</uri>
</author>
<summary type="html"><![CDATA[WSL 2 是 WSL 中体系结构的新版本，它改变了 Linux 发行版与 Windows 交互的方式。WSL 2 的主要目标是提高文件系统性能并增加系统调用的完全兼容性。 每个 Linux 发...]]></summary>
<content type="html" xml:base="https://static.bobby285271.top/index.php/2019/10/05/How-to-Launch-a-Desktop-Environment-on-WSL-2.html" xml:lang="zh-CN"><![CDATA[
<p>WSL 2 是 WSL 中体系结构的新版本，它改变了 Linux 发行版与 Windows 交互的方式。<br>WSL 2 的主要目标是提高文件系统性能并增加系统调用的完全兼容性。 每个 Linux 发行版都可以作为 WSL 1 或 WSL 2 发行版运行，并可随时进行切换。<br>WSL 2 是底层体系结构的主要功能，它使用虚拟化技术和 Linux 内核来实现其新功能。</p><h2>准备</h2><p>为了使用 WSL 2，你需要 <strong>Windows 10 内部版本 18917 或更高版本</strong>。要想了解目前使用的版本是什么，可以到设置页面查看。<br><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/wsl2/0.PNG" alt="" title=""></p><p>首先，右击任务栏 Windows 图标，选择 Windows Powershell（管理员），输入以下命令：</p><pre><code>Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform
Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</code></pre><p>或者前往控制面板 - 程序 - 启用或关闭 Windows 功能，然后勾选<strong>虚拟机平台</strong>和<strong>执行 Linux 程序的 Windows 子系统</strong>。<br><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/wsl2/" alt="" title=""></p><p>完成设置后需要重启计算机！</p><h2>安装</h2><p>前往 Microsoft Store 下载并安装 Ubuntu。<br><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/wsl2/2.PNG" alt="" title=""></p><p>接下来使 WSL 2 成为你的默认体系结构。打开 Windows Powershell 或命令提示符：</p><pre><code>wsl --set-default-version 2</code></pre><p>接下来在开始菜单找到 Ubuntu，点击后稍作等候。当一切准备好后，Ubuntu 会提示你新建一个账户和密码，注意输入密码时是不会有回显的。<br><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/wsl2/5.PNG" alt="" title=""></p><p>此时你可以验证刚刚安装好的 Ubuntu 所使用的 WSL 版本：</p><pre><code>wsl --list --verbose</code></pre><p><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/wsl2/6.PNG" alt="" title=""></p><p>如果你在 Windows Powershell 或命令提示符下运行 <code>wsl</code>，同样也是可以进入 WSL 环境的。</p><h2>软件</h2><p>切换到 Root：</p><pre><code>$ sudo -i</code></pre><p>编辑 APT 软件源（<code>nano</code> 大法好，不接受反驳） ：</p><pre><code># nano /etc/apt/sources.list</code></pre><pre><code>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</code></pre><p>更新可用软件包列表，随后升级系统：</p><pre><code># apt update &amp;&amp; apt dist-upgrade -y</code></pre><p>安装基本开发环境、Xubuntu 桌面和远程桌面支持：</p><pre><code># apt install build-essential xubuntu-desktop xrdp</code></pre><p><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/wsl2/11.PNG" alt="" title=""></p><p>安装的软件包比较多，可能要等上一段时间。这里的 Xubuntu 桌面实际为 XFCE 桌面环境，换成别的问题不大但还是建议选择轻量级桌面。</p><p>保存 Xsession 配置：</p><pre><code># exit #切换回普通用户。
$ echo xfce4-session &gt; ~/.xsession</code></pre><h2>远程桌面</h2><blockquote>需要使用远程桌面时均要执行本节内容。</blockquote><p>启用 Xrdp 服务（这里不能使用 <code>systemctl</code>，因为 SystemD 不是默认的 Init 系统），记录端口信息：</p><pre><code>$ sudo service xrdp start</code></pre><p>在 Windows 开始菜单栏中找到 Windows 附件 - 远程桌面连接，输入 <code>localhost:端口</code>，如 <code>localhost:3389</code>。</p><p>应该会出现如下警告，选择是即可：<br><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/wsl2/16.PNG" alt="" title=""></p><p>如果你没有看到这个警告，可能需要查找虚拟机的 IP 地址并替代 <code>localhost</code> 再试一次：</p><pre><code>$ ip address</code></pre><p><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/wsl2/13.PNG" alt="" title=""></p><p>在这里，IP 地址查找到是 <code>172.18.221.157</code>，端口是 <code>3389</code>。注意每次重启 WSL 实例后这个 IP 地址都会换。</p><p>输入 <code>IP 地址:端口</code>，如 <code>172.18.221.157:3389</code>。</p><p>接下来输入自己的账户密码：<br><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/wsl2/17.PNG" alt="" title=""></p><p>然后就是很熟悉的界面了：<br><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/wsl2/18.PNG" alt="" title=""></p><h2>本地化</h2><p>直接在终端下就可以完成设置了（以下命令在 Root 下运行）：</p><pre><code># dpkg-reconfigure locales</code></pre><p>确认 <code>en_US.UTF-8 UTF-8</code> 和 <code>zh_CN.UTF-8 UTF-8</code> 被勾选，然后将 <code>zh_CN.UTF-8 UTF-8</code> 设定为默认值。<br><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/wsl2/19.PNG" alt="" title=""></p><p>然后安装语言包和输入法（按理来说装完就能用）：</p><pre><code># apt install language-pack-zh-hans language-pack-gnome-zh-hans fcitx fcitx-table</code></pre><h2>彩蛋</h2><p>Windows 应用能访问 Linux 根文件系统啦，包括文件资源管理器！尝试在 WSL 中使用普通用户运行 <code>explorer.exe .</code>（在远程桌面会话中这样做是没有用滴！），看看会发生什么。</p><p>另外内部错误大法又怎能缺席呢（逃）。<br><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/wsl2/20.PNG" alt="" title=""></p>
]]></content>
<link rel="replies" type="text/html" href="https://static.bobby285271.top/index.php/2019/10/05/How-to-Launch-a-Desktop-Environment-on-WSL-2.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://static.bobby285271.top/index.php/feed/atom/2019/10/05/How-to-Launch-a-Desktop-Environment-on-WSL-2.html" thr:count="0"/>
</entry>
</feed>