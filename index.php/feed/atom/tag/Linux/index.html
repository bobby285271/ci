<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"
xmlns:thr="http://purl.org/syndication/thread/1.0"
xml:lang="zh-CN"
xml:base="https://static.bobby285271.top/index.php/tag/Linux/"
>
<title type="text">Dasyatis - Linux</title>
<subtitle type="text"></subtitle>
<updated>2020-04-14T16:00:00+00:00</updated>
<generator uri="http://typecho.org/" version="1.2/18.1.29">Typecho</generator>
<link rel="alternate" type="text/html" href="https://static.bobby285271.top/index.php/tag/Linux/" />
<id>https://static.bobby285271.top/index.php/feed/atom/tag/Linux/</id>
<link rel="self" type="application/atom+xml" href="https://static.bobby285271.top/index.php/feed/atom/tag/Linux/" />
<entry>
<title type="html"><![CDATA[NixOS Installation and Configuration Guide]]></title>
<link rel="alternate" type="text/html" href="https://static.bobby285271.top/index.php/2020/04/15/NixOS-Installation-and-Configuration-Guide.html" />
<id>https://static.bobby285271.top/index.php/2020/04/15/NixOS-Installation-and-Configuration-Guide.html</id>
<updated>2020-04-14T16:00:00+00:00</updated>
<published>2020-04-14T16:00:00+00:00</published>
<author>
    <name>bobby285271</name>
    <uri>https://static.bobby285271.top</uri>
</author>
<summary type="html"><![CDATA[本文基于 NixOS 20.03 Beta 和 NixOS Manual 20.03 撰写。本文的写作缘由是 NixOS Manual 的编排设计很容易导致习惯了其它发行版安装和配置流程的新人入...]]></summary>
<content type="html" xml:base="https://static.bobby285271.top/index.php/2020/04/15/NixOS-Installation-and-Configuration-Guide.html" xml:lang="zh-CN"><![CDATA[
<p>本文基于 NixOS 20.03 Beta 和 <a href="https://nixos.org/nixos/manual/">NixOS Manual 20.03</a> 撰写。本文的写作缘由是 NixOS Manual 的编排设计很容易导致习惯了其它发行版安装和配置流程的新人入坑失败。本篇指南给出的解决方案基本能满足<strong>大一软工专业课程学习</strong>和<strong>日常使用</strong>的需要。</p><p><strong>本文将假定你已经独立安装和配置过 Arch Linux、Gentoo 或任一官方不提供 GUI 安装程序的 Linux 发行版并掌握安装过程中涉及的大部分命令。</strong></p><h2>了解 NixOS</h2><p><a href="https://distrowatch.com/table.php?distribution=nixos">可以先从 DistroWatch 开始了解 NixOS 这个发行版</a>，<a href="https://nixos.org/nixos/about.html">接下来建议阅读 NixOS 官方的介绍</a>。有一个不太恰当的比喻，NixOS 相对于其它发行版有点像使用 Git + Markdown + Hexo 相对于无版本管理 + 手撸 HTML 文件，<a href="https://nixos.wiki/wiki/NixOS#Comparison_with_traditional_Linux_Distributions">NixOS Wiki 也给出了 NixOS 和其它发行版的最大区别所在</a>。而这一切实现的基础是 <strong>Nix</strong>，事实上 NixOS 中所有软件包（<strong>Nixpkgs</strong>）和系统配置都由 Nix 管理。要想了解 Nix，<a href="https://www.zhihu.com/question/279855101/answer/475896416">建议阅读 dram 大佬在知乎相关问题下的回答</a>。dram 是 TUNA 镜像站镜像 NixOS / Nix / Nixpkgs 的主要推动者之一。至于 NixOS 是否适合你，<a href="https://zhuanlan.zhihu.com/p/50623869">可以阅读这篇文章自行判断</a>。</p><h2>准备工作</h2><p>准备好安装 NixOS 了？让我们开始吧。前期的准备工作包括：数据备份、下载镜像、将镜像写入 U 盘、引导安装介质、连接到网络、建立分区、格式化分区、挂载分区，<strong>这一部分和其它（不带 GUI 安装程序的）Linux 发行版的安装几乎是一样的</strong>，这里不会细讲。</p><p>2020 年 3 月后清华镜像站就有 Nix / NixOS / Nixpkgs 的镜像了，<a href="https://mirrors.tuna.tsinghua.edu.cn/nixos-images/">NixOS 的安装介质可在这里下载</a>，建议选带桌面环境的镜像（可以通过文件名判断）。将写入 U 盘可以使用 <code>dd</code> 命令，具体用法（<code>path-to-image</code> 是 NixOS 安装介质的路径，<code>/dev/sdX</code> 则是写入目标）：</p><pre><code>sudo dd if=path-to-image of=/dev/sdX
</code></pre><p>引导安装介质后，按照 <code>/etc/issue</code> 的提示操作即可进入桌面环境（启动登录管理器），注意默认搭载的账户 <code>nixos</code> 和 <code>root</code> 都没有密码：</p><pre><code>sudo systemctl start display-manager
</code></pre><p>因为在线安装，联网是必须的。通常情况使用 NetworkManager 联网即可，<a href="https://nixos.org/nixos/manual/index.html#sec-installation-booting-networking">当然这里还有其它的联网方式</a>。</p><p>可选的分区工具除了熟悉的 GDisk 和 GNU Parted 这些 CLI 的分区工具之外，还有 GUI 的分区工具 GParted。<a href="https://nixos.org/nixos/manual/index.html#sec-installation-partitioning">NixOS Manual 对在命令行下分区做了详细的介绍</a>，<a href="https://nixos.org/nixos/manual/index.html#sec-installation-summary">还配有不少的例子</a>，<a href="https://wiki.archlinux.org/index.php/Partitioning">可以配合 ArchWiki 的相关文章进行阅读</a>。因为 Nix 并不会自动删除历史的软件包安装，<strong>根目录尽可能分大一些</strong>，否则随着时间推移 <code>/nix</code> 可能会占用较大空间。<strong>除了 Home 和 EFI 分区之外不建议（也没必要）设置独立分区</strong>。<strong>另外 NixOS 的回滚功能是由 Nix 实现的，和 Btrfs 无关</strong>，如果你选择 Btrfs 仅仅是因为它的快照特性，那么没有必要给根分区使用 Btrfs。</p><p>格式化分区之后就可以挂载分区了。分区应该挂载到 <code>/mnt</code> 下，例如根分区就挂载到 <code>/mnt</code>，Home 分区则 <code>/mnt/home</code>。<strong>特别留意 NixOS 下 EFI 分区应该挂载到 <code>/mnt/boot</code>。</strong>Swap 分区使用 <code>swapon</code> 启用即可。</p><h3>初始化 NixOS 配置文件</h3><p>接下来就是后期的准备工作了。事实上，如果你点开了前面的几个链接，你会发现 <code>/etc/nixos/configuration.nix</code> 是整个系统的灵魂所在。你的系统<strong>全局搭载</strong>的软件包和系统配置都取决于这个文件。<a href="https://linux.cn/article-8976-1.html">因此我们说这个发行版是「先配置后安装」的</a>。</p><p><strong>所以接下来的主要任务，就是配置 <code>configuration.nix</code>，这个文件会一直伴随着你的系统。</strong>一旦配置完成，你会使用到 <code>nixos-install</code> 脚本，这个脚本会读取这个文件，并调用 Nix 让其根据这个文件「造出对应的系统来」。而在安装好 NixOS 之后，你可以随时改动 <code>configuration.nix</code> 这个文件，然后使用 <code>nixos-rebuild</code> 脚本，这个脚本同样也是调用 Nix，让 Nix <strong>处理所有的变化</strong>，以「造出对应的系统来」。「造出来的系统」会<strong>和当前系统的状态无关</strong> 。这两个脚本笔者在后面会介绍其用法。</p><p>当然了，如果在 Live 环境里面直接编辑 <code>/etc/nixos/configuration.nix</code>，打开的是 Live 环境的配置文件。而现在我们需要为新的系统创建一个默认的 NixOS 的配置文件，在进入新系统之前，应该通过 <code>/mnt</code> 访问其文件<strong>（本文后续的命令，除非特别注明，否则一律需要在 <code>root</code> 账户下执行，可以使用 <code>su</code> 命令从普通用户切换到 <code>root</code> 账户）</strong>：</p><pre><code>nixos-generate-config --root /mnt
</code></pre><p>运行这个命令之后，<code>/mnt/etc/nixos/</code> 目录会被创建，里面会放置自动生成的两个文件：<code>configuration.nix</code> 和 <code>hardware-configuration.nix</code> 。我们待会再看 <code>hardware-configuration.nix</code>，先看看前面已经提到无数次的 <code>configuration.nix</code>，<a href="https://paste.ubuntu.com/p/JHsyTczk3m/">这个文件在 NixOS 20.03 下默认长这样</a>。当然了，在你安装系统之后，可以使用 <code>nixos-generate-config --force</code> 重新生成一个 <code>configuration.nix</code>。</p><h3>初识 <strong>NixOS 模块</strong></h3><p>让我们来打开 <code>configuration.nix</code> 这个文件：</p><pre><code>nano /mnt/etc/nixos/configuration.nix
</code></pre><p>以 <code>#</code> 开头的都是注释，我们先不要管注释，看看没有注释的内容。实际上，这是一个简化的 <strong>NixOS 模块</strong>（NixOS Module）。我们尝试分析一下它的结构：</p><pre><code>{ config, pkgs, ... }:

{
    imports = [
        ./hardware-configuration.nix
    ];
    boot.loader.systemd-boot.enable = true;
    boot.loader.efi.canTouchEfiVariables = true;
    networking.useDHCP = false;
    networking.interfaces.docker0.useDHCP = true;
    networking.interfaces.wlo1.useDHCP = true;
    system.stateVersion = &quot;20.03&quot;;
}
</code></pre><p>第一行的 <code>{ config, pkgs, ... }:</code> 表示这是一个至少接受两个参数 <code>config</code> 和 <code>pkgs</code> 的函数。<code>config</code> 主要用于在多个 NixOS 模块的情形下<strong>引用</strong>其它模块定义的配置值，<a href="https://nixos.org/nixos/manual/index.html#sec-modularity">这里有相关的例子</a>，可以说是引入了完整的系统配置。<code>pkgs</code> 主要用于引用 Nixpkgs 中的软件包，例如 <code>pkgs.fcitx</code>。<strong>当然我们现在简单地认为第一行就是要这样写的好了</strong>，即使在本文中不会使用到 <code>config</code>。说实话在第一次接触 C++ 时对着 <code>using namespace std;</code> 自闭了半天，其实到后面需要到名称空间的时候自然就懂了。</p><p><code>imports</code> 导入了其它的 NixOS 模块，这里它导入了 <code>./hardware-configuration.nix</code>。另外 <code>modules/module-list.nix</code> 里面定义了一系列的模块，<strong>这些模块会被自动导入</strong>。<code>modules/module-list.nix</code> 的绝对路径是啥呢，可以看回 <a href="https://nixos.org/nixos/about.html">NixOS 官方的介绍</a>，阅读 <code>How does NixOS work?</code>，你会发现 <code>/nix/store/</code> 下的目录都带上了 Hash 值，这是为了避免新的安装覆盖旧的安装（便于需要的时候回滚啊！事实上这也是开始时我说根目录尽可能分大一些的原因，后面会提供旧安装清理的方法）。所以要想找到这个 <code>modules/module-list.nix</code>，不妨用点小技巧：</p><pre><code>find / | grep &quot;modules/module-list.nix&quot;
</code></pre><p><code>cat</code> 查看相应的文件就可以看到这个列表了，事实上还真导入了不少的 NixOS 模块。当然我们现在先打开 <code>hardware-configuration.nix</code> 看看（要注意上面的 <code>./hardware-configuration.nix</code> 是相对于 <code>/mnt/etc/nixos/configuration.nix</code> 的路径）：</p><pre><code>cat /mnt/etc/nixos/hardware-configuration.nix
</code></pre><p>你会发现上面记录了你的分区信息，<strong>如果不是那就是你分区过程中出了差错</strong>，可以调整分区后按照上面的步骤重新 <code>nixos-generate-config</code>。这个文件将用于生成 Fstab 等文件。这个文件被单独分出来原因也是为了避免错误地编辑了这个文件。<strong>事实上 NixOS 官方只建议使用 <code>nixos-generate-config</code> 更新这个文件。</strong></p><p>接下来我们来看 <code>configuration.nix</code> 剩余的部分。这些行的格式都是 <code>name = value</code>，我们称这是定义（<strong><em>define</em></strong>）操作。我们称 <code>configuration.nix</code> 为简化的 NixOS 模块，<strong>原因是它只有定义操作</strong>。事实上还有声明（<strong><em>declare</em></strong>）操作，这一个一个的 <code>name</code> 其实在其它文件声明过，这样才可以被定义。笔者接下来会详细介绍定义操作和声明操作，如果想要深入了解 NixOS 模块，<a href="https://nixos.org/nixos/manual/index.html#sec-writing-modules">可以查看这里</a>。</p><h3>定义操作</h3><p>我们来继续来研究上面 <code>configuration.nix</code> 涉及到的 Nix 表达式：</p><pre><code>boot.loader.systemd-boot.enable = true;
boot.loader.efi.canTouchEfiVariables = true;
</code></pre><p>我们已经知道它们格式都是 <code>name = value</code>，进一步分析它的结构，这两个表达式中我们把 <code>boot</code>、<code>loader</code>、<code>systemd-boot</code> 还有 <code>efi</code> 称之为集合（_<strong>set</strong>_），把 <code>enable</code> 和 <code>canTouchEfiVariables</code> 称为选项（_<strong>option</strong>_），把 <code>true</code> 称为值（<strong><em>value</em></strong>）。<strong>一个集合里面可能有子集合，也有可能有选项，我们给选项定义值。</strong>集合与子集合、集合与选项之间可以像上面一样，使用 <code>.</code> 连接。同时也可以使用下面的使用花括号嵌套的方式（<strong>注意分号出现的位置</strong>）：</p><pre><code>boot = {
    loader = {
        systemd-boot = {
            enable = true;
        };
        efi = {
            canTouchEfiVariables = true;
        };
    };
};
</code></pre><p>当然了可以两种方式混合使用：</p><pre><code>boot = {
    loader.systemd-boot = {
        enable = true;
    };
    loader = {
        efi.canTouchEfiVariables = true;
    };
};
</code></pre><p>如果是还有疑问的，<a href="https://nixos.org/nixos/manual/index.html#sec-configuration-syntax">NixOS Manual 给出了更多的相关例子</a>。至于是使用花括号还是半角句号，我认为不重要。但在我看来，<strong>如果有两个选项它们属于同一个集合，它们应该尽量在一起被定义</strong>，而不是一个在文件开头定义，一个在文件末尾定义。<strong>同一集合的两个选项会有一定的关联性，放在一起可以更好地维护。</strong></p><p>当然了，当配置文件足够复杂之后，还可以像 <code>hardware-configuration.nix</code> 一样将一部分拆分出来，在 <code>imports</code> 部分导入相关文件，这里就不细讲了。</p><p>至于 <code>value</code>，上面的给出的 <code>configuration.nix</code> 中涉及到的值有 <code>true</code>、<code>false</code>、<code>&quot;20.03&quot;</code>。和其它编程语言的数据类型类似，我们称 <code>true</code> 和 <code>false</code> 是<strong>布尔值</strong>，称 <code>”20.03&quot;</code> 是<strong>字符串</strong>（注意两个引号），每一个 <code>name</code> 都有对应的可接受的类型。是事实上，对于其它的选项，可以接受的值的类型也有可能是列表、浮点数、软件包等等。<a href="https://nixos.org/nixos/manual/index.html#sec-configuration-file">这里详细地介绍了 <code>value</code> 的各种类型</a>，并给出了相关的例子。</p><p>这里问题就来了，怎样知道在一个 NixOS 系统中我有哪些 <code>name</code> 可以用呢？这些 <code>name</code> 又接受那些 <code>value</code> 呢？让我们继续来了解「声明操作」。</p><h3>声明操作</h3><p>和其它编程语言类似，<strong>声明就是要告诉人家我叫啥、我接受什么样的 <code>value</code>。</strong>怎样查看一个 <code>name</code> 的声明呢？第一个方法是<strong>使用命令 <code>nixos-option</code></strong>，例如我要查看 <code>system.stateVersion</code> 的声明：</p><pre><code>nixos-option system.stateVersion
</code></pre><p>这个是在我系统上的输出，当然了在 Live 环境下输出不一定相同：</p><pre><code>Value:
&quot;20.03&quot;

Default:
&quot;20.03&quot;

Type:
&quot;string&quot;

Description:
''
    Every once in a while, a new NixOS release may change
    configuration defaults in a way incompatible with stateful
    data...（后面的省略）
''

Declared by:
[ &quot;/nix/var/nix/profiles/per-user/root/channels/nixos/nixos/modules/misc/version.nix&quot; ]

Defined by:
[ &quot;/etc/nixos/configuration.nix&quot; ]

</code></pre><p>我们会看到 <code>system.stateVersion</code> 在 <code>/nix/var/nix/profiles/per-user/root/channels/nixos/nixos/modules/misc/version.nix</code> 声明过，而笔者刚开始的时候说过 <code>configuration.nix</code> 会自动导入 <code>modules/module-list.nix</code> 里包含的所有文件，里面就有 <code>version.nix</code>，因此我们才可以在 <code>/etc/nixos/configuration.nix</code> 定义它。另外我们也能得到其它有用的信息，例如它接受一个字符串作为它的值，<code>system.stateVersion</code> 默认定义的值是 <code>&quot;20.03&quot;</code>，事实上这些信息就是在声明它的时候提供的。</p><p>我们打开这个 <code>version.nix</code>，这就是一个声明的真面目了：</p><pre><code>options.system = {
    stateVersion = mkOption {
        type = types.str;
        default = cfg.release;
        description = ''
            Every once in a while, a new NixOS release may change
            configuration defaults in a way incompatible with stateful
            data...（后面的省略）
        '';
    };
};
</code></pre><p>当然笔者在本文中并不会要求用户创建一个声明。但我们还是会继续探究这个文件，我们发现 <code>version.nix</code> 给多个选项提供了声明，例如 <code>system.nixos.release</code>、<code>system.nixos.codeName</code> 等等。</p><p>我们接着再往下翻一点：</p><pre><code>config = {
    system.nixos = {
        version = mkDefault (cfg.release + cfg.versionSuffix);
    };

    # Generate /etc/os-release.
    environment.etc.os-release.text = ''
        NAME=NixOS
        ID=nixos
        VERSION=&quot;${cfg.version} (${cfg.codeName})&quot;
        VERSION_CODENAME=${toLower cfg.codeName}
        VERSION_ID=&quot;${cfg.version}&quot;
        PRETTY_NAME=&quot;NixOS ${cfg.release} (${cfg.codeName})&quot;
        LOGO=&quot;nix-snowflake&quot;
        HOME_URL=&quot;https://nixos.org/&quot;
        DOCUMENTATION_URL=&quot;https://nixos.org/nixos/manual/index.html&quot;
        SUPPORT_URL=&quot;https://nixos.org/nixos/support.html&quot;
        BUG_REPORT_URL=&quot;https://github.com/NixOS/nixpkgs/issues&quot;
    '';
};
</code></pre><p>你会在里面找到 <code>${cfg.version}</code> 和 <code>${cfg.codeName}</code>。<code>cfg</code> 是什么呢，我们回到文件开头：</p><pre><code>{ config, lib, pkgs, ... }:

with lib;

let
    cfg = config.system.nixos;
in
{
    ...
}
</code></pre><p>还记得 <code>config</code> 是啥吗？我们说它引入了完整的系统配置。现在，即使我没有告诉你 <code>environment.etc.os-release.text</code> 是个啥，相信你也能猜出来，Nix 使用了 <code>system.nixos.release</code>、<code>system.nixos.codeName</code> 创建了 <code>/etc/os-release</code> 这个文件。至于前面提到的 <code>system.stateVersion</code> 呢，则被用于其它的地方了（毕竟有了 <code>config</code>，我们在任何地方都可以引用它）。<strong>事实上，就是这样声明和定义一个又一个的选项，组成了最终的系统。</strong></p><p>关于怎样查看一个 <code>name</code> 的声明，<a href="https://nixos.org/nixos/options.html#">第二个方法是<strong>使用 NixOS Options 网页</strong></a>。输入 <code>name</code> 同样可以查看到使用 <code>nixos-options</code> 能看到的内容。<strong>关键是它还非常适合给我们模糊搜素用。</strong>另外点击 <code>Declared in</code> 旁边的超链接，会跳转到 GitHub 的 NixOS/nixpkgs 仓库。例如说我们查找 <code>system.stateVersion</code>，<a href="https://github.com/NixOS/nixpkgs/blob/master/nixos/modules/misc/version.nix">我们会被带到这里</a>。同样也可以查看 <code>version.nix</code> 文件，还可以切换 Git 分支查看不同 NixOS 版本下这个文件的历史状态。我们在后面会经常使用到 NixOS Options 网页和 <code>nixos-option</code> 命令。</p><h2>开始编辑 <code>configuration.nix</code></h2><p>讲了这么多，让我们尝试把刚刚学到的东西应用到实际当中吧！接下来我们要写很多很多的 <code>name = value</code> 表达式。我们已经知道，当我们有一个需求，我们可以尝试去 NixOS Options 进行模糊搜索，看看有没有对应的选项。此外，我们多次提到的 NixOS Manual 提供了很多的常见需求对应的解决方案。这里还会另外推荐一些寻找解决方案的地方：</p><ul><li><a href="https://nixos.org/nixos/manual">NixOS Manual</a> - NixOS 官方文档值得阅读值得信赖。</li><li><a href="https://nixos.org/nixos/options.html">NixOS Options</a> - 列出了所有可用的选项、其声明、可以接受的值。</li><li><a href="https://discourse.nixos.org/">NixOS Discourse Forum</a> - 用户论坛，有官方开发者答疑。</li><li><a href="https://nixos.org/nixos/packages.html">NixOS Packages</a> - 列出了所有可用的 Nixpkgs 软件包。</li><li><a href="https://nixos.wiki/">NixOS Wiki</a> - 社区维护的维基。</li><li><a href="https://github.com/">GitHub</a> - 查看其它用户的配置，或查看官方的 NixOS/nixpkgs 仓库。</li><li><a href="https://stackoverflow.com/questions/tagged/nixos">Stack Overflow</a> - 查看打有 <code>nixos</code> 标签的问题和回答。</li><li>各大搜索引擎 - 这个也不用我多说吧……</li></ul><p>当然了，如果实在找不到，可以去 <a href="https://discourse.nixos.org/">NixOS Discourse Forum</a> 提问，因为官方开发者在这个论坛非常活跃，很多问题都能在短时间内得到答案。</p><p>要注意的是，因为 <code>configuration.nix</code> 会一直伴随着你的 NixOS 安装，所以这个章节既适用于安装时进行初始化配置，也适用于安装后的日常维护进行配置。下面结合两个自认为比较实际的需求来展开介绍，我会着重说明我是<strong>如何找到</strong>解决方案的，希望能给到大家一些帮助。</p><h3>桌面环境</h3><p>会发现 NixOS Manual 有多个对应的章节，<a href="https://nixos.org/nixos/manual/index.html#sec-x11">有讲 X11 的</a>，<a href="https://nixos.org/nixos/manual/index.html#chap-pantheon">有专门讲 Pantheon 桌面环境的</a>，<a href="https://nixos.org/nixos/manual/index.html#sec-xfce">有专门讲 XFCE 桌面环境的</a>。个人非常喜欢 Pantheon，我们也知道 X11 是一切桌面环境的基础（假设我们把 Wayland 忽略掉）。我们来看看 X11。首先看到的是这样一句：</p><p>The X Window System (X11) provides the basis of NixOS’ graphical user interface. It can be enabled as follows:</p><pre><code>services.xserver.enable = true;
</code></pre><p>看上去是不是很熟悉？事实上默认的 <code>configuration.nix</code> 里面已经有了这样的一行，只是被注释掉了。上面还配有注释 <code>Enable the X11 windowing system.</code> 让我们取消注释 <code>services.xserver.enable = true;</code>。</p><p>搞定！就这么简单。先继续看看 Pantheon 桌面对应的章节。根据 NixOS Manual，要想使用 Pantheon 桌面，需要在 <code>configuration.nix</code> 加入：</p><pre><code>services.xserver.desktopManager.pantheon.enable = true;
</code></pre><p>这也很简单，复制粘贴过去就完成了，搞定！在 <code>configuration.nix</code> 加入这个 Nix 是怎样处理的呢？还记得前面提到的 <code>system.nixos.release</code>、<code>system.nixos.codeName</code>和 <code>/etc/os-release</code> 吗？可以按照当时我所给的思路一探究竟，我们在后面揭晓。</p><h3>软件包</h3><p><a href="https://nixos.org/nixos/manual/index.html#sec-declarative-package-mgmt">会发现 NixOS Manual 有对应的章节</a>。它的要求是定义 <code>environment.systemPackages</code> 这个选项。它给出的例子是这样的：</p><pre><code>environment.systemPackages = [ pkgs.thunderbird ];
</code></pre><p>感觉有点迷？那不妨前往 <a href="https://nixos.org/nixos/options.html#environment.systempackages">NixOS Options</a> 查找 <code>environment.systemPackages</code>，这时就应该知道它要求你提供 <code>list of packages</code>。我们回到 <a href="https://nixos.org/nixos/manual/index.html#sec-configuration-file">NixOS Manual</a>，查看 Package 小节。这时就可以大致推断出这个 <code>name</code> 怎么填了。</p><p><a href="https://github.com/search?l=Nix&q=environment.systemPackages&type=Code">接下来我们去 GitHub 参考一下别人的配置文件</a>，注意语言要选择 Nix，关键字将 Option 填入即可。查看搜索结果的时候只看定义操作相关的代码（而不是声明操作），这时你会发现另一个用法：</p><pre><code>environment.systemPackages = with pkgs; [
    vscode
    freemind
];
</code></pre><p>事实上这样写，在后面就不用每个软件包前面加上 <code>pkgs.</code> 了，<code>pkgs.vscode</code> 可以直接写成 <code>vscode</code>。</p><p>胜利在望！接下来去 <a href="https://nixos.org/nixos/packages.html">NixOS Packages</a>，查找自己需要的软件包填入。你会发现有 Package name 和 Attribute name，填哪个呢？不妨回到 GitHub 继续翻配置文件，当你发现所有配置填的都是 Attribute name，我们就可以开始了，下面的就是我的配置：</p><pre><code>environment.systemPackages = with pkgs; 
[
    dos2unix chromium fcitx fcitx-configtool firefox gcc git gptfdisk libreoffice-fresh neofetch pciutils python transmission vim wget vscode-with-extensions
];
</code></pre><p>你会发现这里面没有 X11 和 Pantheon 相关的包，<strong>事实上， <code>services.xserver.desktopManager.pantheon.enable = true;</code> 这一行已经为你安装了相应的包。</strong><a href="https://github.com/NixOS/nixpkgs/blob/master/nixos/modules/services/x11/desktop-managers/pantheon.nix">可以查看一下包含这个选项声明的文件</a>，我们定位到 <code>config =</code> 往下的内容。虽然有些选项我们没有讨论过，例如 <code>fonts.fontconfig.defaultFonts</code> 等等，但是你可以通过搜索 NixOS Options 或者直接按照它的字面意思知道这些选项是干什么的。有安装软件包的、设置系统服务的、设置字体的等等。</p><p>有了这么一行，我们也就没有必要在我们自己的 <code>configuration.nix</code> 中设置它了。所以说 NixOS Options 的优先级是会高于 NixOS Packages 的，笔者才会用很大的篇幅介绍前者。<strong>当你需要一个软件或功能，首先考虑的应该是有没有对应的 NixOS Option，而不是直接安装一个 Nixpkg。</strong></p><ul><li><ul><li>*</li></ul></li></ul><p>下面是另外两个比较玄学的案例，都是我安装完成之后才开始折腾的问题，<strong>当然了安装的时候也没有必要纠结这些问题</strong>，因为安装完后还可以随时编辑 <code>configuration.nix</code>，后面还会再介绍。同样，我会着重说明我是<strong>如何找到</strong>解决方案的，希望能给到大家一些帮助。<strong>介绍这些案例，不是为了劝退，而是为了说明，只要合理利用我在本章介绍的各类资源，善用搜索，必要时勇敢提问、开 Issue，甚至发 PR</strong>（<a href="https://discourse.nixos.org/t/language-packs-for-libreoffice-and-firefox/698/">这里有笔者本人的例子</a>）<strong>，大部分的问题都能很快地得到解决。</strong></p><h3>禁用 N 卡</h3><p>单纯出于想要省电的原因，打算禁用 N 卡。网上给出的禁用 N 卡的方案是都是使用 BBSwitch，四处搜索之。最后在 <a href="https://discourse.nixos.org/t/external-monitors-not-working-dell-xps/1799">Discourse Forum</a> 里面找到了一个有一定关联的。提到的选项包括 <code>extraModprobeConfig</code>、<code>blacklistedKernelModules</code>、<code>extraModulePackages</code>。</p><p>我们知道在其它发行版下要使用 BBSwitch 禁用 N 卡是这样操作的：</p><pre><code>options bbswitch load_state=0 unload_state=1
</code></pre><p>和帖子中 <code>extraModprobeConfig</code> 的值高度类似。而 <code>extraModulePackages</code> 在帖子里的值是 <code>config.boot.kernelPackages.nvidia_x11</code>，我们搜索到 BBSwitch 的 Attribute name 是 <code>linuxPackages.bbswitch</code>，相信也有一定关联。</p><p>接下来我们去 NixOS Options 继续搜索，发现上面几个选项都在 <code>boot</code> 集合下，查找 <code>boot module</code> 关键词，又发现了一个 <code>boot.kernelModules</code>，我认为这个选项和我的需求也是高度关联的。于是我写下了以下的配置：</p><pre><code>boot = {
    extraModprobeConfig = ''
        options bbswitch load_state=0 unload_state=1
    '';
    extraModulePackages = [ pkgs.linuxPackages.bbswitch ];
    kernelModules = [ &quot;bbswitch&quot; ];
    blacklistedKernelModules = [
        &quot;nouveau&quot;
        &quot;rivafb&quot;
        &quot;nvidiafb&quot;
        &quot;rivatv&quot;
        &quot;nv&quot;
        &quot;uvcvideo&quot;
    ];
};
</code></pre><p>确实是可行的，因为我后面运行 <code>lspci</code> 的时候显示已经是 <code>rev ff</code> 了：</p><pre><code>01:00.0 3D controller: NVIDIA Corporation GP107M [GeForce GTX 1050 3 GB Max-Q] (rev ff)
</code></pre><h3>Visual Studio Code 插件</h3><p>你可能会问这也要提及？情况是这样的，安装了 VS Code（<code>pkgs.vscode-with-extensions</code>）之后我安装了几个插件，发现 C++ 插件不工作。我对这个插件提供的补全功能有较大的依赖，第一时间我想到的是这是 NixOS 目录结构和其它发行版不一致的问题。于是去搜索 Discourse Forum，<a href="https://discourse.nixos.org/t/vscode-extensions-setup/1801">找到了这个帖子</a>。下面有官方开发者给出了一个 Dirty Hack，尝试之。</p><p>结果发现 <code>fetchTarball https://github.com/nixos/nixpkgs-channels/archive/nixpkgs-unstable.tar.gz</code> 会消耗不少时间。一个解决方案是将整个 GitHub 仓库同步到其它 Git 托管平台，但我们还是希望有更高效的解决方案。留意到了楼主的解决方案，虽然它会覆盖原有的自己在 Marketplace 安装的 VS Code 插件，但是按照楼主的描述它确实是可行的：</p><pre><code>self: super:
{
    mycode = super.vscode-with-extensions.override {
        # When the extension is already available in the default extensions set.
        vscodeExtensions = with super.vscode-extensions; [
            ms-vscode.cpptools
        ];
    };
}
</code></pre><p>但是你并不知道第一行是啥，也不知道如何添加这个方案，<a href="https://github.com/search?l=Nix&q=vscode-with-extensions.override&type=Code">于是去 GitHub 搜索相关的内容</a>。结果搜出来的结果比上面这个还要再复杂一点，而且这样写的不只一个：</p><pre><code>self: super: {
    vscode-with-extensions = super.vscode-with-extensions.override {
        vscodeExtensions = with super.vscode-extensions;
        [ 
            bbenoist.Nix
            ms-vscode.cpptools
        ]
        ++ super.vscode-utils.extensionsFromVscodeMarketplace [ {
                name = &quot;vim&quot;;
                publisher = &quot;vscodevim&quot;;
                version = &quot;1.0.8&quot;;
                sha256 = &quot;0yqfn8b2jfrijzf731sggyvik2immlx9hfgmsgp1mx01hpyisd9r&quot;;
            } {
                name = &quot;doxdocgen&quot;;
                publisher = &quot;cschlosser&quot;;
                version = &quot;0.4.1&quot;;
                sha256 = &quot;06f4nxjd5ph66bhlyjim87haams286sjhrw7vmiv2rckzinygh1h&quot;;
            } {
                ...
            }
        ];
    };
}
</code></pre><p>这时可以猜出来官方应该有相应的文档，于是就去搜索 NixOS Manual、NixOS Options 还有 NixOS Packages，发现都找不到。终于，<a href="https://github.com/NixOS/nixpkgs">笔者开始查找 GitHub 的 NixOS/nixpkgs 仓库</a>。<a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/applications/editors/vscode/with-extensions.nix">找到了这样一个文件</a>。你会发现第一行没了，后面的内容还是类似的。现在我们可以把关注点放在这个 <code>override</code> 上了。我们重新发起一次搜索，<a href="https://nixos.org/nixos/manual/#sec-customising-packages">在 NixOS Manual 找到了有关 <code>override</code> 的说明</a>。</p><p>太妙了！但是接下来又有一个问题，这里的 <code>name</code>、<code>publisher</code>、<code>version</code> 和 <code>sha256</code> 又该怎么填呢？为什么 <code>ms-vscode.cpptools</code> 不需要填 <code>version</code> 和 <code>sha256</code> 呢？阅读还是刚才的文件，阅读上面的注释：</p><p>This expression should fetch:</p><ul><li>the <code>nix</code> vscode extension from whatever source defined in the default nixpkgs extensions set <code>vscodeExtensions</code>.</li><li>the <code>code-runner</code> vscode extension from the marketplace using the following url: <a href="https://bbenoist.gallery.vsassets.io/_apis/public/gallery/publisher/bbenoist/extension/nix/1.0.1/assetbyname/Microsoft.VisualStudio.Services.VSIXPackage">(link)</a>.</li></ul><p>The original <code>code</code> executable will be wrapped so that it uses the set of pre-installed / unpacked extensions as its <code>--extensions-dir</code>.</p><p>然而我们却找不到 <code>vscodeExtensions</code>，但是我们可以搜索 <code>ms-vscode.cpptools</code> 啊！<a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/misc/vscode-extensions/default.nix">终于笔者找到了这个文件</a>。事实上在这个文件中涉及到的所有插件都无需我们再配置 <code>publisher</code>、<code>version</code> 和 <code>sha256</code> 了。<strong>这和我们使用了 <code>services.xserver.desktopManager.pantheon.enable = true;</code> 就不需要在 <code>environment.systemPackages</code> 添加相关的包是一个道理。</strong></p><p>至于这个文件里没有的插件呢？例如说 <code>ms-vscode.cpptools</code> 的 <code>name</code> 就是 <code>cpptools</code>，<code>publisher</code> 就是 <code>ms-vscode</code>。我们可以去 <a href="https://marketplace.visualstudio.com/vscode">Marketplace</a> 下载这个插件（找到 Download Extension 按钮即可），用 <code>sha256sum</code> 命令计算下载下来的文件的 <code>sha256</code>，而版本号在文件名有。好了，你已经准备好了！让我们来继续完善 <code>environment.systemPackages</code>：</p><pre><code>environment.systemPackages = with pkgs; 
[
    dos2unix chromium fcitx fcitx-configtool firefox gcc git gptfdisk libreoffice-fresh neofetch pciutils python transmission vim wget
    ( vscode-with-extensions.override {
        vscodeExtensions = with vscode-extensions; [
            bbenoist.Nix
            ms-vscode.cpptools
            ms-azuretools.vscode-docker
        ]
        ++ vscode-utils.extensionsFromVscodeMarketplace [ {
                name = &quot;bracket-pair-colorizer-2&quot;;
                publisher = &quot;CoenraadS&quot;;
                version = &quot;0.0.29&quot;;
                sha256 = &quot;cadb50a21944e6e0293e3872d2fe23b5d2fd2b603ed2bf4a0675fd29bcfb130c&quot;;
            } {
                name = &quot;python&quot;;
                publisher = &quot;ms-python&quot;;
                version = &quot;2020.3.71113&quot;;
                sha256 = &quot;1d8a98a1eed7588dd3b57e4bbe518fcc88f883e066f1b3342453e9bc1a283fdb&quot;;
            } {
                name = &quot;php-intellisense&quot;;
                publisher = &quot;felixfbecker&quot;;
                version = &quot;2.3.14&quot;;
                sha256 = &quot;3798a5de1172b5803877357d0057e3e129d8d82b8fbe0b53ae28c777a0075ca6&quot;;
            } {
                name = &quot;vscode-language-pack-zh-hans&quot;;
                publisher = &quot;MS-CEINTL&quot;;
                version = &quot;1.44.2&quot;;
                sha256 = &quot;4f6ee18ada0e71dd1545ef49f8810f52fe872d2074612faa908d8bf2687400a0&quot;;
            }
        ];
    } )
];
</code></pre><ul><li><ul><li>*</li></ul></li></ul><p>相信对于其它的需求大家也能举一反三。<a href="https://github.com/bobby285271/nixos-configuration/blob/master/configuration.nix">这里是我的 <code>configuration.nix</code></a>，供大家参考。</p><h2>执行安装</h2><p>前面已经提及过 <code>nixos-install</code> 这个命令了，让我们使用它执行安装，不需要带上任何参数：</p><pre><code>nixos-install
</code></pre><p>如果 <code>configuration.nix</code> 存在任何错误，安装会在一开始的时候就中断，修改好后重新运行上面的命令即可。<strong>网络出现问题同理。</strong>接下来安装程序会提示你设置一个密码，这个密码是给管理员用的（<strong>密码当然是不能在 <code>configuration.nix</code> 上设置的</strong>），盲打两次即可。重启并进入新系统：</p><pre><code>reboot
</code></pre><p>当然，重启后别忘了为你的普通用户设置密码（如 <code>passwd bobby285271</code>）。</p><h2>系统维护</h2><p>笔者之前讲过 <code>configuration.nix</code> 是可以随时修改的。当然了现在你应该处于你的新系统中了，所以你不应该编辑 <code>/mnt/etc/nixos/configuration.nix</code> 了，而是应该编辑 <code>/etc/nixos/configuration.nix</code>。</p><pre><code>nano /etc/nixos/configuration.nix
</code></pre><p>要使这个配置生效，应该使用 <code>nixos-rebuild switch</code> 命令，如果你希望在构建这个配置的时候顺便升级自己的系统（当然如果你不改动 <code>configuration.nix</code> 单纯想升级系统，同样可以执行这个命令） ：</p><pre><code>nixos-rebuild switch --upgrade
</code></pre><p>关于这个，<a href="https://nixos.org/nixos/manual/index.html#sec-changing-config">可以查看 NixOS Manual 了解详情</a>。</p>
]]></content>
<link rel="replies" type="text/html" href="https://static.bobby285271.top/index.php/2020/04/15/NixOS-Installation-and-Configuration-Guide.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://static.bobby285271.top/index.php/feed/atom/2020/04/15/NixOS-Installation-and-Configuration-Guide.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[How to Deploy WordPress on a Fedora Server (en)]]></title>
<link rel="alternate" type="text/html" href="https://static.bobby285271.top/index.php/2020/02/03/How-to-Deploy-WordPress-on-a-Fedora-Server-en.html" />
<id>https://static.bobby285271.top/index.php/2020/02/03/How-to-Deploy-WordPress-on-a-Fedora-Server-en.html</id>
<updated>2020-02-02T16:00:00+00:00</updated>
<published>2020-02-02T16:00:00+00:00</published>
<author>
    <name>bobby285271</name>
    <uri>https://static.bobby285271.top</uri>
</author>
<summary type="html"><![CDATA[First things firstYou should get a IP address after buying VPS, such as 123.123.123.123. Open you...]]></summary>
<content type="html" xml:base="https://static.bobby285271.top/index.php/2020/02/03/How-to-Deploy-WordPress-on-a-Fedora-Server-en.html" xml:lang="zh-CN"><![CDATA[
<h2>First things first</h2><p>You should get a IP address after buying VPS, such as <code>123.123.123.123</code>. Open your favourite terminal and enter:</p><blockquote>Replace <code>123.123.123.123</code> with your actual IP address.</blockquote><pre><code>ssh root@123.123.123</code></pre><p>Enter your password to login. Perform a full upgrade on your system:</p><pre><code>dnf upgrade
</code></pre><h2>Package Installation</h2><p>Install Apache, PHP and MariaDB using the DNF package manager. There is NO need to install the <code>wordpress</code> package.</p><pre><code>dnf install @&quot;Web Server&quot; php-mysqlnd mariadb-server
</code></pre><p>Enable the web and database services to start at boot time, then start them immediately:</p><pre><code>systemctl enable httpd.service mariadb.service
systemctl start httpd.service mariadb.service</code></pre><h2>MariaDB Configuration</h2><p>Firstly, initialize MariaDB. If this is your first use of MariaDB, you should create a password for your root user here. <strong>Don’t use</strong> the system’s own root (administrator) password. It is suggested to answer <code>y</code> to all yes-no questions afterwards:</p><pre><code>mysql_secure_installation</code></pre><p>Next, create a database. You can host more than one WordPress site on a machine. Therefore, you may want to choose a distinctive name for yours. For instance, this example uses <code>mywpsite</code>. The <code>-p</code> switch prompts you for a password.</p><blockquote>Replace <code>mywpsite</code> with a database name you preferred.</blockquote><pre><code>mysqladmin create mywpsite -u root -p</code></pre><p>Next, set up a special privileged user and password for the database. The web app uses these credentials to run. Use the standard <code>mysql</code> client program for this step. The <code>-D</code> option attaches to the built-in MySQL database where privileges are stored.</p><blockquote>Replace <code>sqluser</code> and <code>password</code> with a user name you preferred and a strong password.</blockquote><pre><code>mysql -D mysql -u root -p</code></pre><pre><code>GRANT ALL PRIVILEGES ON mywpsite.* TO 'sqluser'@'localhost' IDENTIFIED BY 'password';
FLUSH PRIVILEGES;
QUIT;</code></pre><h2>Set up the Web Server</h2><p>Next, tune the SELinux parameters so the web server can perform necessary functions.</p><pre><code>setsebool -P httpd_can_network_connect_db=1
setsebool -P httpd_can_sendmail=1</code></pre><p>Next, configure your firewall so it allows traffic on port <code>80</code> (HTTP):</p><pre><code>firewall-cmd --add-service=http --permanent
firewall-cmd --reload</code></pre><h2>Download WordPress</h2><p>These latest version of WordPress are always available on <code>https://wordpress.org/latest.tar.gz</code>.</p><pre><code>cd /var/www/html
wget https://wordpress.org/latest.tar.gz</code></pre><p>Extract the downloaded archive to the document root of your domain and update permissions on files.</p><pre><code>tar xzf latest.tar.gz
chown -R apache.apache wordpress
chmod -R 755 wordpress</code></pre><h2>All Done</h2><p>Visit <code>123.123.123.123/wordpress</code>, and finish the installation.</p>
]]></content>
<link rel="replies" type="text/html" href="https://static.bobby285271.top/index.php/2020/02/03/How-to-Deploy-WordPress-on-a-Fedora-Server-en.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://static.bobby285271.top/index.php/feed/atom/2020/02/03/How-to-Deploy-WordPress-on-a-Fedora-Server-en.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[How to Launch a Desktop Environment on WSL 2]]></title>
<link rel="alternate" type="text/html" href="https://static.bobby285271.top/index.php/2019/10/05/How-to-Launch-a-Desktop-Environment-on-WSL-2.html" />
<id>https://static.bobby285271.top/index.php/2019/10/05/How-to-Launch-a-Desktop-Environment-on-WSL-2.html</id>
<updated>2019-10-04T16:00:00+00:00</updated>
<published>2019-10-04T16:00:00+00:00</published>
<author>
    <name>bobby285271</name>
    <uri>https://static.bobby285271.top</uri>
</author>
<summary type="html"><![CDATA[WSL 2 是 WSL 中体系结构的新版本，它改变了 Linux 发行版与 Windows 交互的方式。WSL 2 的主要目标是提高文件系统性能并增加系统调用的完全兼容性。 每个 Linux 发...]]></summary>
<content type="html" xml:base="https://static.bobby285271.top/index.php/2019/10/05/How-to-Launch-a-Desktop-Environment-on-WSL-2.html" xml:lang="zh-CN"><![CDATA[
<p>WSL 2 是 WSL 中体系结构的新版本，它改变了 Linux 发行版与 Windows 交互的方式。<br>WSL 2 的主要目标是提高文件系统性能并增加系统调用的完全兼容性。 每个 Linux 发行版都可以作为 WSL 1 或 WSL 2 发行版运行，并可随时进行切换。<br>WSL 2 是底层体系结构的主要功能，它使用虚拟化技术和 Linux 内核来实现其新功能。</p><h2>准备</h2><p>为了使用 WSL 2，你需要 <strong>Windows 10 内部版本 18917 或更高版本</strong>。要想了解目前使用的版本是什么，可以到设置页面查看。<br><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/wsl2/0.PNG" alt="" title=""></p><p>首先，右击任务栏 Windows 图标，选择 Windows Powershell（管理员），输入以下命令：</p><pre><code>Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform
Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</code></pre><p>或者前往控制面板 - 程序 - 启用或关闭 Windows 功能，然后勾选<strong>虚拟机平台</strong>和<strong>执行 Linux 程序的 Windows 子系统</strong>。<br><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/wsl2/" alt="" title=""></p><p>完成设置后需要重启计算机！</p><h2>安装</h2><p>前往 Microsoft Store 下载并安装 Ubuntu。<br><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/wsl2/2.PNG" alt="" title=""></p><p>接下来使 WSL 2 成为你的默认体系结构。打开 Windows Powershell 或命令提示符：</p><pre><code>wsl --set-default-version 2</code></pre><p>接下来在开始菜单找到 Ubuntu，点击后稍作等候。当一切准备好后，Ubuntu 会提示你新建一个账户和密码，注意输入密码时是不会有回显的。<br><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/wsl2/5.PNG" alt="" title=""></p><p>此时你可以验证刚刚安装好的 Ubuntu 所使用的 WSL 版本：</p><pre><code>wsl --list --verbose</code></pre><p><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/wsl2/6.PNG" alt="" title=""></p><p>如果你在 Windows Powershell 或命令提示符下运行 <code>wsl</code>，同样也是可以进入 WSL 环境的。</p><h2>软件</h2><p>切换到 Root：</p><pre><code>$ sudo -i</code></pre><p>编辑 APT 软件源（<code>nano</code> 大法好，不接受反驳） ：</p><pre><code># nano /etc/apt/sources.list</code></pre><pre><code>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</code></pre><p>更新可用软件包列表，随后升级系统：</p><pre><code># apt update &amp;&amp; apt dist-upgrade -y</code></pre><p>安装基本开发环境、Xubuntu 桌面和远程桌面支持：</p><pre><code># apt install build-essential xubuntu-desktop xrdp</code></pre><p><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/wsl2/11.PNG" alt="" title=""></p><p>安装的软件包比较多，可能要等上一段时间。这里的 Xubuntu 桌面实际为 XFCE 桌面环境，换成别的问题不大但还是建议选择轻量级桌面。</p><p>保存 Xsession 配置：</p><pre><code># exit #切换回普通用户。
$ echo xfce4-session &gt; ~/.xsession</code></pre><h2>远程桌面</h2><blockquote>需要使用远程桌面时均要执行本节内容。</blockquote><p>启用 Xrdp 服务（这里不能使用 <code>systemctl</code>，因为 SystemD 不是默认的 Init 系统），记录端口信息：</p><pre><code>$ sudo service xrdp start</code></pre><p>在 Windows 开始菜单栏中找到 Windows 附件 - 远程桌面连接，输入 <code>localhost:端口</code>，如 <code>localhost:3389</code>。</p><p>应该会出现如下警告，选择是即可：<br><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/wsl2/16.PNG" alt="" title=""></p><p>如果你没有看到这个警告，可能需要查找虚拟机的 IP 地址并替代 <code>localhost</code> 再试一次：</p><pre><code>$ ip address</code></pre><p><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/wsl2/13.PNG" alt="" title=""></p><p>在这里，IP 地址查找到是 <code>172.18.221.157</code>，端口是 <code>3389</code>。注意每次重启 WSL 实例后这个 IP 地址都会换。</p><p>输入 <code>IP 地址:端口</code>，如 <code>172.18.221.157:3389</code>。</p><p>接下来输入自己的账户密码：<br><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/wsl2/17.PNG" alt="" title=""></p><p>然后就是很熟悉的界面了：<br><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/wsl2/18.PNG" alt="" title=""></p><h2>本地化</h2><p>直接在终端下就可以完成设置了（以下命令在 Root 下运行）：</p><pre><code># dpkg-reconfigure locales</code></pre><p>确认 <code>en_US.UTF-8 UTF-8</code> 和 <code>zh_CN.UTF-8 UTF-8</code> 被勾选，然后将 <code>zh_CN.UTF-8 UTF-8</code> 设定为默认值。<br><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/wsl2/19.PNG" alt="" title=""></p><p>然后安装语言包和输入法（按理来说装完就能用）：</p><pre><code># apt install language-pack-zh-hans language-pack-gnome-zh-hans fcitx fcitx-table</code></pre><h2>彩蛋</h2><p>Windows 应用能访问 Linux 根文件系统啦，包括文件资源管理器！尝试在 WSL 中使用普通用户运行 <code>explorer.exe .</code>（在远程桌面会话中这样做是没有用滴！），看看会发生什么。</p><p>另外内部错误大法又怎能缺席呢（逃）。<br><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/wsl2/20.PNG" alt="" title=""></p>
]]></content>
<link rel="replies" type="text/html" href="https://static.bobby285271.top/index.php/2019/10/05/How-to-Launch-a-Desktop-Environment-on-WSL-2.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://static.bobby285271.top/index.php/feed/atom/2019/10/05/How-to-Launch-a-Desktop-Environment-on-WSL-2.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[Chakra CCR Packaging Guide]]></title>
<link rel="alternate" type="text/html" href="https://static.bobby285271.top/index.php/2019/02/02/Chakra-CCR-Packaging-Guide.html" />
<id>https://static.bobby285271.top/index.php/2019/02/02/Chakra-CCR-Packaging-Guide.html</id>
<updated>2019-02-01T16:00:00+00:00</updated>
<published>2019-02-01T16:00:00+00:00</published>
<author>
    <name>bobby285271</name>
    <uri>https://static.bobby285271.top</uri>
</author>
<summary type="html"><![CDATA[Chakra 的成功证明了只围绕 KDE 和 Qt 搭建一个简约的系统是完全可行的。但正是因为「简约」这一特性，一些用户需要的软件可能不被包含在我们的官方软件仓库中。Chakra 社区软件仓库（...]]></summary>
<content type="html" xml:base="https://static.bobby285271.top/index.php/2019/02/02/Chakra-CCR-Packaging-Guide.html" xml:lang="zh-CN"><![CDATA[
<p>Chakra 的成功证明了只围绕 KDE 和 Qt 搭建一个简约的系统是完全可行的。但正是因为「简约」这一特性，一些用户需要的软件可能不被包含在我们的官方软件仓库中。<a href="https://ccr.chakralinux.org">Chakra 社区软件仓库</a>（CCR）也就因此诞生了，它由社区维护，为所有类型的软件都敞开了大门。</p><h2>搜索、安装、升级 CCR 软件包</h2><blockquote>老用户请注意：<code>ccr</code> 工具已经被弃用，请转而使用 <code>chaser</code>。</blockquote><p>Chakra 提供了一个叫 <code>chaser</code> 的工具供用户管理 CCR 软件包。它的一些常见用法如下：</p><pre><code>[chakra@localhost ~]$ chaser -h
usage: chaser [-h] [-v] [-b BUILD_DIR]
              {get,install,listupdates,update,search,info} ...

Next-generation community package management for Chakra.

positional arguments:
  {get,install,listupdates,update,search,info}
    get                 download source files here
    install             install a package from the CCR
    listupdates         list available updates
    update              search for and install updates for CCR packages
    search              search CCR packages
    info                display package information

optional arguments:
  -h, --help            show this help message and exit
  -v, --version         show version information and exit
  -b BUILD_DIR, --build-dir BUILD_DIR
                        build packages in BUILD_DIR. default = /tmp/chaser</code></pre><h3>搜索</h3><p>搜索 CCR 软件包有两种方式，一种是直接访问 <a href="https://ccr.chakralinux.org/">CCR</a> 站点并发起搜索，另一种是使用 <code>chaser search</code> 命令，比如搜索 <code>neofetch</code>：</p><pre><code>[chakra@localhost ~]$ chaser search neofetch</code></pre><p><code>chaser</code> 既会扫描官方软件仓库，也会扫描 CCR。两处符合条件的软件包都会被输出。</p><ul><li>如果您没有在其中找到您所需要的包，请考虑阅读下一章节。</li><li>如果您找到的包位于 <code>[core]</code>、<code>[desktop]</code>、<code>[gtk]</code>、<code>[lib32]</code>、<code>[testing]</code> 之一，这意味着您所需的包已经存在于官方软件仓库，请使用 <a href="https://community.chakralinux.org/t/chakra-package-manager-simplified-chinese/7341">Pacman</a> 进行后续操作。</li><li>如果您找到的包位于 <code>[ccr]</code>，请继续阅读。</li></ul><p>下面可以使用 <code>chaser info</code> 进一步了解软件包信息。</p><pre><code>[chakra@localhost ~]$ chaser info neofetch</code></pre><p>下面是一个示例输出：</p><pre><code>Name           : neofetch
Version        : 5.0.0-1
URL            : https://github.com/dylanaraps/neofetch
Licenses       : MIT
Category       : utils
Votes          : 2
Maintainer     : bobby285271
OutOfDate      : False
Description    : A CLI system information tool written in BASH that supports displaying images.</code></pre><p>由于 CCR 活跃用户不多，请务必通过 <code>Version</code> 和 <code>OutOfDate</code> 了解清楚软件包维护情况，如果这个软件包过旧，考虑帮忙维护它（请阅读下一章节）。</p><h3>安装</h3><p>如果您决定安装，使用 <code>chaser install</code> 命令。<strong>不要</strong>使用 <code>root</code> 运行以下命令，当 <code>chaser</code> 需要管理员权限的时候会要求您输入密码。</p><pre><code>[live@localhost ~]$ chaser install neofetch</code></pre><p>大致的安装流程如下（以安装 <code>neofetch</code> 为例，部分输出被省略）。</p><ul><li>确认构建软件包：请在此处回答 <code>y</code>（是）。</li></ul><pre><code>resolving dependencies...
Downloading neofetch

Targets (1) neofetch

:: Proceed with installation? [Y/n]</code></pre><ul><li>定制软件包：PKGBUILD 是 Arch Linux 的一大特色，也被 Chakra 很好地继承了下来。感兴趣的请阅读 <a href="https://www.archlinux.org/pacman/PKGBUILD.5.html">PKGBUILD 语法</a>，一般用户直接回答 <code>n</code>（否）。</li></ul><pre><code>Downloading neofetch
Edit neofetch PKGBUILD with $EDITOR? [Y/n]</code></pre><ul><li>构建软件包：此过程全自动，无需用户干预。</li></ul><pre><code>==&gt; Making package: neofetch 5.0.0-1
==&gt; Checking runtime dependencies...
==&gt; Checking buildtime dependencies...
==&gt; Retrieving sources...
==&gt; Validating source files with sha256sums...
==&gt; Extracting sources...
==&gt; Entering fakeroot environment...
==&gt; Starting package()...
==&gt; Tidying install...
==&gt; Checking for packaging issue...
==&gt; WARNING: backup entry file not in package : etc/neofetch/config.conf
==&gt; Creating package &quot;neofetch&quot;...
==&gt; Leaving fakeroot environment.
==&gt; Finished making: neofetch 5.0.0-1
==&gt; Installing package neofetch with pacman -U...</code></pre><ul><li>确认安装软件包：后续的工作将自动交由 Pacman 完成。请在此处回答 <code>y</code>（是）。</li></ul><pre><code>loading packages...
resolving dependencies...
looking for conflicting packages...

Packages (1) neofetch-5.0.0-1

Total Installed Size:  0.26 MiB

:: Proceed with installation? [Y/n] </code></pre><ul><li>安装软件包：此过程全自动，无需用户干预。</li></ul><pre><code>(1/1) checking keys in keyring                                                                                                                                     [#####################################################################################################] 100%
(1/1) checking package integrity                                                                                                                                   [#####################################################################################################] 100%
(1/1) loading package files                                                                                                                                        [#####################################################################################################] 100%
(1/1) checking for file conflicts                                                                                                                                  [#####################################################################################################] 100%
(1/1) checking available disk space                                                                                                                                [#####################################################################################################] 100%
:: Processing package changes...
(1/1) installing neofetch                                                                                                                                          [#####################################################################################################] 100%
:: Running post-transaction hooks...
(1/1) Arming ConditionNeedsUpdate...</code></pre><h3>升级</h3><p>使用 <code>chaser listupdates</code> 查看可用的更新，使用 <code>chaser update</code> 检查并应用更新 CCR 软件包。</p><h3>移除</h3><p>要查看您安装的 CCR 软件包，使用 <code>pacman -Qm</code> 命令。</p><blockquote>这个命令可能会输出一些您觉得很陌生的软件包，这很有可能是从官方软件仓库仓库移除且不再受 Chakra 团队支持的包。</blockquote><p>使用 Pacman 移除您不再需要的包，详见 <a href="https://community.chakralinux.org/t/chakra-package-manager-simplified-chinese/7341">这篇文章</a>。</p><h2>提交、维护 CCR 软件包（初阶）</h2><p>感谢您为 Chakra 做出贡献！接下来，您将了解到如何准备 PKGBUILD，制作源码包并上传到 CCR 上。首先，请先前往 CCR 的 <a href="https://ccr.chakralinux.org/account.php">帐户页面</a> 注册一个帐号。</p><h3>准备 PKGBUILD：概述</h3><p>PKGBUILD 是整个 CCR 包的灵魂所在。要知道的是，所谓的「制作源码包」不过是将 PKGBUILD 和几个补丁捆起来制作一个压缩包罢了。用户试图安装一个 CCR 包，本质上来说，其实是将 PKGBUILD 给下载下来，并执行里面的命令，从而编译安装真正的软件包。</p><h4>PKGBUILD 示例</h4><p>编写 PKGBUILD 并不是一件容易事，这里提供一个示例文件：</p><blockquote>如果您知道分包是什么，请注意：<strong>CCR 不支持分包，一个 PKGBUILD 只能对应一个软件包</strong>。</blockquote><pre><code># This is an example PKGBUILD file. Use this as a start to creating your own,
# and remove these comments. For more information, see 'man PKGBUILD'.
# NOTE: Please fill out the license field for your package! If it is unknown,
# then please put 'unknown'.

# Maintainer: Your Name &lt;youremail@domain.com&gt;
pkgname=NAME
pkgver=VERSION
pkgrel=1
epoch=
pkgdesc=&quot;&quot;
arch=()
url=&quot;&quot;
license=('GPL')
groups=()
depends=()
makedepends=()
checkdepends=()
optdepends=()
provides=()
conflicts=()
replaces=()
backup=()
options=()
install=
changelog=
source=(&quot;$pkgname-$pkgver.tar.gz&quot;
        &quot;$pkgname-$pkgver.patch&quot;)
noextract=()
md5sums=()
validpgpkeys=()

prepare() {
        cd &quot;$pkgname-$pkgver&quot;
        patch -p1 -i &quot;$srcdir/$pkgname-$pkgver.patch&quot;
}

build() {
        cd &quot;$pkgname-$pkgver&quot;
        ./configure --prefix=/usr
        make
}

check() {
        cd &quot;$pkgname-$pkgver&quot;
        make -k check
}

package() {
        cd &quot;$pkgname-$pkgver&quot;
        make DESTDIR=&quot;$pkgdir/&quot; install
}</code></pre><h4>简要说明</h4><p>基本信息：</p><ul><li><code>pkgbase</code>： 软件包的名称，名称由小写字母、数字和任意以下字符组成： <code>@ . _ + -</code>；</li><li><code>pkgver</code>：软件包的版本号，应该与软件原作者发布的版本号一致；</li><li><code>pkgrel</code>：发布号，一个正整数，用来区分同一版本软件的多次构建；</li><li><code>epoch</code>：当一个软件的版本编号方式改变，使用此数值进行强制升级。</li></ul><p>描述：</p><ul><li><code>pkgdesc</code>：软件包描述，合理使用关键字以方便搜索；</li><li><code>arch</code>： PKGBUILD 可以编译和使用的架构（Chakra 仅支持 <code>x86_64</code>） ；</li><li><code>url</code>：软件官方站点的网址；</li><li><code>license</code>：软件发布许可证；</li><li><code>groups</code>：软件包所在的组。</li></ul><p>依赖关系：</p><ul><li><code>depends</code>：软件的运行时依赖列表；</li><li><code>optdepends</code>：一组不影响软件主要功能，但能提供额外特性的软件包；</li><li><code>makedepends</code>：仅在软件编译时需要的软件包列表；</li><li><code>checkdepends</code>：运行测试组件时需要，而运行时不需要的包列表。</li></ul><p>相关性：</p><ul><li><code>provides</code>：这个变量说明当前包能提供的功能（或者像 cron、sh 这样的虚包）；</li><li><code>conflicts</code>：与当前软件包发生冲突的包列表；</li><li><code>replaces</code>：会因安装当前包而取代的包列表。</li></ul><p>其它：</p><ul><li><code>backup</code>：当包被升级或卸载时，应当备份的文件；</li><li><code>options</code>：这个变量允许您重置 <code>makepkg</code> 的部分默认行为；</li><li><code>install</code>：<code>.install</code> 脚本的名称，应该和 <code>pkgname</code> 相同；</li><li><code>changelog</code>：软件包 changelog 的名称。</li></ul><p>源码：</p><ul><li><code>source</code>：构建软件包时需要的文件列表；</li><li><code>noextract</code>：一些列举于 <code>source</code> 中，但不需要在运行 <code>makepkg</code> 时解包的文件；</li><li><code>validpgpkeys</code>：PGP 指纹列表；</li></ul><p>完整性：</p><ul><li><code>md5sums</code>：<code>source</code> 列表文件中的 128 位 MD5 校验和；</li><li><code>sha1sums</code>：<code>source</code> 列表文件中 160 位 SHA-1 校验和；</li><li><code>sha224sums</code>、<code>sha256sums</code>、<code>sha384sums</code>、<code>sha512sums</code>：<code>source</code> 列表文件中224、256、384 或 512 位 SHA-2 校验和。</li></ul><p>想要了解更多，可以阅读 ArchWiki 上的 <a href="https://wiki.archlinux.org/index.php/PKGBUILD">相关页面</a>。</p><h3>准备 PKGBUILD：从零开始（进阶）</h3><p>准备好大干一场？如果您打算从零开始编写一个 PKGBUILD，建议继续阅读以下文章：</p><ul><li><a href="https://wiki.archlinux.org/index.php/Arch_package_guidelines">AUR 打包准则</a>（对 CCR 也是同样适用的）；</li><li><a href="https://www.archlinux.org/pacman/PKGBUILD.5.html">PKGBUILD 官方手册</a>。</li></ul><p>请确认您已经彻底了解清楚您所维护的软件包<strong>依赖什么包</strong>以及<strong>如何编译安装</strong>，否则还是建议先往下阅读。</p><h3>准备 PKGBUILD：从外部导入</h3><p>要知道现实情况是：CCR 的成熟程度远远落后于 AUR，和 <a href="https://kaos-community-packages.github.io/">KCP</a>（KaOS 社区软件仓库）差不多。AUR 的生态就摆在那里，<strong>几乎所有原生支持 Linux 的应用程序都能在 AUR 找到对应的软件包</strong>。而 KaOS 的定位和 Chakra 类似，也是围绕 KDE 和 Qt 搭建的发行版。所以说，在大部分情况下是没有必要自己造轮子的。<strong>有些轮子说不定 Chakra 团队已经为您造好了，在 Chakra 官方软件仓库里，不要重复提交这些软件包！</strong></p><p>请从 <strong>Arch Linux 官方软件仓库 & AUR</strong> 和 <strong>KaOS 官方软件仓库 & KCP</strong> 两个来源选择一个，并继续阅读下面的教程。</p><h4>Arch Linux 官方软件仓库 & AUR</h4><p>前往 <a href="https://www.archlinux.org/packages/">Arch Linux 软件包页面</a> 和 <a href="https://aur.archlinux.org/">AUR 首页</a> 发起搜索，直到您找到您打算提交到 CCR 的软件包。点击软件包名进入软件包详情页，定位到页面右侧的「Package Actions」方框：</p><p><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/ccr/1.png" alt="" title=""></p><p><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/ccr/2.png" alt="" title=""></p><p>对于 AUR 软件包页面，选择「View PKGBUILD」，当页面加载完毕后还需要点击「summary」链接前往 Git 仓库概览页面。</p><p>对于 Arch Linux 官方软件包，直接选择「Source Files」。</p><p>AUR 的软件包是一个软件包对应一个 Git 仓库的，而 Arch Linux 官方软件包则是 [core]、[extra] 仓库中的<strong>所有软件包</strong>放一个 Git 仓库，[community]、[multilib] 仓库中的<strong>所有软件包</strong>放另一个 Git 仓库。为了效率最大化，对于 AUR 包我们会选择 Clone 整个 Git 仓库，而官方软件包我们会选择逐个文件拷贝。</p><p>对于 AUR 软件包，找到 Clone 这一栏，下面有一个地址，将它复制下来：</p><p><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/ccr/3.png" alt="" title=""></p><p>打开终端，输入 <code>git clone &lt;刚刚复制的 URL 地址&gt; --depth=1</code>，例如：</p><pre><code>git clone https://aur.archlinux.org/wps-office.git/ --depth=1</code></pre><p>至于 Arch Linux 官方软件包，新建一个文件夹（名字随意），然后回到浏览器，<strong>逐个文件</strong>点击文件名旁边的「plain」链接（如图所示），如果是文本文件复制一下，在刚刚新建的文件夹新建一个<strong>同样名称</strong>的文件（千万不要随意改名），将文本粘贴下去。</p><p><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/ccr/4.png" alt="" title=""></p><p>至于二进制文件，浏览器应该会弹出下载窗口，将文件下载后放入文件夹中。</p><p>记得检查文件权限是否正常，如果发现文件权限和浏览器中「Mode」显示的是否一致。如果不一致，使用 <code>chmod</code> 修正妥当（<a href="http://linux.vbird.org/linux_basic/0210filepermission.php#chmod">这里</a> 有这个命令相关的介绍）。</p><h4>KaOS 官方软件仓库 & KCP</h4><p>和前面 Arch Linux 官方软件仓库 & AUR 大同小异。<a href="https://kaosx.us/packages/">KaOS 软件包页面</a> 和 <a href="https://kaos-community-packages.github.io/">KCP</a> 同样提供了搜索框，发起搜索后进入软件包详情页。</p><p>同样，官方包建议逐个文件获取，点击右栏的「Source Files」，剩下的操作估计大家很熟悉了，毕竟 GitHub 大家都用过，逐个查看「Raw」文件即可。</p><p><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/ccr/5.png" alt="" title=""></p><p>KCP 包可以整个仓库 Clone 下来（原因同 AUR），点击右上角的「View on GitHub」，后面的我也不再多说了，依然是 <code>git clone &lt;刚刚复制的 URL 地址&gt; --depth=1</code>。</p><p><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/ccr/6.png" alt="" title=""></p><h3>准备 PKGBUILD：收尾 & 检查工作</h3><p><strong>这一步很关键，一定要重视！</strong></p><p>上一步完成后，我们得到了一个文件夹，里面有些什么取决于您选择的包，大多数情况下里面可能只有一个 <code>PKGBUILD</code> 文件。没关系，<strong>反正一定要有 PKGBUILD</strong>，剩下的无需我们来检查。再次强调，PKGBUILD 非常关键，所以我们一定要进行检查。</p><p>这里是一份 <code>PKGBUILD</code>：</p><pre><code># Maintainer: Jan de Groot &lt;jgc@archlinux.org&gt;

pkgname=xorg-xprop
pkgver=1.2.3
pkgrel=1
pkgdesc=&quot;Property displayer for X&quot;
arch=(x86_64)
url=&quot;https://xorg.freedesktop.org/&quot;
license=('custom')
depends=('libx11')
makedepends=('xorg-util-macros')
groups=('xorg-apps' 'xorg')
source=(https://xorg.freedesktop.org/archive/individual/app/xprop-${pkgver}.tar.bz2{,.sig})
sha512sums=('ad7987fec11ae19b7adc3b0f683fc393e95155f3b6c753d1d8744aedcfb360452eee5735a4c380152b286905931515f3e1a28676b5531001eb8dd93b7249916a'
            'SKIP')
validpgpkeys=('4A193C06D35E7C670FA4EF0BA2FB9E081F2D130E') # &quot;Alan Coopersmith &lt;alan.coopersmith@oracle.com&gt;&quot;

build() {
  cd xprop-${pkgver}
  ./configure --prefix=/usr
  make
}

package() {
  cd xprop-${pkgver}
  make DESTDIR=&quot;${pkgdir}&quot; install
  install -m755 -d &quot;${pkgdir}/usr/share/licenses/${pkgname}&quot;
  install -m644 COPYING &quot;${pkgdir}/usr/share/licenses/${pkgname}/&quot;
}</code></pre><p>聪明人看完第一行就应该知道这份 <code>PKGBUILD</code> 是从 Arch Linux 官方仓库上抓取下来的。如果您刚才「 简要说明」，大概就知道我们要重点检查什么了。</p><h4>依赖关系</h4><p>首先是 <code>depends</code> 和 <code>makedepends</code>，这两项都是针对 Arch Linux 来写的。例如说一个包依赖 <code>foo</code>，到了 Chakra 这边，可能会有这几种情况：</p><ul><li>Chakra 官方软件仓库正好有 <code>foo</code>，提供的是同样的功能；</li><li>Chakra 官方软件仓库没有 <code>foo</code>，但 CCR 有；</li><li>Chakra 官方软件仓库或 CCR 提供了提供同样功能，但包名不同的 <code>foo1</code>；</li><li>Chakra 官方软件仓库或 CCR 不提供 <code>foo</code>。</li></ul><p>第一、二种情况可以直接给过不用管，因为 <code>chaser</code> 会自动从官方软件仓库和 CCR 获取相应的依赖。</p><p>第三种情况要小心一点，并不是所有情况下简单地将 <code>foo</code> 改成 <code>foo1</code> 就可以的，看一下下面这个案例：</p><p><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/ccr/7.png" alt="" title=""></p><p>注意到在 Arch Linux 这里同时存在 <code>openssl</code> 和 <code>openssl-1.0</code> 两个软件包，观察版本号，我们知道后者是为了兼容性而单独打包的。<code>openssl</code> 的版本号（截至 20190201）是 1.1.1.a-1，<code>openssl-1.0</code> 则是 1.0.2.q-1。</p><p>接下来看看 AUR 里 <code>wps-office</code> 这个包：</p><p><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/ccr/8.png" alt="" title=""></p><p>它依赖的是 <code>openssl-1.0</code>。我们可以搜索 Chakra 官方软件仓库（省略部分输出）：</p><pre><code>[chakra@localhost ~]$ pacman -Ss openssl
lib32/lib32-openssl 1.0.2.q-1
    The Open Source toolkit for Secure Sockets Layer and Transport Layer Security (32-bit)
core/openssl 1.0.2.q-1 [已安装]
    The Open Source toolkit for Secure Sockets Layer and Transport Layer Security
core/perl-crypt-openssl-bignum 0.04-3
    OpenSSL's multiprecision integer arithmetic
core/perl-crypt-openssl-random 0.04-8
    Interface to OpenSSL PRNG methods
core/perl-crypt-openssl-rsa 0.28-2
    Interface to OpenSSL RSA methods
core/perl-net-ssleay 1.63-1
    Perl extension for using OpenSSL
core/pkcs11-helper 1.25.1-1
    A library that simplifies the interaction with PKCS11 providers for end-user applications using a simple API and optional OpenSSL engine
core/python2-characteristic 14.3.0-1
    Service identity verification for pyOpenSSL
core/python2-service-identity 17.0.0-1
    Service identity verification for pyOpenSSL
core/python3-characteristic 14.3.0-1
    Service identity verification for pyOpenSSL
core/python3-service-identity 17.0.0-1
    Service identity verification for pyOpenSSL
core/tls 1.6.7-1
    OpenSSL extension to Tcl
desktop/python2-ndg-httpsclient 0.4.3-1
    Provides enhanced HTTPS support for httplib and urllib2 using PyOpenSSL
desktop/python2-pyopenssl 17.3.0-1
    Python2 wrapper module around the OpenSSL library
desktop/python3-ndg-httpsclient 0.4.3-1
    Provides enhanced HTTPS support for httplib and urllib2 using PyOpenSSL
desktop/python3-pyopenssl 17.3.0-1
    Python3 wrapper module around the OpenSSL library
[chakra@localhost ~]$</code></pre><p>这就是所有的搜索结果了，有 <code>openssl</code> 却没有 <code>openssl-1.0</code>，但是要注意 Chakra 提供的 <code>openssl</code> 版本是 1.0.2.q-1，和 Arch 中 <code>openssl-1.0</code> 是一致的。从中我们可以得出以下信息：</p><p>Chakra 是半滚动更新发行版，更新一般来说会滞后于 Arch Linux，Chakra 的 OpenSSL 打包落后于 Arch Linux，所以目前来说我们要将 <code>PKGBUILD</code> 文件中的 <code>openssl-1.0</code> 修改为 <code>openssl</code>，但当 Chakra 将 <code>openssl</code> 升级到 1.1+ 之后，我们要实时监测 Chakra 动态，做好两手准备：</p><ul><li>如果 <code>openssl-1.0</code> 可用，我们要重新打包 <code>wps-office</code>，将 PKGBUILD 改回 <code>openssl-1.0</code>；</li><li>如果 Chakra 不提供 <code>openssl-1.0</code>，我们得为 <code>openssl-1.0</code> 打包并提交到 CCR。</li></ul><p>注意：在这个案例中，只要 Chakra 的 <code>openssl</code> 不更新，用户就不能提前将 <code>openssl-1.0</code> 提交到 CCR，因为<strong>它和官方源所提供的重复了</strong>。</p><p>第四种情况，您需要前往<strong>您刚刚所选的来源</strong>（<strong>Arch Linux 官方软件仓库 & AUR</strong> 或 <strong>KaOS 官方软件仓库 & KCP</strong>），按照上面提供的步骤，获取这个依赖包的相关文件，在稍后一起进行打包。</p><h4>PGP 密钥</h4><p>如果您从 Arch Linux 或 KaOS 官方软件仓库获取软件包的要特意留意 <code>validpgpkeys</code> 这一项，如果有所填写，要注意的是，Charka 的 <code>chakra-keyring</code> 软件包只提供了 Chakra 维护者的签名，没有 Arch Linux 或 KaOS 的。这样会导致打包失败，因为打包工具 <code>makepkg</code> 是会检查 PGP 密钥的。</p><p>规避检查很简单，将 <code>validpgpkeys</code> 所在的那一行删掉。当然也别忘了将相关的文件删掉，还是上面 <code>xorg-xprop</code> 的那个例子：</p><pre><code>...
source=(https://xorg.freedesktop.org/archive/individual/app/xprop-${pkgver}.tar.bz2{,.sig})
sha512sums=('ad7987fec11ae19b7adc3b0f683fc393e95155f3b6c753d1d8744aedcfb360452eee5735a4c380152b286905931515f3e1a28676b5531001eb8dd93b7249916a'
            'SKIP')
validpgpkeys=('4A193C06D35E7C670FA4EF0BA2FB9E081F2D130E') # &quot;Alan Coopersmith &lt;alan.coopersmith@oracle.com&gt;&quot;
...</code></pre><p>在删除下面这一行之后：</p><pre><code>validpgpkeys=('4A193C06D35E7C670FA4EF0BA2FB9E081F2D130E') # &quot;Alan Coopersmith &lt;alan.coopersmith@oracle.com&gt;&quot;</code></pre><p>我们留意到 <code>source</code> 那一行，<code>{,.sig}</code> 意味着它同时包含了两个文件：<code>xprop-${pkgver}.tar.bz2</code> 和 <code>xprop-${pkgver}.tar.bz2.sig</code>，后者是用于验证密钥的，删除它。</p><p>而 <code>sha512sums</code> 那里，所有的检验值都和 <code>source</code> 的文件逐一对应，所以我们得把 <code>xprop-${pkgver}.tar.bz2.sig</code> 的校验值给相应地删除，即使它是 <code>SKIP</code>，意为「跳过校验值检查」。</p><p>这个文件最终被修改成了这样：</p><pre><code># Maintainer: Jan de Groot &lt;jgc@archlinux.org&gt;

pkgname=xorg-xprop
pkgver=1.2.3
pkgrel=1
pkgdesc=&quot;Property displayer for X&quot;
arch=(x86_64)
url=&quot;https://xorg.freedesktop.org/&quot;
license=('custom')
depends=('libx11')
makedepends=('xorg-util-macros')
groups=('xorg-apps' 'xorg')
source=(https://xorg.freedesktop.org/archive/individual/app/xprop-${pkgver}.tar.bz2)
sha512sums=('ad7987fec11ae19b7adc3b0f683fc393e95155f3b6c753d1d8744aedcfb360452eee5735a4c380152b286905931515f3e1a28676b5531001eb8dd93b7249916a')

build() {
  cd xprop-${pkgver}
  ./configure --prefix=/usr
  make
}

package() {
  cd xprop-${pkgver}
  make DESTDIR=&quot;${pkgdir}&quot; install
  install -m755 -d &quot;${pkgdir}/usr/share/licenses/${pkgname}&quot;
  install -m644 COPYING &quot;${pkgdir}/usr/share/licenses/${pkgname}/&quot;
}</code></pre><h4>其它</h4><p>如果您是从外部导入的软件包，案例来说您是无需检查校验值的，如果是自己创建的软件包就一定要检查校验值了：打开 Konsole，使用 <code>cd</code> 命令进入您的文件夹，然后执行 <code>updpkgsums</code> 命令即可。</p><p>另外我们还建议您将 Maintainer 后面的姓名和邮箱改成您自己的。</p><h4>亲自测试（建议）</h4><p>打开 Konsole，使用 <code>cd</code> 命令进入您的文件夹，然后执行 <code>makepkg</code> 命令。 如果 <code>PKGBUILD</code> 没有错误，将会生成一个包，但是如果 <code>PKGBUILD</code> 被破坏或未完成，它将抛出一个错误。</p><p><code>makepkg</code> 的用法如下：</p><pre><code>用法：/usr/bin/makepkg [选项]

选项：
  -A, --ignorearch      忽略不完整的 arch 字段 (位于 PKGBUILD 中)
  -c, --clean           编译后清理工作文件
  -C, --cleanbuild      在编译软件包之前删除 $srcdir/ 文件夹
  -d, --nodeps          跳过所有依赖关系检查
  -e, --noextract       不解压源文件 (使用现存的 $srcdir/ 目录)
  -f, --force           覆盖现存的软件包
  -g, --geninteg        为源码文件生成完整性检查值
  -h, --help            显示本帮助信息并退出
  -i, --install         成功编译后安装软件包
  -L, --log             记录软件包编译过程
  -m, --nocolor         禁止彩色输出信息
  -o, --nobuild         仅下载和解压缩文件
  -p &lt;文件&gt;             使用另外的编译脚本 (而不是 'PKGBUILD' ) 
  -r, --rmdeps          编译成功后删除安装的依赖关系
  -R, --repackage       不编译而重新打包软件包内容
  -s, --syncdeps        使用 pacman 安装缺失的依赖关系
  -S, --source          不下载源文件只生成仅包含源的包
  -V, --version         显示版本信息并退出
  --allsource           只生成源码包 (包括有已下载的源码) 
  --check               运行 check() 函数 (包含于 PKGBUILD 中)
  --config &lt;文件&gt;       使用另外的配置文件 (而不是 '/etc/makepkg.conf')
  --holdver             不升级版本控制系统源
  --key &lt;密匙&gt;          指定签名 gpg 使用的密匙而不用默认密匙
  --noarchive           不生成软件包归档
  --nocheck             不执行 check() 函数在 PKGBUILD 中
  --noprepare           不执行 prepare() 函数在 PKGBUILD 中
  --nosign              不为该软件包创建签名
  --packagelist         只列出将会产生的包，不带PKGEXT
  --printsrcinfo        打印出生成的 SRCINFO 并退出
  --sign                使用 gpg 签名生成的软件包
  --skipchecksums       不验证源文件的检验值
  --skipinteg           不对源文件执行任何验证检查
  --skippgpcheck        不验证有 PGP 签名的源文件
 --verifysource         下载源文件(如果需要)并进行完整性检查

这些选项可以传递给 pacman：
  --asdeps              作为依赖安装
  --needed              不重装已是最新的目标软件包
  --noconfirm           当解决依赖关系时不询问确认
  --noprogressbar       下载文件时不显示进度条

如果没有指定 -p，makepkg 将寻找 'PKGBUILD'</code></pre><p>如果运行 <code>makepkg</code> 成功，在您工作的目录下将会生成一个名为 <code>$pkgname-$pkgver.pkg.tar.gz</code> 的新文件。这个文件可以使用 <code>pacman -U</code> 或 <code>pacman -A</code> 安装。如果包看起来是正确的，那您的工作就完成了。</p><h4>一个实用的检查工具（建议）</h4><p>Namcap 是 Arch Linux 推荐的检查工具，它将会做以下工作：</p><ul><li>检查 PKGBUILD 文件里的一些常见错误；</li><li>用 <code>ldd</code> 扫描包中所有的ELF文件，自动报告缺失或可去除的依赖；</li><li>启发式搜寻缺失或冗余的依赖。</li></ul><p>要养成用 Namcap 检查包的习惯，以避免提交包后再做修复的麻烦。</p><p>打开 Konsole，使用 <code>cd</code> 命令进入您的文件夹，然后执行：</p><pre><code>namcap PKGBUILD</code></pre><h3>制作源码包</h3><p>后面的步骤都很简单了！打开 Konsole，使用 <code>cd</code> 命令进入您的文件夹，执行以下命令：</p><pre><code>makepkg --source</code></pre><p>这个命令实际上就是将文件夹里的文件打成一个包，但为了确认您的 PKGBUILD 中的校验值准确无误，PKGBUILD 中 <code>source</code> 一栏所有文件都会被下载下来以校验完整性，耐心等待就好。</p><p>输出内容大概是：</p><pre><code>==&gt; 正在进入 fakeroot 环境...
==&gt; 正在创建源码包...
  -&gt; 正在添加 PKGBUILD...
  -&gt; 正在生成 .SRCINFO 文件...
  -&gt; 正在压缩源码包...
==&gt; 正在离开 fakeroot 环境。
==&gt; 源代码包已创建：foo</code></pre><h3>将源码包上传到 CCR</h3><p>请确认您已经登录 CCR 帐户，接下来访问 <a href="https://ccr.chakralinux.org/pkgsubmit.php">上传页面</a>，选择软件包分类，接下来选择源码包，源码包应该位于您的文件夹中，包名应该是 <code>$pkgname-$pkgver.src.tar.gz</code>。</p><p><img src="https://bobby285271.coding.net/p/img/d/img/git/raw/master/ccr/9.png" alt="" title=""></p><p>点击「上传」即可。如果 CCR 里面本身没有这个包或这个包是一个无人维护的包（孤儿包），您将会成为维护者。CCR 里面旧版本的软件包将会被您的新软件包取代。如果这个包已经有维护者，CCR 会拒绝您的提交。如果您发现 CCR 里的包已经被标记为「过期」一段时间而维护者没有采取任何动作，您可以联系 Chakra 团队将该包重置为无人维护状态。</p>
]]></content>
<link rel="replies" type="text/html" href="https://static.bobby285271.top/index.php/2019/02/02/Chakra-CCR-Packaging-Guide.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://static.bobby285271.top/index.php/feed/atom/2019/02/02/Chakra-CCR-Packaging-Guide.html" thr:count="0"/>
</entry>
</feed>